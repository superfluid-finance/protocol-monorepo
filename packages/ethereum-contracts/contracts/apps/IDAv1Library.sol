// SPDX-License-Identifier: AGPLv3
pragma solidity >= 0.8.0;
pragma experimental ABIEncoderV2;

import {ISuperfluid, ISuperfluidToken} from "../interfaces/superfluid/ISuperfluid.sol";

import {
    IInstantDistributionAgreementV1
} from "../interfaces/agreements/IInstantDistributionAgreementV1.sol";

/// @title Instant Distribution Agreement V1 helper library for solidity development.
/// @author Superfluid
/// @dev Set a variable of type `InitData` in the contract, then call this library's functions
/// directly `initData.functionName()`.
library IDAv1Library {

    /// @dev Initialization data.
    /// @param host Superfluid host contract for calling agreements.
    /// @param ida Instant Distribution Agreement contract.
    struct InitData {
        ISuperfluid host;
        IInstantDistributionAgreementV1 ida;
    }

    /**************************************************************************
     * View Functions
     *************************************************************************/

    /// @dev Gets an index by its ID and publisher.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @return exist True if the index exists.
    /// @return indexValue Total value of the index.
    /// @return totalUnitsApproved Units of the index approved by subscribers.
    /// @return totalUnitsPending Units of teh index not yet approved by subscribers.
    function getIndex(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId
    )
        internal
        view
        returns (
            bool exist,
            uint128 indexValue,
            uint128 totalUnitsApproved,
            uint128 totalUnitsPending
        )
    {
        return idaLibrary.ida.getIndex(token, publisher, indexId);
    }

    /// @dev Calculates the distribution amount based on the amount of tokens desired to distribute.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param amount Amount of tokens desired to distribute.
    /// @return actualAmount Amount to be distributed with correct rounding.
    /// @return newIndexValue The index value after the distribution would be called.
    function calculateDistribution(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        uint256 amount
    )
        internal
        view
        returns (
            uint256 actualAmount,
            uint128 newIndexValue
        )
    {
        return idaLibrary.ida.calculateDistribution(token, publisher, indexId, amount);
    }

    /// @dev List all subscriptions of an address
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super token used in the indexes listed.
    /// @param subscriber Subscriber address.
    /// @return publishers Publishers of the indices.
    /// @return indexIds IDs of the indices.
    /// @return unitsList Units owned of the indices.
    function listSubscriptions(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address subscriber
    )
        internal
        view
        returns (
            address[] memory publishers,
            uint32[] memory indexIds,
            uint128[] memory unitsList
        )
    {
        return idaLibrary.ida.listSubscriptions(token, subscriber);
    }

    /// @dev Gets subscription by publisher, index id, and subscriber.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber to the index.
    /// @return exist True if the subscription exists.
    /// @return approved True if the subscription has been approved by the subscriber.
    /// @return units Units held by the subscriber
    /// @return pendingDistribution If not approved, the amount to be claimed on approval.
    function getSubscription(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber
    )
        internal
        view
        returns (
            bool exist,
            bool approved,
            uint128 units,
            uint256 pendingDistribution
        )
    {
        return idaLibrary.ida.getSubscription(token, publisher, indexId, subscriber);
    }

    /// @dev Gets subscription by the agreement ID.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param agreementId Agreement ID, unique to the subscriber and index ID.
    /// @return publisher Publisher of the index.
    /// @return indexId ID of the index.
    /// @return approved True if the subscription has been approved by the subscriber.
    /// @return units Units held by the subscriber
    /// @return pendingDistribution If not approved, the amount to be claimed on approval.
    function getSubscriptionByID(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        bytes32 agreementId
    )
        internal
        view
        returns (
            address publisher,
            uint32 indexId,
            bool approved,
            uint128 units,
            uint256 pendingDistribution
        )
    {
        return idaLibrary.ida.getSubscriptionByID(token, agreementId);
    }

    /**************************************************************************
     * Index Operations
     *************************************************************************/

    /// @dev Creates a new index.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    function createIndex(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId
    ) internal {
        createIndex(idaLibrary, token, indexId, new bytes(0));
    }

    /// @dev Creates a new index. This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param userData Arbitrary user data field.
    function createIndex(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.createIndex.selector,
                token,
                indexId,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Creates a new index in a super app callback.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    function createIndexWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId
    ) internal returns (bytes memory newCtx) {
        return createIndexWithCtx(idaLibrary, ctx, token, indexId, new bytes(0));
    }

    /// @dev Creates a new index in a super app callback. This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param userData Arbitrary user data field.
    function createIndexWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.createIndex.selector,
                token,
                indexId,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }

    /// @dev Updates an index value. This distributes an amount of tokens equal to
    /// `indexValue - lastIndexValue`. See `distribute` for another way to distribute. This takes
    /// arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.
    function updateIndexValue(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId,
        uint128 indexValue
    ) internal {
        updateIndexValue(idaLibrary, token, indexId, indexValue, new bytes(0));
    }

    /// @dev Updates an index value. This distributes an amount of tokens equal to
    /// `indexValue - lastIndexValue`. See `distribute` for another way to distribute.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.
    /// @param userData Arbitrary user data field.
    function updateIndexValue(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId,
        uint128 indexValue,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.updateIndex.selector,
                token,
                indexId,
                indexValue,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Updates an index value in a super app callback. This distributes an amount of tokens
    /// equal to `indexValue - lastIndexValue`. See `distribute` for another way to distribute.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.
    function updateIndexValueWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId,
        uint128 indexValue
    ) internal returns (bytes memory newCtx) {
        return updateIndexValueWithCtx(
            idaLibrary,
            ctx,
            token,
            indexId,
            indexValue,
            new bytes(0)
        );
    }

    /// @dev Updates an index value in a super app callback. This distributes an amount of tokens
    /// equal to `indexValue - lastIndexValue`. See `distribute` for another way to distribute.
    /// This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param indexValue New TOTAL index value, this will equal the total amount distributed.
    function updateIndexValueWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId,
        uint128 indexValue,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.updateIndex.selector,
                token,
                indexId,
                indexValue,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }

    /// @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of
    /// passing the new total index value, this function will increase the index value by `amount`.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param amount Amount by which the index value should increase.
    function distribute(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId,
        uint256 amount
    ) internal {
        distribute(idaLibrary, token, indexId, amount, new bytes(0));
    }

    /// @dev Distributes tokens in a more developer friendly way than `updateIndex`. Instead of
    /// passing the new total index value, this function will increase the index value by `amount`.
    /// This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param amount Amount by which the index value should increase.
    /// @param userData Arbitrary user data field.
    function distribute(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId,
        uint256 amount,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.distribute.selector,
                token,
                indexId,
                amount,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Distributes tokens in a super app callback. Instead of passing the new total index
    /// value, this function will increase the index value by `amount`.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param amount Amount by which the index value should increase.
    function distributeWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId,
        uint256 amount
    ) internal returns (bytes memory newCtx) {
        return distributeWithCtx(idaLibrary, ctx, token, indexId, amount, new bytes(0));
    }

    /// @dev Distributes tokens in a super app callback. Instead of passing the new total index
    /// value, this function will increase the index value by `amount`. This takes arbitrary user
    /// data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param amount Amount by which the index value should increase.
    /// @param userData Arbitrary user data field.
    function distributeWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId,
        uint256 amount,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida, 
            abi.encodeWithSelector(
                idaLibrary.ida.distribute.selector,
                token,
                indexId,
                amount,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }

    /**************************************************************************
     * Subscription Operations
     *************************************************************************/

    /// @dev Approves a subscription to an index. The subscriber's real time balance will not update
    /// until the subscription is approved, but once approved, the balance will be updated with
    /// prior distributions.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    function approveSubscription(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId
    ) internal {
        approveSubscription(idaLibrary, token, publisher, indexId, new bytes(0));
    }

    /// @dev Approves a subscription to an index. The subscriber's real time balance will not update
    /// until the subscription is approved, but once approved, the balance will be updated with
    /// prior distributions.
    /// This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param userData Arbitrary user data field.
    function approveSubscription(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.approveSubscription.selector,
                token,
                publisher,
                indexId,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Approves a subscription to an index in a super app callback. The subscriber's real time
    /// balance will not update until the subscription is approved, but once approved, the balance
    /// will be updated with prior distributions.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    function approveSubscriptionWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId
    ) internal returns (bytes memory newCtx) {
        return approveSubscriptionWithCtx(
            idaLibrary,
            ctx,
            token,
            publisher,
            indexId,
            new bytes(0)
        );
    }

    /// @dev Approves a subscription to an index in a super app callback. The subscriber's real time
    /// balance will not update until the subscription is approved, but once approved, the balance
    /// will be updated with prior distributions. This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param userData Arbitrary user data field.
    function approveSubscriptionWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.approveSubscription.selector,
                token,
                publisher,
                indexId,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }

    /// @dev Revokes a previously approved subscription.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    function revokeSubscription(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId
    ) internal {
        revokeSubscription(idaLibrary, token, publisher, indexId, new bytes(0));
    }

    /// @dev Revokes a previously approved subscription. This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param userData Arbitrary user data field.
    function revokeSubscription(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.revokeSubscription.selector,
                token,
                publisher,
                indexId,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Revokes a previously approved subscription in a super app callback.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    function revokeSubscriptionWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId
    ) internal returns (bytes memory newCtx) {
        return revokeSubscriptionWithCtx(
            idaLibrary,
            ctx,
            token,
            publisher,
            indexId,
            new bytes(0)
        );
    }

    /// @dev Revokes a previously approved subscription in a super app callback. This takes
    /// arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param userData Arbitrary user data field.
    function revokeSubscriptionWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.revokeSubscription.selector,
                token,
                publisher,
                indexId,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }

    /// @dev Updates the units of a subscription. This changes the number of shares the subscriber
    /// holds.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be updated.
    /// @param units New number of units the subscriber holds.
    function updateSubscriptionUnits(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId,
        address subscriber,
        uint128 units
    ) internal {
        updateSubscriptionUnits(idaLibrary, token, indexId, subscriber, units, new bytes(0));
    }

    /// @dev Updates the units of a subscription. This changes the number of shares the subscriber
    /// holds. This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be updated.
    /// @param units New number of units the subscriber holds.
    /// @param userData Arbitrary user data field.
    function updateSubscriptionUnits(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        uint32 indexId,
        address subscriber,
        uint128 units,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.updateSubscription.selector,
                token,
                indexId,
                subscriber,
                units,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Updates the units of a subscription in a super app callback. This changes the number of
    /// shares the subscriber holds.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be updated.
    /// @param units New number of units the subscriber holds.
    function updateSubscriptionUnitsWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId,
        address subscriber,
        uint128 units
    ) internal returns (bytes memory newCtx) {
        return updateSubscriptionUnitsWithCtx(
            idaLibrary,
            ctx,
            token,
            indexId,
            subscriber,
            units,
            new bytes(0)
        );
    }

    /// @dev Updates the units of a subscription in a super app callback. This changes the number of
    /// shares the subscriber holds. This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be updated.
    /// @param units New number of units the subscriber holds.
    /// @param userData Arbitrary user data field.
    function updateSubscriptionUnitsWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        uint32 indexId,
        address subscriber,
        uint128 units,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.updateSubscription.selector,
                token,
                indexId,
                subscriber,
                units,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }

    /// @dev Deletes a subscription, setting a subcriber's units to zero.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be deleted.
    function deleteSubscription(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber
    ) internal {
        deleteSubscription(idaLibrary, token, publisher, indexId, subscriber, new bytes(0));
    }

    /// @dev Deletes a subscription, setting a subcriber's units to zero. This takes arbitrary user
    /// data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be deleted.
    /// @param userData Arbitrary user data field.
    function deleteSubscription(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.deleteSubscription.selector,
                token,
                publisher,
                indexId,
                subscriber,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Deletes a subscription in a super app callback, setting a subcriber's units to zero.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be deleted.
    function deleteSubscriptionWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber
    ) internal returns (bytes memory newCtx) {
        return deleteSubscriptionWithCtx(
            idaLibrary,
            ctx,
            token,
            publisher,
            indexId,
            subscriber,
            new bytes(0)
        );
    }

    /// @dev Deletes a subscription in a super app callback, setting a subcriber's units to zero.
    /// This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param ctx Context byte string used by the Superfluid host.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address whose units are to be deleted.
    /// @param userData Arbitrary user data field.
    function deleteSubscriptionWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.deleteSubscription.selector,
                token,
                publisher,
                indexId,
                subscriber,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }

    /// @dev Claims pending distribution. Subscription should not be approved.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address that receives the claim.
    function claim(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber
    ) internal {
        claim(idaLibrary, token, publisher, indexId, subscriber, new bytes(0));
    }

    /// @dev Claims pending distribution. Subscription should not be approved. This takes arbitrary
    /// user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address that receives the claim.
    /// @param userData Arbitrary user data field.
    function claim(
        InitData storage idaLibrary,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber,
        bytes memory userData
    ) internal {
        idaLibrary.host.callAgreement(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.claim.selector,
                token,
                publisher,
                indexId,
                subscriber,
                new bytes(0) // ctx placeholder
            ),
            userData
        );
    }

    /// @dev Claims pending distribution in a super app callback. Subscription should not be
    /// approved.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address that receives the claim.
    function claimWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber
    ) internal returns (bytes memory newCtx) {
        return claimWithCtx(
            idaLibrary,
            ctx,
            token,
            publisher,
            indexId,
            subscriber,
            new bytes(0)
        );
    }

    /// @dev Claims pending distribution in a super app callback. Subscription should not be
    /// approved. This takes arbitrary user data.
    /// @param idaLibrary Storage pointer to host and ida interfaces.
    /// @param token Super Token used with the index.
    /// @param publisher Publisher of the index.
    /// @param indexId ID of the index.
    /// @param subscriber Subscriber address that receives the claim.
    /// @param userData Arbitrary user data field.
    function claimWithCtx(
        InitData storage idaLibrary,
        bytes memory ctx,
        ISuperfluidToken token,
        address publisher,
        uint32 indexId,
        address subscriber,
        bytes memory userData
    ) internal returns (bytes memory newCtx) {
        (newCtx, ) = idaLibrary.host.callAgreementWithContext(
            idaLibrary.ida,
            abi.encodeWithSelector(
                idaLibrary.ida.claim.selector,
                token,
                publisher,
                indexId,
                subscriber,
                new bytes(0) // ctx placeholder
            ),
            userData,
            ctx
        );
    }
}
