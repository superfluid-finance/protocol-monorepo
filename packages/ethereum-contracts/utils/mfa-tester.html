<!DOCTYPE html>
<html>

<head>
    <title>Multi Flow SuperApp Tester</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" />
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.6.0/dist/ethers.umd.min.js"
        integrity="sha256-I/T7C/qM1p/EIawMnVp+b68aGIgHpiaW5uJm8Xd/WYg=" crossorigin="anonymous"></script>

    <!-- sdk-core -->
    <script src="./index.umd.js"></script>
    <!-- vue.js -->
    <script type="importmap">
        {
            "imports": {
                "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
        }
    </script>
    <style>
        label {
            display: table-cell;
        }

        input {
            display: table-cell;
        }

        p {
            margin-bottom: 0;
        }

        .input-table {
            display: table;
        }

        .input-container {
            display: table-row;
        }

        .receiver-container {
            margin-bottom: 1rem;
        }

        .loading {
            width: 100vw;
            height: 100vh;
            z-index: 2;
            position: absolute;
            background-color: black;
            opacity: 0.3;
            top: 0;
            left: 0;
            color: white;
        }
    </style>

</head>

<body>
    <script type="module">
        import { computed, createApp, reactive, ref, onMounted, watch } from 'vue';

        const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
        const RESOLVER_ADDRESS = "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512";
        const MFA_ADDRESS = "0x9E545E3C0baAB3E08CdfD552C960A1050f373042";
        const EMPTY_RECEIVER = { address: ZERO_ADDRESS, proportion: "0" };
        const RESET_SNAPSHOT_ID = "RESET_SNAPSHOT";

        createApp({
            setup() {
                let framework;
                let token;
                let passedSigner;
                const provider = new ethers.providers.JsonRpcProvider("http://127.0.0.1:8545/");
                const abiCoder = new ethers.utils.AbiCoder();

                // computed properties
                const mfaData = reactive({ ratioPct: "", flowRate: "", mfaAddress: MFA_ADDRESS, signerAddress: "" });
                const receivers = reactive([]); // Array<{ address: string, proportion: string }>
                const accounts = reactive([]); // Array<string>
                const tokenData = reactive({
                    address: "",
                    balance: 0,
                    name: "",
                    underlyingAddress: "",
                    underlyingBalance: 0,
                    underlyingName: "",
                });
                const balanceData = reactive({
                    sender: {},
                    mfa: {},
                    receivers: []
                });
                const agreementData = reactive({
                    senderToMfa: {},
                    mfaToReceivers: []
                });

                const receiverAddresses = computed(() => receivers.map(x => x.address));
                const filteredReceivers = computed(() => receivers.filter(x => x.proportion > 0));
                const signerAddress = computed(() => signer && signer.value ? signer.value._address : "n/a");
                const providerNetwork = computed(() => provider && provider ? provider._network : "n/a");

                // reactive refs
                const selected = ref("");
                const currentToken = ref("ETHx");
                const currentReceiverAddress = ref("");
                const currentReceiverProportion = ref("");
                const impersonatedSignerAddress = ref("");
                const signer = ref(null);
                const loading = ref(true);

                // watchers
                watch(selected, (receiverAddress) => {
                    const receiver = receivers.find(x => x.address === receiverAddress);
                    if (receiver) {
                        currentReceiverProportion.value = receiver.proportion;
                        currentReceiverAddress.value = receiverAddress;
                    }
                });
                watch(signer, async (signer) => {
                    if (token) {
                        const { superTokenBalanceData, underlyingBalance } = await getBalanceData(signer._address);
                        tokenData.balance = superTokenBalanceData.availableBalance;
                        tokenData.underlyingBalance = underlyingBalance;
                    }
                });
                watch(accounts, async (accounts) => {
                    try {
                        if (accounts.length > 0) {
                            await initialize();
                            const { superTokenBalanceData } = await getBalanceData(signer.value._address);
                                const signers = await getSigners();
                            if (Number(superTokenBalanceData.availableBalance) === 0) {
                                const signers = await getSigners();
                                const upgradePromise = signers.map(x => upgradeToSuperToken(x));
                                await Promise.all(upgradePromise);
                            }
                        }
                        if (!sessionStorage.getItem(RESET_SNAPSHOT_ID)) {
                            const snapshotId = await takeSnapshotAndReturnId();
                            sessionStorage.setItem(RESET_SNAPSHOT_ID, snapshotId);
                        }
                    } catch (err) {
                        console.error(err);
                    } finally {
                        loading.value = false;
                    }
                });

                // form validation
                const hasValidUpdateReceiverInput = () => {
                    return isAddress(currentReceiverAddress.value)
                        && (currentReceiverProportion.value === 0
                            || currentReceiverProportion.value === 1);
                }
                const hasValidMFAInput = () => {
                    return mfaData.ratioPct !== ""
                        && mfaData.flowRate !== ""
                        && isAddress(mfaData.signerAddress)
                        && filteredReceivers.value.length > 0;
                }
                const isAddress = (address) => {
                    return ethers.utils.isAddress(address);
                }

                // receivers crud
                const addReceiver = () => {
                    let newAddress;
                    if (currentReceiverAddress.value !== "" || currentReceiverProportion.value !== "") {
                        if (!hasValidUpdateReceiverInput() || receiverAddresses.value.includes(currentReceiverAddress.value)) {
                            window.alert("what are ya doing");
                            return;
                        }

                        const currentData = {
                            address: currentReceiverAddress.value,
                            proportion: currentReceiverProportion.value
                        };
                        receivers.push(currentData);
                        newAddress = currentReceiverAddress.value;
                    } else {
                        if (receiverAddresses.value.includes(EMPTY_RECEIVER.address)) {
                            window.alert("what are ya doing");
                            return;
                        }
                        receivers.push(EMPTY_RECEIVER);
                        newAddress = EMPTY_RECEIVER.address;
                    }
                    selected.value = newAddress;
                };
                const updateReceiver = () => {
                    if (!hasValidUpdateReceiverInput()) {
                        window.alert("what are ya doing");
                        return;
                    }
                    const i = receivers.map(x => x.address).indexOf(selected.value);
                    receivers[i].address = selected.value = currentReceiverAddress.value;
                    receivers[i].proportion = currentReceiverProportion.value;
                    selected.value = currentReceiverAddress.value = currentReceiverProportion.value = "";
                };
                const removeReceiver = (receiver) => {
                    const i = receivers.map(x => x.address).indexOf(selected.value);
                    receivers.splice(i, 1);
                    selected.value = currentReceiverAddress.value = currentReceiverProportion.value = ""
                };

                // data formatting
                const toBN = (num) => ethers.BigNumber.from(num);
                const getPerSecondFlowRateByDay = (amountPerDay) => {
                    return Math.round(
                        (Number(amountPerDay) / 86400) * 10 ** 18
                    ).toString();
                };
                const getMFAUserData = () => {
                    return abiCoder.encode(
                        [
                            "address",
                            "uint256",
                            "address[]",
                            "uint256[]"
                        ],
                        [
                            mfaData.signerAddress,
                            mfaData.ratioPct || "0",
                            filteredReceivers.value.map(x => x.address),
                            filteredReceivers.value.map(x => x.proportion)
                        ]);
                }

                // text formatting
                const formatBalance = (balance) => Number(ethers.utils.formatEther(balance || "0")).toFixed(8);

                // async
                const getBalanceData = async (signerAddress) => {
                    const isNativeAsset = token.nativeTokenSymbol !== "";
                    const balanceData = await token.realtimeBalanceOf({
                        providerOrSigner: provider,
                        account: signerAddress
                    })

                    const underlyingBalance = await provider.getBalance(signerAddress);
                    return { superTokenBalanceData: balanceData, underlyingBalance };
                }
                const getFlowData = async (sender, receiver) =>
                ({
                    ...await token.getFlow({
                        sender,
                        receiver,
                        providerOrSigner: provider
                    }),
                    address: receiver
                });
                const getAccountNetFlow = async (account) =>
                    await token.getNetFlow({
                        account,
                        providerOrSigner: provider
                    });
                const getFlowAndBalanceData = async (account) => {
                    const { superTokenBalanceData } = await getBalanceData(account);
                    const flowRate = await getAccountNetFlow(account);
                    return {
                        availableBalance: superTokenBalanceData.availableBalance,
                        deposit: superTokenBalanceData.deposit,
                        owedDeposit: superTokenBalanceData.owedDeposit,
                        flowRate,
                        address: account
                    };
                }
                const loadToken = async () => {
                    const superToken = await framework.loadSuperToken(currentToken.value);
                    token = superToken;
                    tokenData.address = superToken.address;
                    if (signer.value) {
                        const { superTokenBalanceData, underlyingBalance } = await getBalanceData(signer.value._address);
                        tokenData.balance = superTokenBalanceData.availableBalance;
                        tokenData.underlyingBalance = underlyingBalance;
                    }
                    tokenData.name = await superToken.symbol({
                        providerOrSigner: provider
                    });
                    tokenData.underlyingName = superToken.nativeTokenSymbol
                        || await superToken.underlyingToken.connect(provider).symbol();
                }
                const getAccounts = async () => {
                    const ethAccounts = await provider.listAccounts();
                    accounts.push(...ethAccounts);
                }
                const getSigners = async () => {
                    const signersPromise = accounts.map(x => provider.getSigner(x));
                    return await Promise.all(signersPromise);
                }
                const impersonateAccount = async () => {
                    await provider.send(
                        "hardhat_impersonateAccount",
                        [mfaData.signerAddress]
                    );
                    const ethersSigner = await provider.getSigner(mfaData.signerAddress);
                    signer.value = ethersSigner;
                    passedSigner = ethersSigner;
                }
                const takeSnapshotAndReturnId = async () => {
                    return await provider.send(
                        "evm_snapshot",
                        []
                    );
                }
                const revertToSnapshot = async (snapshotId) => {
                    await provider.send(
                        "evm_revert",
                        [snapshotId]
                    );
                    return await takeSnapshotAndReturnId();
                }
                const resetState = async () => {
                    try {
                        const snapshotId = sessionStorage.getItem(RESET_SNAPSHOT_ID);
                        const newId = await revertToSnapshot(snapshotId);
                        sessionStorage.setItem(RESET_SNAPSHOT_ID, newId);
                        await setupData();
                    } catch (err) {
                        console.error(err);
                    }
                }
                const setupData = async () => {
                    const senderData = await getFlowAndBalanceData(mfaData.signerAddress);
                    const mfaFlowData = await getFlowAndBalanceData(mfaData.mfaAddress);
                    const mfaToReceiversData = await Promise.all(
                        accounts.map(x => getFlowData(mfaData.mfaAddress, x))
                    );
                    const mfaReceivers = mfaToReceiversData.filter(x => x.flowRate > 0).map(x => x.address);
                    const filteredReceiversData = await Promise.all(mfaReceivers.map(x => getFlowAndBalanceData(x)));
                    balanceData.sender = senderData;
                    balanceData.mfa = mfaFlowData;
                    balanceData.receivers = filteredReceiversData;

                    agreementData.senderToMfa = await getFlowData(mfaData.signerAddress, mfaData.mfaAddress);
                    agreementData.mfaToReceivers = await Promise.all(mfaReceivers.map(x => getFlowData(mfaData.mfaAddress, x)));
                    receivers.splice(0, receivers.length);
                    receivers.push(
                        ...filteredReceiversData.map(x => ({ address: x.address, proportion: 1 }))
                    );
                }
                /** initialize signer, framework, token */
                const initialize = async () => {
                    mfaData.signerAddress = accounts[0];
                    await impersonateAccount();
                    const sf = await sdkCore.Framework.create({
                        chainId: 31337,
                        provider: provider,
                        resolverAddress: RESOLVER_ADDRESS,
                        protocolReleaseVersion: "test",
                    });
                    framework = sf;
                    await loadToken();
                    await setupData();
                }

                // transaction functions
                const upgradeToSuperToken = async (signer) => {
                    const ethBalance = await provider.getBalance(signer._address);
                    await token.upgrade({ amount: ethBalance.div(toBN(2)) }).exec(signer);
                }
                const modifyStream = async (action) => {
                    loading.value = true;
                    try {
                        console.log("modifying stream:", action);
                        if (signer.value == null) {
                            await impersonateAccount();
                        }
                        const s = await provider.getSigner(signer.value._address);
                        const txn = action === "create" ?
                            await token.createFlow({
                                receiver: mfaData.mfaAddress || MFA_ADDRESS,
                                flowRate: getPerSecondFlowRateByDay(mfaData.flowRate),
                                userData: getMFAUserData()
                            }).exec(s)
                            : action === "update"
                                ? await token.updateFlow({
                                    receiver: mfaData.mfaAddress || MFA_ADDRESS,
                                    flowRate: getPerSecondFlowRateByDay(mfaData.flowRate),
                                    userData: getMFAUserData()
                                }).exec(s)
                                : await token.deleteFlow({
                                    sender: signer.value._address,
                                    receiver: mfaData.mfaAddress || MFA_ADDRESS,
                                    userData: getMFAUserData()
                                }).exec(s);
                        const receipt = await txn.wait();

                        console.log(receipt);
                        await setupData();
                    } catch (err) {
                        console.error(err);
                    } finally {
                        loading.value = false;
                    }
                }

                // initialization
                getAccounts();

                return {
                    addReceiver,
                    formatBalance,
                    hasValidMFAInput,
                    impersonateAccount,
                    isAddress,
                    loadToken,
                    removeReceiver,
                    resetState,
                    modifyStream,
                    updateReceiver,

                    accounts,
                    agreementData,
                    balanceData,
                    currentReceiverAddress,
                    currentReceiverProportion,
                    currentToken,
                    filteredReceivers,
                    impersonatedSignerAddress,
                    loading,
                    mfaData,
                    providerNetwork,
                    receiverAddresses,
                    receivers,
                    selected,
                    signer,
                    signerAddress,
                    token,
                    tokenData,
                }
            }
        }).mount('#app')
    </script>
</body>
<div id="app">
    <h1 class="loading d-flex justify-content-center align-items-center" v-if="loading">loading...</h1>
    <div class="p-3">
        <h2 class="d-flex justify-content-center">
            Multi Flow SuperApp Tester
        </h2>
        <div class="d-flex justify-content-center">
            <div>
                <div>
                    <h4>General Information</h4>
                    <p>
                        Selected Token: {{ tokenData.name }} | {{
                        tokenData.address }}
                    </p>
                    <p>MFA Address: {{ mfaData.mfaAddress }}</p>
                    <p>Selected Impersonated Signer: {{ signerAddress }}</p>
                    <p>
                        Token Balance: {{ formatBalance(tokenData.balance)
                        }} {{ tokenData.name }}
                    </p>
                    <p>
                        Underlying Balance: {{
                        formatBalance(tokenData.underlyingBalance) }} {{
                        tokenData.underlyingName}}
                    </p>
                </div>
                <div class="input-table mt-3">
                    <div class="input-container">
                        <label for="signerAddress">Signer</label>
                        <input class="ml-2" type="text" v-model="mfaData.signerAddress" name="signerAddress" />
                        <button type="button" class="btn btn-dark" @click="impersonateAccount"
                            :disabled="!isAddress(mfaData.signerAddress)">
                            Impersonate
                        </button>
                    </div>
                    <div class="input-container">
                        <label for="mfaAddress">MFA Address</label>
                        <input class="ml-2" type="text" v-model="mfaData.mfaAddress" name="mfaAddress" />
                    </div>
                    <div class="input-container">
                        <label for="signerAddress">Token</label>
                        <input class="ml-2" type="text" v-model="currentToken" name="currentToken" />
                        <button type="button" class="btn btn-dark" @click="loadToken">Load Token</button>
                    </div>
                    <div class="input-container">
                        <label for="ratioPct">Ratio Percent</label>
                        <input class="ml-2" type="number" v-model="mfaData.ratioPct" name="ratioPct" />
                    </div>
                    <div class="input-container">
                        <label for="flowRate">Flow Rate (/day)</label>
                        <input class="ml-2" type="number" v-model="mfaData.flowRate" name="flowRate" />
                    </div>
                </div>
                <div class="mt-3">
                    <h4>Receivers</h4>
                    <select class="mb-3" style="width: 420px" size="5" v-model="selected">
                        <option v-for="receiverAddress in receiverAddresses">
                            {{receiverAddress}}
                        </option>
                    </select>
                    <div class="input-container">
                        <label for="currentReceiverAddress">Receiver Address</label>
                        <input class="ml-2" type="text" size="50" v-model="currentReceiverAddress"
                            name="currentReceiverAddress" />
                    </div>
                    <div class="input-container">
                        <label for="currentReceiverProportion">Receiver Proportion</label>
                        <input class="ml-2" style="width: 69px" type="number" min="0" max="1"
                            v-model="currentReceiverProportion" name="currentReceiverProportion" />
                    </div>
                    <div class="d-flex justify-content-around mt-3 mb-3">
                        <button type="button" class="btn btn-dark" @click="addReceiver">Add receiver</button>
                        <button type="button" class="btn btn-dark" @click="updateReceiver" :disabled='selected === ""'>
                            Update receiver
                        </button>
                        <button type="button" class="btn btn-dark" @click="removeReceiver" :disabled='selected === ""'>
                            Remove receiver
                        </button>
                    </div>
                </div>
                <div class="d-flex justify-content-around mb-3">
                    <button type="button" class="btn btn-dark" @click='modifyStream("create")'
                        :disabled="hasValidMFAInput() === false">
                        Start Stream
                    </button>
                    <button type="button" class="btn btn-dark" @click='modifyStream("update")'
                        :disabled="hasValidMFAInput() === false">
                        Update Stream
                    </button>
                    <button type="button" class="btn btn-dark" @click='modifyStream("delete")'>
                        Delete Stream
                    </button>
                </div>
                <button type="button" class="btn btn-danger" @click="resetState">
                    Reset to initial state
                </button>
            </div>
            <div>
                <h4>Accounts</h4>
                <ul>
                    <li v-for="account in accounts">{{ account }}</li>
                </ul>
            </div>
        </div>
        <h4>Account State</h4>
        <div class="mfa-flows-container d-flex align-items-center justify-content-around">
            <div class="account-container">
                <b>Sender</b>
                <p>available balance: {{ formatBalance(balanceData.sender.availableBalance) }}</p>
                <p>deposit: {{ formatBalance(balanceData.sender.deposit) }}</p>
                <p>owed deposit: {{ formatBalance(balanceData.sender.owedDeposit) }}</p>
                <p>net flow rate: {{ formatBalance(balanceData.sender.flowRate) }}</p>
            </div>
            <div class="account-container">
                <b>MFA</b>
                <p>available balance: {{ formatBalance(balanceData.mfa.availableBalance) }}</p>
                <p>deposit: {{ formatBalance(balanceData.mfa.deposit) }}</p>
                <p>owed deposit: {{ formatBalance(balanceData.mfa.owedDeposit) }}</p>
                <p>net flow rate: {{ formatBalance(balanceData.mfa.flowRate) }}</p>
            </div>
            <div class="d-flex flex-column">
                <div class="receiver-container" v-for="(receiver, i) in balanceData.receivers">
                    <b>Receiver {{ i + 1 }}: {{ receiver.address.substring(0, 6) }}</b>
                    <p>available balance: {{ formatBalance(receiver.availableBalance) }}</p>
                    <p>deposit: {{ formatBalance(receiver.deposit) }}</p>
                    <p>owed deposit: {{ formatBalance(receiver.owedDeposit) }}</p>
                    <p>net flow rate: {{ formatBalance(receiver.flowRate) }}</p>
                </div>
            </div>
        </div>
        <h4 class="mt-5">Agreement State</h4>
        <div class="mfa-flow-agreements-container d-flex align-items-center justify-content-around">
            <div class="account-container">
                <b>Sender -> MFA</b>
                <p>deposit: {{ formatBalance(agreementData.senderToMfa.deposit) }}</p>
                <p>owed deposit: {{ formatBalance(agreementData.senderToMfa.owedDeposit) }}</p>
                <p>flow rate: {{ formatBalance(agreementData.senderToMfa.flowRate) }}</p>
            </div>

            <div class="d-flex flex-column">
                <div class="receiver-container" v-for="(receiver, i) in agreementData.mfaToReceivers">
                    <b>MFA -> Receiver {{ i + 1 }}: {{ receiver.address.substring(0, 6) }}</b>
                    <p>deposit: {{ formatBalance(receiver.deposit) }}</p>
                    <p>owed deposit: {{ formatBalance(receiver.owedDeposit) }}</p>
                    <p>net flow rate: {{ formatBalance(receiver.flowRate) }}</p>
                </div>
            </div>
        </div>
    </div>
</div>

</html>