<!DOCTYPE html>
<html>

<head>
    <title>Multi Flow SuperApp Tester</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css"
        integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous" />
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.6.0/dist/ethers.umd.min.js"
        integrity="sha256-I/T7C/qM1p/EIawMnVp+b68aGIgHpiaW5uJm8Xd/WYg=" crossorigin="anonymous"></script>
    <script src="./index.umd.js"></script>
    <script type="importmap">
            {
                "imports": {
                    "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
                }
            }
        </script>
</head>

<body>
    <script type="module">
        import { computed, createApp, reactive, ref, onMounted, watch } from 'vue';

        const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
        const EMPTY_RECEIVER = { address: ZERO_ADDRESS, proportion: "0" };

        createApp({
            setup() {
                let framework;
                let token;
                let passedSigner;
                const provider = new ethers.providers.JsonRpcProvider("http://127.0.0.1:8545/");
                const abiCoder = new ethers.utils.AbiCoder();
                const mfaData = reactive({ ratioPct: "", flowRate: "", signerAddress: "" });
                const receivers = reactive([]); // Array<{ address: string, proportion: string }>
                const accounts = reactive([]); // Array<string>
                const tokenData = reactive({
                    address: "",
                    balance: 0,
                    name: "",
                    underlyingAddress: "",
                    underlyingBalance: 0,
                    underlyingName: "",
                });
                const receiverAddresses = computed(() => receivers.map(x => x.address));
                const filteredReceivers = computed(() => receivers.filter(x => x.proportion > 0));
                const signerAddress = computed(() => signer && signer.value ? signer.value._address : "pepe");
                const providerNetwork = computed(() => provider && provider ? provider._network : "pepe");

                const selected = ref("");
                const currentToken = ref("");
                const currentReceiverAddress = ref("");
                const currentReceiverProportion = ref("");
                const impersonatedSignerAddress = ref("");
                const signer = ref(null);

                watch(selected, (receiverAddress) => {
                    const receiver = receivers.find(x => x.address === receiverAddress);
                    if (receiver) {
                        currentReceiverProportion.value = receiver.proportion;
                        currentReceiverAddress.value = receiverAddress;
                    }
                });
                watch(signer, (signer) => {
                    if (token) {
                        // const balance = await
                    }
                });
                watch(accounts, async (accounts) => {
                    if (accounts.length > 0) {
                        await initialize();
                        await initializeFramework();
                        await loadToken();
                        const { superTokenBalanceData } = await getBalanceData();
                        if (Number(superTokenBalanceData.availableBalance) === 0) {
                            const signers = await getSigners();
                            const upgradePromise = signers.map(x => upgradeToSuperToken(x));
                            await Promise.all(upgradePromise);
                            await loadToken(); // NOTE REPLACE THIS WITH JUST BALANCE UPDATING
                        }
                    }
                });

                // VALIDATORS
                const hasValidUpdateReceiverInput = () => {
                    return isAddress(currentReceiverAddress.value)
                        && (currentReceiverProportion.value === 0
                            || currentReceiverProportion.value === 1);
                }
                const hasValidMFAInput = () => {
                    return mfaData.ratioPct !== ""
                        && mfaData.flowRate !== ""
                        && isAddress(mfaData.signerAddress)
                        && filteredReceivers.value.length > 0;
                }
                const isAddress = (address) => {
                    return ethers.utils.isAddress(address);
                }

                // CRUD
                const addReceiver = () => {
                    let newAddress;
                    if (currentReceiverAddress.value !== "" || currentReceiverProportion.value !== "") {
                        if (!hasValidUpdateReceiverInput() || receiverAddresses.value.includes(currentReceiverAddress.value)) {
                            window.alert("what are ya doing");
                            return;
                        }

                        const currentData = {
                            address: currentReceiverAddress.value,
                            proportion: currentReceiverProportion.value
                        };
                        receivers.push(currentData);
                        newAddress = currentReceiverAddress.value;
                    } else {
                        if (receiverAddresses.value.includes(EMPTY_RECEIVER.address)) {
                            window.alert("what are ya doing");
                            return;
                        }
                        receivers.push(EMPTY_RECEIVER);
                        newAddress = EMPTY_RECEIVER.address;
                    }
                    selected.value = newAddress;
                };
                const updateReceiver = () => {
                    if (!hasValidUpdateReceiverInput()) {
                        window.alert("what are ya doing");
                        return;
                    }
                    const i = receivers.map(x => x.address).indexOf(selected.value);
                    receivers[i].address = selected.value = currentReceiverAddress.value;
                    receivers[i].proportion = currentReceiverProportion.value;
                    selected.value = currentReceiverAddress.value = currentReceiverProportion.value = "";
                };
                const removeReceiver = (receiver) => {
                    const i = receivers.map(x => x.address).indexOf(selected.value);
                    receivers.splice(i, 1);
                    selected.value = currentReceiverAddress.value = currentReceiverProportion.value = ""
                };

                // DATA MOLDING
                const getPerSecondFlowRateByDay = (amountPerDay) => {
                    return Math.round(
                        (Number(amountPerDay) / 86400) * 10 ** 18
                    ).toString();
                };

                const getMFAUserData = () => {
                    return abiCoder.encode(
                        [
                            "address",
                            "uint256",
                            "address[]",
                            "uint256[]"
                        ],
                        [
                            mfaData.signerAddress,
                            mfaData.ratioPct,
                            filteredReceivers.value.map(x => x.address),
                            filteredReceivers.value.map(x => x.proportion)
                        ]);
                }

                // FORMATTING
                const formatBalance = (balance) => ethers.utils.formatEther(balance);

                const initializeFramework = async () => {
                    const sf = await sdkCore.Framework.create({
                        chainId: 31337,
                        provider: provider,
                        resolverAddress: "0xe7f1725e7734ce288f8367e1bb143e90bb3f0512",
                        protocolReleaseVersion: "test",
                    });
                    framework = sf;
                }
                const getBalanceData = async () => {
                    const signerAddress = signer.value._address;
                    const balanceData = await token.realtimeBalanceOf({
                        providerOrSigner: provider,
                        account: signerAddress
                    });
                    const underlyingBalance = await provider.getBalance(signerAddress);
                    return { superTokenBalanceData: balanceData, underlyingBalance };
                }
                const loadToken = async () => {
                    const ethX = await framework.loadNativeAssetSuperToken("ETHx");
                    token = ethX;
                    tokenData.address = ethX.address;
                    if (signer.value) {
                        const { superTokenBalanceData, underlyingBalance } = await getBalanceData();
                        tokenData.balance = superTokenBalanceData.availableBalance;
                        tokenData.underlyingBalance = underlyingBalance;
                    }
                    tokenData.name = await ethX.symbol({
                        providerOrSigner: provider
                    });
                    tokenData.underlyingName = "ETH";
                }
                const getAccounts = async () => {
                    const ethAccounts = await provider.listAccounts();
                    accounts.push(...ethAccounts);
                }
                const getSigners = async () => {
                    const signersPromise = accounts.map(x => provider.getSigner(x));
                    return await Promise.all(signersPromise);
                }
                const impersonateAccount = async () => {
                    await provider.send(
                        "hardhat_impersonateAccount",
                        [mfaData.signerAddress]
                    );
                    const ethersSigner = await provider.getSigner(mfaData.signerAddress);
                    signer.value = ethersSigner;
                    passedSigner = ethersSigner;
                }
                const initialize = async () => {
                    mfaData.signerAddress = accounts[0];
                    await impersonateAccount();
                }

                // TXNs
                const upgradeToSuperToken = async (signer) => {
                    const ethBalance = await provider.getBalance(signer._address);
                    await token.upgrade({ amount: ethBalance.div(toBN(2)) }).exec(signer);
                }
                const startStream = async () => {
                    if (signer.value == null) {
                        await impersonateAccount();
                    }
                    const s = await provider.getSigner(signer.value._address);
                    await token.createFlow({
                        receiver: "0x9e545e3c0baab3e08cdfd552c960a1050f373042", // MFA
                        flowRate: getPerSecondFlowRateByDay(mfaData.flowRate),
                        userData: getMFAUserData()
                    }).exec(s);
                }
                const toBN = (num) => ethers.BigNumber.from(num);

                // INITIALIZATIONS
                getAccounts();

                return {
                    addReceiver,
                    formatBalance,
                    hasValidMFAInput,
                    impersonateAccount,
                    isAddress,
                    loadToken,
                    removeReceiver,
                    startStream,
                    updateReceiver,

                    accounts,
                    currentReceiverAddress,
                    currentReceiverProportion,
                    currentToken,
                    filteredReceivers,
                    impersonatedSignerAddress,
                    mfaData,
                    providerNetwork,
                    receiverAddresses,
                    receivers,
                    selected,
                    signer,
                    signerAddress,
                    token,
                    tokenData,
                }
            }
        }).mount('#app')
    </script>
</body>
<div id="app">
    <div class="p-3">
        <h2 class="d-flex justify-content-center">
            Multi Flow SuperApp Tester
        </h2>
        <div class="d-flex justify-content-center">
            <div>
                <div>
                    <h4>General Information</h4>
                    <p>Selected Impersonated Signer: {{ signerAddress }}</p>
                    <p>
                        Selected Token: {{ tokenData.name }} | {{
                        tokenData.address }}
                    </p>
                    <p>
                        Token Balance: {{ formatBalance(tokenData.balance)
                        }} {{ tokenData.name }}
                    </p>
                    <p>
                        Underlying Balance: {{
                        formatBalance(tokenData.underlyingBalance) }} {{
                        tokenData.underlyingName}}
                    </p>
                </div>
                <div class="input-container d-flex">
                    <label for="signerAddress">Signer</label>
                    <input class="ml-2" type="text" v-model="mfaData.signerAddress" name="signerAddress" />
                    <button @click="impersonateAccount" :disabled="!isAddress(mfaData.signerAddress)">
                        Impersonate
                    </button>
                </div>
                <div class="input-container d-flex">
                    <label for="signerAddress">Token</label>
                    <input class="ml-2" type="text" v-model="currentToken" name="currentToken" />
                    <button @click="loadToken">Load Token</button>
                </div>
                <div class="input-container">
                    <label for="ratioPct">Ratio Percent</label>
                    <input class="ml-2" type="number" v-model="mfaData.ratioPct" name="ratioPct" />
                </div>
                <div class="input-container">
                    <label for="flowRate">Flow Rate (/day)</label>
                    <input class="ml-2" type="number" v-model="mfaData.flowRate" name="flowRate" />
                </div>
                <div class="mt-5">
                    <h4>Receivers</h4>
                    <select style="width: 420px" size="5" v-model="selected">
                        <option v-for="receiverAddress in receiverAddresses">
                            {{receiverAddress}}
                        </option>
                    </select>
                    <div class="input-container">
                        <label for="currentReceiverAddress">Receiver Address</label>
                        <input class="ml-2" type="text" size="50" v-model="currentReceiverAddress"
                            name="currentReceiverAddress" />
                    </div>
                    <div class="input-container">
                        <label for="currentReceiverProportion">Receiver Proportion</label>
                        <input class="ml-2" style="width: 69px" type="number" min="0" max="1"
                            v-model="currentReceiverProportion" name="currentReceiverProportion" />
                    </div>
                    <button @click="addReceiver">Add receiver</button>
                    <button @click="updateReceiver" :disabled='selected === ""'>
                        Update receiver
                    </button>
                    <button @click="removeReceiver" :disabled='selected === ""'>
                        Remove receiver
                    </button>
                </div>
                <button @click="startStream" :disabled="hasValidMFAInput() === false">
                    Start Stream
                </button>
            </div>
            <div>
                <h4>Accounts</h4>
                <ul>
                    <li v-for="account in accounts">{{ account }}</li>
                </ul>
            </div>
        </div>
    </div>
</div>

</html>