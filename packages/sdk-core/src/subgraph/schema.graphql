"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

"""
Account: A higher order entity created for any addresses which interact with
Superfluid contracts.

"""
type Account {
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  Indicates whether the address/account is a super app.
  
  """
  isSuperApp: Boolean!
  inflows(skip: Int = 0, first: Int = 100, orderBy: Stream_orderBy, orderDirection: OrderDirection, where: Stream_filter): [Stream!]!
  outflows(skip: Int = 0, first: Int = 100, orderBy: Stream_orderBy, orderDirection: OrderDirection, where: Stream_filter): [Stream!]!
  subscriptions(skip: Int = 0, first: Int = 100, orderBy: IndexSubscription_orderBy, orderDirection: OrderDirection, where: IndexSubscription_filter): [IndexSubscription!]!
  publishedIndexes(skip: Int = 0, first: Int = 100, orderBy: Index_orderBy, orderDirection: OrderDirection, where: Index_filter): [Index!]!
  sentTransferEvents(skip: Int = 0, first: Int = 100, orderBy: TransferEvent_orderBy, orderDirection: OrderDirection, where: TransferEvent_filter): [TransferEvent!]!
  receivedTransferEvents(skip: Int = 0, first: Int = 100, orderBy: TransferEvent_orderBy, orderDirection: OrderDirection, where: TransferEvent_filter): [TransferEvent!]!
  tokenUpgradedEvents(skip: Int = 0, first: Int = 100, orderBy: TokenUpgradedEvent_orderBy, orderDirection: OrderDirection, where: TokenUpgradedEvent_filter): [TokenUpgradedEvent!]!
  tokenDowngradedEvents(skip: Int = 0, first: Int = 100, orderBy: TokenDowngradedEvent_orderBy, orderDirection: OrderDirection, where: TokenDowngradedEvent_filter): [TokenDowngradedEvent!]!
  accountTokenSnapshots(skip: Int = 0, first: Int = 100, orderBy: AccountTokenSnapshot_orderBy, orderDirection: OrderDirection, where: AccountTokenSnapshot_filter): [AccountTokenSnapshot!]!
}

input Account_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  isSuperApp: Boolean
  isSuperApp_not: Boolean
  isSuperApp_in: [Boolean!]
  isSuperApp_not_in: [Boolean!]
  inflows_: Stream_filter
  outflows_: Stream_filter
  subscriptions_: IndexSubscription_filter
  publishedIndexes_: Index_filter
  sentTransferEvents_: TransferEvent_filter
  receivedTransferEvents_: TransferEvent_filter
  tokenUpgradedEvents_: TokenUpgradedEvent_filter
  tokenDowngradedEvents_: TokenDowngradedEvent_filter
  accountTokenSnapshots_: AccountTokenSnapshot_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Account_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  isSuperApp
  inflows
  outflows
  subscriptions
  publishedIndexes
  sentTransferEvents
  receivedTransferEvents
  tokenUpgradedEvents
  tokenDowngradedEvents
  accountTokenSnapshots
}

"""
AccountTokenSnapshot: An aggregate entity which aggregates data on an account's
interaction with a `token`.

"""
type AccountTokenSnapshot {
  """
  ID composed of: accountID-tokenID
  
  """
  id: ID!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  isLiquidationEstimateOptimistic, If `totalSubscriptionsWithUnits > 0`, it is true.
  Optimistic means that it is the earliest time the user will be liquidated as
  they may receive ongoing distributions which aren't tracked by the subgraph
  
  """
  isLiquidationEstimateOptimistic: Boolean!

  """
  Optimistic liquidation estimation property.
  
  """
  maybeCriticalAtTimestamp: BigInt

  """
  The number of currently open streams.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The number of all-time closed streams.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all currently (as of updatedAt) approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  balanceUntilUpdatedAt: BigInt!

  """
  The total deposit this account has held by the CFA agreement for `account` active streams.
  
  """
  totalDeposit: BigInt!

  """
  The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalNetFlowRate: BigInt!

  """
  The total inflow rate (receive flowRate per second) of the `account`.
  
  """
  totalInflowRate: BigInt!

  """
  The total outflow rate (send flowrate per second) of the `account`.
  
  """
  totalOutflowRate: BigInt!

  """
  The total amount of `token` streamed into this `account` until
  the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedInUntilUpdatedAt: BigInt!

  """
  The total amount of `token` streamed from this `account` until
  the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedOutUntilUpdatedAt: BigInt!

  """
  The total amount of `token` streamed through this `account` until
  the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedUntilUpdatedAt: BigInt!

  """
  The total amount of `token` this `account` has transferred.
  
  """
  totalAmountTransferredUntilUpdatedAt: BigInt!
  account: Account!
  token: Token!
  flowOperators(skip: Int = 0, first: Int = 100, orderBy: FlowOperator_orderBy, orderDirection: OrderDirection, where: FlowOperator_filter): [FlowOperator!]!
  accountTokenSnapshotLogs(skip: Int = 0, first: Int = 100, orderBy: AccountTokenSnapshotLog_orderBy, orderDirection: OrderDirection, where: AccountTokenSnapshotLog_filter): [AccountTokenSnapshotLog!]!
}

input AccountTokenSnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  isLiquidationEstimateOptimistic: Boolean
  isLiquidationEstimateOptimistic_not: Boolean
  isLiquidationEstimateOptimistic_in: [Boolean!]
  isLiquidationEstimateOptimistic_not_in: [Boolean!]
  maybeCriticalAtTimestamp: BigInt
  maybeCriticalAtTimestamp_not: BigInt
  maybeCriticalAtTimestamp_gt: BigInt
  maybeCriticalAtTimestamp_lt: BigInt
  maybeCriticalAtTimestamp_gte: BigInt
  maybeCriticalAtTimestamp_lte: BigInt
  maybeCriticalAtTimestamp_in: [BigInt!]
  maybeCriticalAtTimestamp_not_in: [BigInt!]
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  balanceUntilUpdatedAt: BigInt
  balanceUntilUpdatedAt_not: BigInt
  balanceUntilUpdatedAt_gt: BigInt
  balanceUntilUpdatedAt_lt: BigInt
  balanceUntilUpdatedAt_gte: BigInt
  balanceUntilUpdatedAt_lte: BigInt
  balanceUntilUpdatedAt_in: [BigInt!]
  balanceUntilUpdatedAt_not_in: [BigInt!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalNetFlowRate: BigInt
  totalNetFlowRate_not: BigInt
  totalNetFlowRate_gt: BigInt
  totalNetFlowRate_lt: BigInt
  totalNetFlowRate_gte: BigInt
  totalNetFlowRate_lte: BigInt
  totalNetFlowRate_in: [BigInt!]
  totalNetFlowRate_not_in: [BigInt!]
  totalInflowRate: BigInt
  totalInflowRate_not: BigInt
  totalInflowRate_gt: BigInt
  totalInflowRate_lt: BigInt
  totalInflowRate_gte: BigInt
  totalInflowRate_lte: BigInt
  totalInflowRate_in: [BigInt!]
  totalInflowRate_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamedInUntilUpdatedAt: BigInt
  totalAmountStreamedInUntilUpdatedAt_not: BigInt
  totalAmountStreamedInUntilUpdatedAt_gt: BigInt
  totalAmountStreamedInUntilUpdatedAt_lt: BigInt
  totalAmountStreamedInUntilUpdatedAt_gte: BigInt
  totalAmountStreamedInUntilUpdatedAt_lte: BigInt
  totalAmountStreamedInUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedInUntilUpdatedAt_not_in: [BigInt!]
  totalAmountStreamedOutUntilUpdatedAt: BigInt
  totalAmountStreamedOutUntilUpdatedAt_not: BigInt
  totalAmountStreamedOutUntilUpdatedAt_gt: BigInt
  totalAmountStreamedOutUntilUpdatedAt_lt: BigInt
  totalAmountStreamedOutUntilUpdatedAt_gte: BigInt
  totalAmountStreamedOutUntilUpdatedAt_lte: BigInt
  totalAmountStreamedOutUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedOutUntilUpdatedAt_not_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt: BigInt
  totalAmountStreamedUntilUpdatedAt_not: BigInt
  totalAmountStreamedUntilUpdatedAt_gt: BigInt
  totalAmountStreamedUntilUpdatedAt_lt: BigInt
  totalAmountStreamedUntilUpdatedAt_gte: BigInt
  totalAmountStreamedUntilUpdatedAt_lte: BigInt
  totalAmountStreamedUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt_not_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt: BigInt
  totalAmountTransferredUntilUpdatedAt_not: BigInt
  totalAmountTransferredUntilUpdatedAt_gt: BigInt
  totalAmountTransferredUntilUpdatedAt_lt: BigInt
  totalAmountTransferredUntilUpdatedAt_gte: BigInt
  totalAmountTransferredUntilUpdatedAt_lte: BigInt
  totalAmountTransferredUntilUpdatedAt_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt_not_in: [BigInt!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  flowOperators_: FlowOperator_filter
  accountTokenSnapshotLogs_: AccountTokenSnapshotLog_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AccountTokenSnapshot_orderBy {
  id
  updatedAtTimestamp
  updatedAtBlockNumber
  isLiquidationEstimateOptimistic
  maybeCriticalAtTimestamp
  totalNumberOfActiveStreams
  totalNumberOfClosedStreams
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  balanceUntilUpdatedAt
  totalDeposit
  totalNetFlowRate
  totalInflowRate
  totalOutflowRate
  totalAmountStreamedInUntilUpdatedAt
  totalAmountStreamedOutUntilUpdatedAt
  totalAmountStreamedUntilUpdatedAt
  totalAmountTransferredUntilUpdatedAt
  account
  token
  flowOperators
  accountTokenSnapshotLogs
}

"""
AccountTokenSnapshotLog: Historical entries of AccountTokenSnapshot updates.

"""
type AccountTokenSnapshotLog {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
  order: BigInt!
  triggeredByEventName: String!

  """
  Optimistic liquidation estimation property.
  
  """
  maybeCriticalAtTimestamp: BigInt

  """
  The current (as of timestamp) number of currently open streams.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The current (as of timestamp) number of all-time closed streams.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The current (as of timestamp) number of subscriptions with units allocated to them tied to this `account`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all currently (as of timestamp) approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  Balance of `account` as of `timestamp`/`block`.
  
  """
  balance: BigInt!

  """
  The total (as of timestamp) deposit this account has held by the CFA agreement for `account` active streams.
  
  """
  totalDeposit: BigInt!

  """
  The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block`.
  
  """
  totalNetFlowRate: BigInt!

  """
  The total (as of timestamp) inflow rate (receive flowRate per second) of the `account`.
  
  """
  totalInflowRate: BigInt!

  """
  The total (as of timestamp) outflow rate (send flowrate per second) of the `account`.
  
  """
  totalOutflowRate: BigInt!

  """
  The total (as of timestamp) amount of `token` streamed into this `account` until
  the `timestamp`/`block`.
  
  """
  totalAmountStreamedIn: BigInt!

  """
  The total (as of timestamp) amount of `token` streamed from this `account` until
  the `timestamp`/`block`.
  
  """
  totalAmountStreamedOut: BigInt!

  """
  The total (as of timestamp) net amount of `token` streamed through this `account` until
  the `timestamp`/`block`.
  
  """
  totalAmountStreamed: BigInt!

  """
  The total (as of timestamp) amount of `token` this `account` has transferred.
  
  """
  totalAmountTransferred: BigInt!
  account: Account!
  token: Token!
  accountTokenSnapshot: AccountTokenSnapshot!
}

input AccountTokenSnapshotLog_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  triggeredByEventName: String
  triggeredByEventName_not: String
  triggeredByEventName_gt: String
  triggeredByEventName_lt: String
  triggeredByEventName_gte: String
  triggeredByEventName_lte: String
  triggeredByEventName_in: [String!]
  triggeredByEventName_not_in: [String!]
  triggeredByEventName_contains: String
  triggeredByEventName_contains_nocase: String
  triggeredByEventName_not_contains: String
  triggeredByEventName_not_contains_nocase: String
  triggeredByEventName_starts_with: String
  triggeredByEventName_starts_with_nocase: String
  triggeredByEventName_not_starts_with: String
  triggeredByEventName_not_starts_with_nocase: String
  triggeredByEventName_ends_with: String
  triggeredByEventName_ends_with_nocase: String
  triggeredByEventName_not_ends_with: String
  triggeredByEventName_not_ends_with_nocase: String
  maybeCriticalAtTimestamp: BigInt
  maybeCriticalAtTimestamp_not: BigInt
  maybeCriticalAtTimestamp_gt: BigInt
  maybeCriticalAtTimestamp_lt: BigInt
  maybeCriticalAtTimestamp_gte: BigInt
  maybeCriticalAtTimestamp_lte: BigInt
  maybeCriticalAtTimestamp_in: [BigInt!]
  maybeCriticalAtTimestamp_not_in: [BigInt!]
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalNetFlowRate: BigInt
  totalNetFlowRate_not: BigInt
  totalNetFlowRate_gt: BigInt
  totalNetFlowRate_lt: BigInt
  totalNetFlowRate_gte: BigInt
  totalNetFlowRate_lte: BigInt
  totalNetFlowRate_in: [BigInt!]
  totalNetFlowRate_not_in: [BigInt!]
  totalInflowRate: BigInt
  totalInflowRate_not: BigInt
  totalInflowRate_gt: BigInt
  totalInflowRate_lt: BigInt
  totalInflowRate_gte: BigInt
  totalInflowRate_lte: BigInt
  totalInflowRate_in: [BigInt!]
  totalInflowRate_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamedIn: BigInt
  totalAmountStreamedIn_not: BigInt
  totalAmountStreamedIn_gt: BigInt
  totalAmountStreamedIn_lt: BigInt
  totalAmountStreamedIn_gte: BigInt
  totalAmountStreamedIn_lte: BigInt
  totalAmountStreamedIn_in: [BigInt!]
  totalAmountStreamedIn_not_in: [BigInt!]
  totalAmountStreamedOut: BigInt
  totalAmountStreamedOut_not: BigInt
  totalAmountStreamedOut_gt: BigInt
  totalAmountStreamedOut_lt: BigInt
  totalAmountStreamedOut_gte: BigInt
  totalAmountStreamedOut_lte: BigInt
  totalAmountStreamedOut_in: [BigInt!]
  totalAmountStreamedOut_not_in: [BigInt!]
  totalAmountStreamed: BigInt
  totalAmountStreamed_not: BigInt
  totalAmountStreamed_gt: BigInt
  totalAmountStreamed_lt: BigInt
  totalAmountStreamed_gte: BigInt
  totalAmountStreamed_lte: BigInt
  totalAmountStreamed_in: [BigInt!]
  totalAmountStreamed_not_in: [BigInt!]
  totalAmountTransferred: BigInt
  totalAmountTransferred_not: BigInt
  totalAmountTransferred_gt: BigInt
  totalAmountTransferred_lt: BigInt
  totalAmountTransferred_gte: BigInt
  totalAmountTransferred_lte: BigInt
  totalAmountTransferred_in: [BigInt!]
  totalAmountTransferred_not_in: [BigInt!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  accountTokenSnapshot: String
  accountTokenSnapshot_not: String
  accountTokenSnapshot_gt: String
  accountTokenSnapshot_lt: String
  accountTokenSnapshot_gte: String
  accountTokenSnapshot_lte: String
  accountTokenSnapshot_in: [String!]
  accountTokenSnapshot_not_in: [String!]
  accountTokenSnapshot_contains: String
  accountTokenSnapshot_contains_nocase: String
  accountTokenSnapshot_not_contains: String
  accountTokenSnapshot_not_contains_nocase: String
  accountTokenSnapshot_starts_with: String
  accountTokenSnapshot_starts_with_nocase: String
  accountTokenSnapshot_not_starts_with: String
  accountTokenSnapshot_not_starts_with_nocase: String
  accountTokenSnapshot_ends_with: String
  accountTokenSnapshot_ends_with_nocase: String
  accountTokenSnapshot_not_ends_with: String
  accountTokenSnapshot_not_ends_with_nocase: String
  accountTokenSnapshot_: AccountTokenSnapshot_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AccountTokenSnapshotLog_orderBy {
  id
  timestamp
  blockNumber
  transactionHash
  logIndex
  order
  triggeredByEventName
  maybeCriticalAtTimestamp
  totalNumberOfActiveStreams
  totalNumberOfClosedStreams
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  balance
  totalDeposit
  totalNetFlowRate
  totalInflowRate
  totalOutflowRate
  totalAmountStreamedIn
  totalAmountStreamedOut
  totalAmountStreamed
  totalAmountTransferred
  account
  token
  accountTokenSnapshot
}

type AgreementClassRegisteredEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  agreementType: Bytes!
  code: Bytes!
}

input AgreementClassRegisteredEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  agreementType: Bytes
  agreementType_not: Bytes
  agreementType_in: [Bytes!]
  agreementType_not_in: [Bytes!]
  agreementType_contains: Bytes
  agreementType_not_contains: Bytes
  code: Bytes
  code_not: Bytes
  code_in: [Bytes!]
  code_not_in: [Bytes!]
  code_contains: Bytes
  code_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AgreementClassRegisteredEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  agreementType
  code
}

type AgreementClassUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  agreementType: Bytes!
  code: Bytes!
}

input AgreementClassUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  agreementType: Bytes
  agreementType_not: Bytes
  agreementType_in: [Bytes!]
  agreementType_not_in: [Bytes!]
  agreementType_contains: Bytes
  agreementType_not_contains: Bytes
  code: Bytes
  code_not: Bytes
  code_in: [Bytes!]
  code_not_in: [Bytes!]
  code_contains: Bytes
  code_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AgreementClassUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  agreementType
  code
}

type AgreementLiquidatedByEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, liquidatorAccount, penaltyAccount and bondAccount addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  liquidatorAccount: Bytes!
  agreementClass: Bytes!
  agreementId: Bytes!
  penaltyAccount: Bytes!
  bondAccount: Bytes!
  rewardAmount: BigInt!
  bailoutAmount: BigInt!
}

input AgreementLiquidatedByEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  liquidatorAccount: Bytes
  liquidatorAccount_not: Bytes
  liquidatorAccount_in: [Bytes!]
  liquidatorAccount_not_in: [Bytes!]
  liquidatorAccount_contains: Bytes
  liquidatorAccount_not_contains: Bytes
  agreementClass: Bytes
  agreementClass_not: Bytes
  agreementClass_in: [Bytes!]
  agreementClass_not_in: [Bytes!]
  agreementClass_contains: Bytes
  agreementClass_not_contains: Bytes
  agreementId: Bytes
  agreementId_not: Bytes
  agreementId_in: [Bytes!]
  agreementId_not_in: [Bytes!]
  agreementId_contains: Bytes
  agreementId_not_contains: Bytes
  penaltyAccount: Bytes
  penaltyAccount_not: Bytes
  penaltyAccount_in: [Bytes!]
  penaltyAccount_not_in: [Bytes!]
  penaltyAccount_contains: Bytes
  penaltyAccount_not_contains: Bytes
  bondAccount: Bytes
  bondAccount_not: Bytes
  bondAccount_in: [Bytes!]
  bondAccount_not_in: [Bytes!]
  bondAccount_contains: Bytes
  bondAccount_not_contains: Bytes
  rewardAmount: BigInt
  rewardAmount_not: BigInt
  rewardAmount_gt: BigInt
  rewardAmount_lt: BigInt
  rewardAmount_gte: BigInt
  rewardAmount_lte: BigInt
  rewardAmount_in: [BigInt!]
  rewardAmount_not_in: [BigInt!]
  bailoutAmount: BigInt
  bailoutAmount_not: BigInt
  bailoutAmount_gt: BigInt
  bailoutAmount_lt: BigInt
  bailoutAmount_gte: BigInt
  bailoutAmount_lte: BigInt
  bailoutAmount_in: [BigInt!]
  bailoutAmount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AgreementLiquidatedByEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  liquidatorAccount
  agreementClass
  agreementId
  penaltyAccount
  bondAccount
  rewardAmount
  bailoutAmount
}

type AgreementLiquidatedV2Event implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, liquidatorAccount, targetAccount and rewardAmountReceiver addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  liquidatorAccount: Bytes!
  agreementClass: Bytes!
  agreementId: Bytes!
  targetAccount: Bytes!
  rewardAmountReceiver: Bytes!
  rewardAmount: BigInt!
  targetAccountBalanceDelta: BigInt!
  version: BigInt!
  liquidationType: Int!

  """
  TO BE DEPRECATED in v2 endpoint - use rewardAmountReceiver instead
  
  """
  rewardAccount: Bytes!
}

input AgreementLiquidatedV2Event_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  liquidatorAccount: Bytes
  liquidatorAccount_not: Bytes
  liquidatorAccount_in: [Bytes!]
  liquidatorAccount_not_in: [Bytes!]
  liquidatorAccount_contains: Bytes
  liquidatorAccount_not_contains: Bytes
  agreementClass: Bytes
  agreementClass_not: Bytes
  agreementClass_in: [Bytes!]
  agreementClass_not_in: [Bytes!]
  agreementClass_contains: Bytes
  agreementClass_not_contains: Bytes
  agreementId: Bytes
  agreementId_not: Bytes
  agreementId_in: [Bytes!]
  agreementId_not_in: [Bytes!]
  agreementId_contains: Bytes
  agreementId_not_contains: Bytes
  targetAccount: Bytes
  targetAccount_not: Bytes
  targetAccount_in: [Bytes!]
  targetAccount_not_in: [Bytes!]
  targetAccount_contains: Bytes
  targetAccount_not_contains: Bytes
  rewardAmountReceiver: Bytes
  rewardAmountReceiver_not: Bytes
  rewardAmountReceiver_in: [Bytes!]
  rewardAmountReceiver_not_in: [Bytes!]
  rewardAmountReceiver_contains: Bytes
  rewardAmountReceiver_not_contains: Bytes
  rewardAmount: BigInt
  rewardAmount_not: BigInt
  rewardAmount_gt: BigInt
  rewardAmount_lt: BigInt
  rewardAmount_gte: BigInt
  rewardAmount_lte: BigInt
  rewardAmount_in: [BigInt!]
  rewardAmount_not_in: [BigInt!]
  targetAccountBalanceDelta: BigInt
  targetAccountBalanceDelta_not: BigInt
  targetAccountBalanceDelta_gt: BigInt
  targetAccountBalanceDelta_lt: BigInt
  targetAccountBalanceDelta_gte: BigInt
  targetAccountBalanceDelta_lte: BigInt
  targetAccountBalanceDelta_in: [BigInt!]
  targetAccountBalanceDelta_not_in: [BigInt!]
  version: BigInt
  version_not: BigInt
  version_gt: BigInt
  version_lt: BigInt
  version_gte: BigInt
  version_lte: BigInt
  version_in: [BigInt!]
  version_not_in: [BigInt!]
  liquidationType: Int
  liquidationType_not: Int
  liquidationType_gt: Int
  liquidationType_lt: Int
  liquidationType_gte: Int
  liquidationType_lte: Int
  liquidationType_in: [Int!]
  liquidationType_not_in: [Int!]
  rewardAccount: Bytes
  rewardAccount_not: Bytes
  rewardAccount_in: [Bytes!]
  rewardAccount_not_in: [Bytes!]
  rewardAccount_contains: Bytes
  rewardAccount_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AgreementLiquidatedV2Event_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  liquidatorAccount
  agreementClass
  agreementId
  targetAccount
  rewardAmountReceiver
  rewardAmount
  targetAccountBalanceDelta
  version
  liquidationType
  rewardAccount
}

type AppRegisteredEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  app: Bytes!
}

input AppRegisteredEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  app: Bytes
  app_not: Bytes
  app_in: [Bytes!]
  app_not_in: [Bytes!]
  app_contains: Bytes
  app_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum AppRegisteredEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  app
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

type BurnedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token and from addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  operator: Bytes!
  from: Bytes!
  token: Bytes!
  amount: BigInt!
  data: Bytes!
  operatorData: Bytes!
}

input BurnedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  operator: Bytes
  operator_not: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  data: Bytes
  data_not: Bytes
  data_in: [Bytes!]
  data_not_in: [Bytes!]
  data_contains: Bytes
  data_not_contains: Bytes
  operatorData: Bytes
  operatorData_not: Bytes
  operatorData_in: [Bytes!]
  operatorData_not_in: [Bytes!]
  operatorData_contains: Bytes
  operatorData_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum BurnedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  operator
  from
  token
  amount
  data
  operatorData
}

scalar Bytes

type CFAv1LiquidationPeriodChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  order: BigInt!
  logIndex: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  liquidationPeriod: BigInt!
}

input CFAv1LiquidationPeriodChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  liquidationPeriod: BigInt
  liquidationPeriod_not: BigInt
  liquidationPeriod_gt: BigInt
  liquidationPeriod_lt: BigInt
  liquidationPeriod_gte: BigInt
  liquidationPeriod_lte: BigInt
  liquidationPeriod_in: [BigInt!]
  liquidationPeriod_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum CFAv1LiquidationPeriodChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  order
  logIndex
  host
  superToken
  isKeySet
  liquidationPeriod
}

type ConfigChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  key: Bytes!
  isKeySet: Boolean!
  value: BigInt!
}

input ConfigChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  key: Bytes
  key_not: Bytes
  key_in: [Bytes!]
  key_not_in: [Bytes!]
  key_contains: Bytes
  key_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ConfigChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  key
  isKeySet
  value
}

type CustomSuperTokenCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token address.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
}

input CustomSuperTokenCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum CustomSuperTokenCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
}

"""
Event: An interface which is shared by all
event entities and contains basic transaction
data.

"""
interface Event {
  id: ID!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  name: String!

  """
  Holds the addresses for accounts that were impacted by the event.
  
  """
  addresses: [Bytes!]!
  timestamp: BigInt!
  transactionHash: Bytes!
  gasPrice: BigInt!
}

input Event_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Event_orderBy {
  id
  blockNumber
  logIndex
  order
  name
  addresses
  timestamp
  transactionHash
  gasPrice
}

"""
FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`.

"""
type FlowOperator {
  """
  ID composed of: flowOperator - token - sender
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  The permissions granted to the `flowOperator`.
  Octo bitmask representation.
  
  """
  permissions: Int!

  """
  The flow rate allowance granted to the `flowOperator`
  by the `sender`. This can be reset if the `sender`
  updates the `flowOperator` flow rate allowance.
  
  """
  flowRateAllowanceGranted: BigInt!

  """
  The remaining flow rate allowance the `flowOperator` has,
  this will go down every time when `flowOperator` uses it
  (if they increase flowRate or create a new flow)
  and can only be reset if the `sender` updates the flow
  rate allowance.
  
  """
  flowRateAllowanceRemaining: BigInt!
  flowOperator: Bytes!
  sender: Account!
  token: Token!
  accountTokenSnapshot: AccountTokenSnapshot!
  flowOperatorUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: FlowOperatorUpdatedEvent_orderBy, orderDirection: OrderDirection, where: FlowOperatorUpdatedEvent_filter): [FlowOperatorUpdatedEvent!]!
}

input FlowOperator_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  permissions: Int
  permissions_not: Int
  permissions_gt: Int
  permissions_lt: Int
  permissions_gte: Int
  permissions_lte: Int
  permissions_in: [Int!]
  permissions_not_in: [Int!]
  flowRateAllowanceGranted: BigInt
  flowRateAllowanceGranted_not: BigInt
  flowRateAllowanceGranted_gt: BigInt
  flowRateAllowanceGranted_lt: BigInt
  flowRateAllowanceGranted_gte: BigInt
  flowRateAllowanceGranted_lte: BigInt
  flowRateAllowanceGranted_in: [BigInt!]
  flowRateAllowanceGranted_not_in: [BigInt!]
  flowRateAllowanceRemaining: BigInt
  flowRateAllowanceRemaining_not: BigInt
  flowRateAllowanceRemaining_gt: BigInt
  flowRateAllowanceRemaining_lt: BigInt
  flowRateAllowanceRemaining_gte: BigInt
  flowRateAllowanceRemaining_lte: BigInt
  flowRateAllowanceRemaining_in: [BigInt!]
  flowRateAllowanceRemaining_not_in: [BigInt!]
  flowOperator: Bytes
  flowOperator_not: Bytes
  flowOperator_in: [Bytes!]
  flowOperator_not_in: [Bytes!]
  flowOperator_contains: Bytes
  flowOperator_not_contains: Bytes
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  accountTokenSnapshot: String
  accountTokenSnapshot_not: String
  accountTokenSnapshot_gt: String
  accountTokenSnapshot_lt: String
  accountTokenSnapshot_gte: String
  accountTokenSnapshot_lte: String
  accountTokenSnapshot_in: [String!]
  accountTokenSnapshot_not_in: [String!]
  accountTokenSnapshot_contains: String
  accountTokenSnapshot_contains_nocase: String
  accountTokenSnapshot_not_contains: String
  accountTokenSnapshot_not_contains_nocase: String
  accountTokenSnapshot_starts_with: String
  accountTokenSnapshot_starts_with_nocase: String
  accountTokenSnapshot_not_starts_with: String
  accountTokenSnapshot_not_starts_with_nocase: String
  accountTokenSnapshot_ends_with: String
  accountTokenSnapshot_ends_with_nocase: String
  accountTokenSnapshot_not_ends_with: String
  accountTokenSnapshot_not_ends_with_nocase: String
  accountTokenSnapshot_: AccountTokenSnapshot_filter
  flowOperatorUpdatedEvents_: FlowOperatorUpdatedEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum FlowOperator_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  permissions
  flowRateAllowanceGranted
  flowRateAllowanceRemaining
  flowOperator
  sender
  token
  accountTokenSnapshot
  flowOperatorUpdatedEvents
}

type FlowOperatorUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, sender, and flowOperator addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  The address of the `token` being streamed.
  
  """
  token: Bytes!
  sender: Bytes!

  """
  The permissions granted to the `flowOperator`.
  Octo bitmask representation.
  
  """
  permissions: Int!
  flowRateAllowance: BigInt!
  flowOperator: FlowOperator!
}

input FlowOperatorUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  permissions: Int
  permissions_not: Int
  permissions_gt: Int
  permissions_lt: Int
  permissions_gte: Int
  permissions_lte: Int
  permissions_in: [Int!]
  permissions_not_in: [Int!]
  flowRateAllowance: BigInt
  flowRateAllowance_not: BigInt
  flowRateAllowance_gt: BigInt
  flowRateAllowance_lt: BigInt
  flowRateAllowance_gte: BigInt
  flowRateAllowance_lte: BigInt
  flowRateAllowance_in: [BigInt!]
  flowRateAllowance_not_in: [BigInt!]
  flowOperator: String
  flowOperator_not: String
  flowOperator_gt: String
  flowOperator_lt: String
  flowOperator_gte: String
  flowOperator_lte: String
  flowOperator_in: [String!]
  flowOperator_not_in: [String!]
  flowOperator_contains: String
  flowOperator_contains_nocase: String
  flowOperator_not_contains: String
  flowOperator_not_contains_nocase: String
  flowOperator_starts_with: String
  flowOperator_starts_with_nocase: String
  flowOperator_not_starts_with: String
  flowOperator_not_starts_with_nocase: String
  flowOperator_ends_with: String
  flowOperator_ends_with_nocase: String
  flowOperator_not_ends_with: String
  flowOperator_not_ends_with_nocase: String
  flowOperator_: FlowOperator_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum FlowOperatorUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  sender
  permissions
  flowRateAllowance
  flowOperator
}

"""
FlowUpdated: An `Event` entity that is emitted
when a flow is created, updated, or deleted.

"""
type FlowUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, sender and receiver addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  The address of the `token` being streamed.
  
  """
  token: Bytes!
  sender: Bytes!
  receiver: Bytes!

  """
  The address that is triggering the flow update.
  This will be the zero address until the flowOperator
  feature is live.
  
  """
  flowOperator: Bytes!

  """
  The flow rate per second.
  
  """
  flowRate: BigInt!
  totalSenderFlowRate: BigInt!
  totalReceiverFlowRate: BigInt!
  deposit: BigInt!
  userData: Bytes!

  """
  The previous flow rate.
  
  """
  oldFlowRate: BigInt!

  """
  The "type" of the `FlowUpdated` event.
  0 = create
  1 = update
  2 = terminate
  
  """
  type: Int!

  """
  The total amount streamed until the timestamp
  for the Stream entity linked to this event.
  
  """
  totalAmountStreamedUntilTimestamp: BigInt!

  """
  The stream entity which is being modified.
  
  """
  stream: Stream!
}

input FlowUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  receiver: Bytes
  receiver_not: Bytes
  receiver_in: [Bytes!]
  receiver_not_in: [Bytes!]
  receiver_contains: Bytes
  receiver_not_contains: Bytes
  flowOperator: Bytes
  flowOperator_not: Bytes
  flowOperator_in: [Bytes!]
  flowOperator_not_in: [Bytes!]
  flowOperator_contains: Bytes
  flowOperator_not_contains: Bytes
  flowRate: BigInt
  flowRate_not: BigInt
  flowRate_gt: BigInt
  flowRate_lt: BigInt
  flowRate_gte: BigInt
  flowRate_lte: BigInt
  flowRate_in: [BigInt!]
  flowRate_not_in: [BigInt!]
  totalSenderFlowRate: BigInt
  totalSenderFlowRate_not: BigInt
  totalSenderFlowRate_gt: BigInt
  totalSenderFlowRate_lt: BigInt
  totalSenderFlowRate_gte: BigInt
  totalSenderFlowRate_lte: BigInt
  totalSenderFlowRate_in: [BigInt!]
  totalSenderFlowRate_not_in: [BigInt!]
  totalReceiverFlowRate: BigInt
  totalReceiverFlowRate_not: BigInt
  totalReceiverFlowRate_gt: BigInt
  totalReceiverFlowRate_lt: BigInt
  totalReceiverFlowRate_gte: BigInt
  totalReceiverFlowRate_lte: BigInt
  totalReceiverFlowRate_in: [BigInt!]
  totalReceiverFlowRate_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  oldFlowRate: BigInt
  oldFlowRate_not: BigInt
  oldFlowRate_gt: BigInt
  oldFlowRate_lt: BigInt
  oldFlowRate_gte: BigInt
  oldFlowRate_lte: BigInt
  oldFlowRate_in: [BigInt!]
  oldFlowRate_not_in: [BigInt!]
  type: Int
  type_not: Int
  type_gt: Int
  type_lt: Int
  type_gte: Int
  type_lte: Int
  type_in: [Int!]
  type_not_in: [Int!]
  totalAmountStreamedUntilTimestamp: BigInt
  totalAmountStreamedUntilTimestamp_not: BigInt
  totalAmountStreamedUntilTimestamp_gt: BigInt
  totalAmountStreamedUntilTimestamp_lt: BigInt
  totalAmountStreamedUntilTimestamp_gte: BigInt
  totalAmountStreamedUntilTimestamp_lte: BigInt
  totalAmountStreamedUntilTimestamp_in: [BigInt!]
  totalAmountStreamedUntilTimestamp_not_in: [BigInt!]
  stream: String
  stream_not: String
  stream_gt: String
  stream_lt: String
  stream_gte: String
  stream_lte: String
  stream_in: [String!]
  stream_not_in: [String!]
  stream_contains: String
  stream_contains_nocase: String
  stream_not_contains: String
  stream_not_contains_nocase: String
  stream_starts_with: String
  stream_starts_with_nocase: String
  stream_not_starts_with: String
  stream_not_starts_with_nocase: String
  stream_ends_with: String
  stream_ends_with_nocase: String
  stream_not_ends_with: String
  stream_not_ends_with_nocase: String
  stream_: Stream_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum FlowUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  sender
  receiver
  flowOperator
  flowRate
  totalSenderFlowRate
  totalReceiverFlowRate
  deposit
  userData
  oldFlowRate
  type
  totalAmountStreamedUntilTimestamp
  stream
}

type GovernanceReplacedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  oldGovernance: Bytes!
  newGovernance: Bytes!
}

input GovernanceReplacedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  oldGovernance: Bytes
  oldGovernance_not: Bytes
  oldGovernance_in: [Bytes!]
  oldGovernance_not_in: [Bytes!]
  oldGovernance_contains: Bytes
  oldGovernance_not_contains: Bytes
  newGovernance: Bytes
  newGovernance_not: Bytes
  newGovernance_in: [Bytes!]
  newGovernance_not_in: [Bytes!]
  newGovernance_contains: Bytes
  newGovernance_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum GovernanceReplacedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  blockNumber
  logIndex
  order
  addresses
  oldGovernance
  newGovernance
}

"""
Index: An Index higher order entity.

"""
type Index {
  """
  ID composed of: publisherAddress-tokenAddress-indexId
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  indexId is not the id of the `Index` entity.
  
  """
  indexId: BigInt!
  indexValue: BigInt!

  """
  The number of subscriptions which have units allocated to them on the `Index`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  The number of units allocated by the `Index` that are pending.
  This refers to the current (as of updatedAt) `totalUnitsPending`
  - not all that has ever been pending.
  
  """
  totalUnitsPending: BigInt!

  """
  The number of units allocated by the `Index` that are approved.
  This refers to the current (as of updatedAt) `totalUnitsApproved`
  - not all that has ever been approved.
  
  """
  totalUnitsApproved: BigInt!

  """
  The sum of `totalUnitsPending` and `totalUnitsApproved`.
  
  """
  totalUnits: BigInt!

  """
  The total amount distributed from this `Index`.
  
  """
  totalAmountDistributedUntilUpdatedAt: BigInt!
  token: Token!
  publisher: Account!

  """
  The subscriptions of the index, it will include approved, unapproved
  and deleted subscriptions.
  
  """
  subscriptions(skip: Int = 0, first: Int = 100, orderBy: IndexSubscription_orderBy, orderDirection: OrderDirection, where: IndexSubscription_filter): [IndexSubscription!]!

  """
  IndexCreated event, there will only be one.
  
  """
  indexCreatedEvent: IndexCreatedEvent!
  indexDistributionClaimedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexDistributionClaimedEvent_orderBy, orderDirection: OrderDirection, where: IndexDistributionClaimedEvent_filter): [IndexDistributionClaimedEvent!]!
  indexUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexUpdatedEvent_orderBy, orderDirection: OrderDirection, where: IndexUpdatedEvent_filter): [IndexUpdatedEvent!]!
  indexSubscribedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexSubscribedEvent_orderBy, orderDirection: OrderDirection, where: IndexSubscribedEvent_filter): [IndexSubscribedEvent!]!
  indexUnitsUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexUnitsUpdatedEvent_orderBy, orderDirection: OrderDirection, where: IndexUnitsUpdatedEvent_filter): [IndexUnitsUpdatedEvent!]!
  indexUnsubscribedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexUnsubscribedEvent_orderBy, orderDirection: OrderDirection, where: IndexUnsubscribedEvent_filter): [IndexUnsubscribedEvent!]!
}

input Index_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  indexValue: BigInt
  indexValue_not: BigInt
  indexValue_gt: BigInt
  indexValue_lt: BigInt
  indexValue_gte: BigInt
  indexValue_lte: BigInt
  indexValue_in: [BigInt!]
  indexValue_not_in: [BigInt!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalUnitsPending: BigInt
  totalUnitsPending_not: BigInt
  totalUnitsPending_gt: BigInt
  totalUnitsPending_lt: BigInt
  totalUnitsPending_gte: BigInt
  totalUnitsPending_lte: BigInt
  totalUnitsPending_in: [BigInt!]
  totalUnitsPending_not_in: [BigInt!]
  totalUnitsApproved: BigInt
  totalUnitsApproved_not: BigInt
  totalUnitsApproved_gt: BigInt
  totalUnitsApproved_lt: BigInt
  totalUnitsApproved_gte: BigInt
  totalUnitsApproved_lte: BigInt
  totalUnitsApproved_in: [BigInt!]
  totalUnitsApproved_not_in: [BigInt!]
  totalUnits: BigInt
  totalUnits_not: BigInt
  totalUnits_gt: BigInt
  totalUnits_lt: BigInt
  totalUnits_gte: BigInt
  totalUnits_lte: BigInt
  totalUnits_in: [BigInt!]
  totalUnits_not_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt: BigInt
  totalAmountDistributedUntilUpdatedAt_not: BigInt
  totalAmountDistributedUntilUpdatedAt_gt: BigInt
  totalAmountDistributedUntilUpdatedAt_lt: BigInt
  totalAmountDistributedUntilUpdatedAt_gte: BigInt
  totalAmountDistributedUntilUpdatedAt_lte: BigInt
  totalAmountDistributedUntilUpdatedAt_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  publisher: String
  publisher_not: String
  publisher_gt: String
  publisher_lt: String
  publisher_gte: String
  publisher_lte: String
  publisher_in: [String!]
  publisher_not_in: [String!]
  publisher_contains: String
  publisher_contains_nocase: String
  publisher_not_contains: String
  publisher_not_contains_nocase: String
  publisher_starts_with: String
  publisher_starts_with_nocase: String
  publisher_not_starts_with: String
  publisher_not_starts_with_nocase: String
  publisher_ends_with: String
  publisher_ends_with_nocase: String
  publisher_not_ends_with: String
  publisher_not_ends_with_nocase: String
  publisher_: Account_filter
  subscriptions_: IndexSubscription_filter
  indexCreatedEvent: String
  indexCreatedEvent_not: String
  indexCreatedEvent_gt: String
  indexCreatedEvent_lt: String
  indexCreatedEvent_gte: String
  indexCreatedEvent_lte: String
  indexCreatedEvent_in: [String!]
  indexCreatedEvent_not_in: [String!]
  indexCreatedEvent_contains: String
  indexCreatedEvent_contains_nocase: String
  indexCreatedEvent_not_contains: String
  indexCreatedEvent_not_contains_nocase: String
  indexCreatedEvent_starts_with: String
  indexCreatedEvent_starts_with_nocase: String
  indexCreatedEvent_not_starts_with: String
  indexCreatedEvent_not_starts_with_nocase: String
  indexCreatedEvent_ends_with: String
  indexCreatedEvent_ends_with_nocase: String
  indexCreatedEvent_not_ends_with: String
  indexCreatedEvent_not_ends_with_nocase: String
  indexCreatedEvent_: IndexCreatedEvent_filter
  indexDistributionClaimedEvents_: IndexDistributionClaimedEvent_filter
  indexUpdatedEvents_: IndexUpdatedEvent_filter
  indexSubscribedEvents_: IndexSubscribedEvent_filter
  indexUnitsUpdatedEvents_: IndexUnitsUpdatedEvent_filter
  indexUnsubscribedEvents_: IndexUnsubscribedEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Index_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  indexId
  indexValue
  totalSubscriptionsWithUnits
  totalUnitsPending
  totalUnitsApproved
  totalUnits
  totalAmountDistributedUntilUpdatedAt
  token
  publisher
  subscriptions
  indexCreatedEvent
  indexDistributionClaimedEvents
  indexUpdatedEvents
  indexSubscribedEvents
  indexUnitsUpdatedEvents
  indexUnsubscribedEvents
}

type IndexCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token and publisher addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  userData: Bytes!
  index: Index!
}

input IndexCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum IndexCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  userData
  index
}

type IndexDistributionClaimedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  subscriber: Bytes!
  amount: BigInt!
  index: Index!
}

input IndexDistributionClaimedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum IndexDistributionClaimedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  amount
  index
}

type IndexSubscribedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  subscriber: Bytes!
  userData: Bytes!
  index: Index!
}

input IndexSubscribedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum IndexSubscribedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  userData
  index
}

"""
IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular
`Index`.

"""
type IndexSubscription {
  """
  ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
  subscriber: Account!

  """
  Approved subscriptions don't require subscribers to claim tokens that are distributed from
  the publisher.
  
  """
  approved: Boolean!

  """
  If units is 0, it indicates that the subscription is "deleted". They are no longer
  subscribed to the index.
  
  """
  units: BigInt!

  """
  The total amount of tokens you've received via IDA until
  `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountReceivedUntilUpdatedAt: BigInt!

  """
  The previous index value - used to calculate `totalAmountReceivedUntilUpdatedAt` field as of the
  `index.updatedAtTimestamp`. The formula to get this value is:
  `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue -
  indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
  
  """
  indexValueUntilUpdatedAt: BigInt!
  index: Index!

  """
  IndexSubscription approved events on the subscription.
  
  """
  subscriptionApprovedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionApprovedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionApprovedEvent_filter): [SubscriptionApprovedEvent!]!
  subscriptionDistributionClaimedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionDistributionClaimedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionDistributionClaimedEvent_filter): [SubscriptionDistributionClaimedEvent!]!
  subscriptionRevokedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionRevokedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionRevokedEvent_filter): [SubscriptionRevokedEvent!]!
  subscriptionUnitsUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionUnitsUpdatedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionUnitsUpdatedEvent_filter): [SubscriptionUnitsUpdatedEvent!]!
}

input IndexSubscription_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  subscriber: String
  subscriber_not: String
  subscriber_gt: String
  subscriber_lt: String
  subscriber_gte: String
  subscriber_lte: String
  subscriber_in: [String!]
  subscriber_not_in: [String!]
  subscriber_contains: String
  subscriber_contains_nocase: String
  subscriber_not_contains: String
  subscriber_not_contains_nocase: String
  subscriber_starts_with: String
  subscriber_starts_with_nocase: String
  subscriber_not_starts_with: String
  subscriber_not_starts_with_nocase: String
  subscriber_ends_with: String
  subscriber_ends_with_nocase: String
  subscriber_not_ends_with: String
  subscriber_not_ends_with_nocase: String
  subscriber_: Account_filter
  approved: Boolean
  approved_not: Boolean
  approved_in: [Boolean!]
  approved_not_in: [Boolean!]
  units: BigInt
  units_not: BigInt
  units_gt: BigInt
  units_lt: BigInt
  units_gte: BigInt
  units_lte: BigInt
  units_in: [BigInt!]
  units_not_in: [BigInt!]
  totalAmountReceivedUntilUpdatedAt: BigInt
  totalAmountReceivedUntilUpdatedAt_not: BigInt
  totalAmountReceivedUntilUpdatedAt_gt: BigInt
  totalAmountReceivedUntilUpdatedAt_lt: BigInt
  totalAmountReceivedUntilUpdatedAt_gte: BigInt
  totalAmountReceivedUntilUpdatedAt_lte: BigInt
  totalAmountReceivedUntilUpdatedAt_in: [BigInt!]
  totalAmountReceivedUntilUpdatedAt_not_in: [BigInt!]
  indexValueUntilUpdatedAt: BigInt
  indexValueUntilUpdatedAt_not: BigInt
  indexValueUntilUpdatedAt_gt: BigInt
  indexValueUntilUpdatedAt_lt: BigInt
  indexValueUntilUpdatedAt_gte: BigInt
  indexValueUntilUpdatedAt_lte: BigInt
  indexValueUntilUpdatedAt_in: [BigInt!]
  indexValueUntilUpdatedAt_not_in: [BigInt!]
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter
  subscriptionApprovedEvents_: SubscriptionApprovedEvent_filter
  subscriptionDistributionClaimedEvents_: SubscriptionDistributionClaimedEvent_filter
  subscriptionRevokedEvents_: SubscriptionRevokedEvent_filter
  subscriptionUnitsUpdatedEvents_: SubscriptionUnitsUpdatedEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum IndexSubscription_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  subscriber
  approved
  units
  totalAmountReceivedUntilUpdatedAt
  indexValueUntilUpdatedAt
  index
  subscriptionApprovedEvents
  subscriptionDistributionClaimedEvents
  subscriptionRevokedEvents
  subscriptionUnitsUpdatedEvents
}

type IndexUnitsUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  subscriber: Bytes!
  units: BigInt!
  userData: Bytes!
  oldUnits: BigInt!
  index: Index!
}

input IndexUnitsUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  units: BigInt
  units_not: BigInt
  units_gt: BigInt
  units_lt: BigInt
  units_gte: BigInt
  units_lte: BigInt
  units_in: [BigInt!]
  units_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  oldUnits: BigInt
  oldUnits_not: BigInt
  oldUnits_gt: BigInt
  oldUnits_lt: BigInt
  oldUnits_gte: BigInt
  oldUnits_lte: BigInt
  oldUnits_in: [BigInt!]
  oldUnits_not_in: [BigInt!]
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum IndexUnitsUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  units
  userData
  oldUnits
  index
}

type IndexUnsubscribedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  subscriber: Bytes!
  userData: Bytes!
  index: Index!
}

input IndexUnsubscribedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum IndexUnsubscribedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  userData
  index
}

type IndexUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token and publisher addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  oldIndexValue: BigInt!
  newIndexValue: BigInt!
  totalUnitsPending: BigInt!
  totalUnitsApproved: BigInt!
  userData: Bytes!
  index: Index!
}

input IndexUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  oldIndexValue: BigInt
  oldIndexValue_not: BigInt
  oldIndexValue_gt: BigInt
  oldIndexValue_lt: BigInt
  oldIndexValue_gte: BigInt
  oldIndexValue_lte: BigInt
  oldIndexValue_in: [BigInt!]
  oldIndexValue_not_in: [BigInt!]
  newIndexValue: BigInt
  newIndexValue_not: BigInt
  newIndexValue_gt: BigInt
  newIndexValue_lt: BigInt
  newIndexValue_gte: BigInt
  newIndexValue_lte: BigInt
  newIndexValue_in: [BigInt!]
  newIndexValue_not_in: [BigInt!]
  totalUnitsPending: BigInt
  totalUnitsPending_not: BigInt
  totalUnitsPending_gt: BigInt
  totalUnitsPending_lt: BigInt
  totalUnitsPending_gte: BigInt
  totalUnitsPending_lte: BigInt
  totalUnitsPending_in: [BigInt!]
  totalUnitsPending_not_in: [BigInt!]
  totalUnitsApproved: BigInt
  totalUnitsApproved_not: BigInt
  totalUnitsApproved_gt: BigInt
  totalUnitsApproved_lt: BigInt
  totalUnitsApproved_gte: BigInt
  totalUnitsApproved_lte: BigInt
  totalUnitsApproved_in: [BigInt!]
  totalUnitsApproved_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum IndexUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  oldIndexValue
  newIndexValue
  totalUnitsPending
  totalUnitsApproved
  userData
  index
}

type JailEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  app: Bytes!
  reason: BigInt!
}

input JailEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  app: Bytes
  app_not: Bytes
  app_in: [Bytes!]
  app_not_in: [Bytes!]
  app_contains: Bytes
  app_not_contains: Bytes
  reason: BigInt
  reason_not: BigInt
  reason_gt: BigInt
  reason_lt: BigInt
  reason_gte: BigInt
  reason_lte: BigInt
  reason_in: [BigInt!]
  reason_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum JailEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  app
  reason
}

type MintedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, operator and to addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  operator: Bytes!
  to: Bytes!
  amount: BigInt!
  data: Bytes!
  token: Bytes!
  operatorData: Bytes!
}

input MintedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  operator: Bytes
  operator_not: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  data: Bytes
  data_not: Bytes
  data_in: [Bytes!]
  data_not_in: [Bytes!]
  data_contains: Bytes
  data_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  operatorData: Bytes
  operatorData_not: Bytes
  operatorData_in: [Bytes!]
  operatorData_not_in: [Bytes!]
  operatorData_contains: Bytes
  operatorData_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum MintedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  operator
  to
  amount
  data
  token
  operatorData
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PPPConfigurationChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  liquidationPeriod: BigInt!
  patricianPeriod: BigInt!
}

input PPPConfigurationChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  liquidationPeriod: BigInt
  liquidationPeriod_not: BigInt
  liquidationPeriod_gt: BigInt
  liquidationPeriod_lt: BigInt
  liquidationPeriod_gte: BigInt
  liquidationPeriod_lte: BigInt
  liquidationPeriod_in: [BigInt!]
  liquidationPeriod_not_in: [BigInt!]
  patricianPeriod: BigInt
  patricianPeriod_not: BigInt
  patricianPeriod_gt: BigInt
  patricianPeriod_lt: BigInt
  patricianPeriod_gte: BigInt
  patricianPeriod_lte: BigInt
  patricianPeriod_in: [BigInt!]
  patricianPeriod_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum PPPConfigurationChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  isKeySet
  liquidationPeriod
  patricianPeriod
}

type Query {
  flowUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowUpdatedEvent
  flowUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowUpdatedEvent!]!
  flowOperatorUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperatorUpdatedEvent
  flowOperatorUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperatorUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowOperatorUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperatorUpdatedEvent!]!
  indexCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexCreatedEvent
  indexCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexCreatedEvent!]!
  indexDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexDistributionClaimedEvent
  indexDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexDistributionClaimedEvent!]!
  indexUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUpdatedEvent
  indexUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUpdatedEvent!]!
  indexSubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscribedEvent
  indexSubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexSubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscribedEvent!]!
  indexUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnitsUpdatedEvent
  indexUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnitsUpdatedEvent!]!
  indexUnsubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnsubscribedEvent
  indexUnsubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnsubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnsubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnsubscribedEvent!]!
  subscriptionApprovedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionApprovedEvent
  subscriptionApprovedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionApprovedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionApprovedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionApprovedEvent!]!
  subscriptionDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionDistributionClaimedEvent
  subscriptionDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionDistributionClaimedEvent!]!
  subscriptionRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionRevokedEvent
  subscriptionRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionRevokedEvent!]!
  subscriptionUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionUnitsUpdatedEvent
  subscriptionUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionUnitsUpdatedEvent!]!
  agreementClassRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassRegisteredEvent
  agreementClassRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassRegisteredEvent!]!
  agreementClassUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassUpdatedEvent
  agreementClassUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassUpdatedEvent!]!
  appRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppRegisteredEvent
  appRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AppRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AppRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppRegisteredEvent!]!
  governanceReplacedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GovernanceReplacedEvent
  governanceReplacedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: GovernanceReplacedEvent_orderBy
    orderDirection: OrderDirection
    where: GovernanceReplacedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GovernanceReplacedEvent!]!
  jailEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JailEvent
  jailEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: JailEvent_orderBy
    orderDirection: OrderDirection
    where: JailEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [JailEvent!]!
  superTokenFactoryUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenFactoryUpdatedEvent
  superTokenFactoryUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenFactoryUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenFactoryUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenFactoryUpdatedEvent!]!
  superTokenLogicUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicUpdatedEvent
  superTokenLogicUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicUpdatedEvent!]!
  roleAdminChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleAdminChangedEvent
  roleAdminChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleAdminChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleAdminChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleAdminChangedEvent!]!
  roleGrantedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleGrantedEvent
  roleGrantedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleGrantedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleGrantedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleGrantedEvent!]!
  roleRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleRevokedEvent
  roleRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleRevokedEvent!]!
  setEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetEvent
  setEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SetEvent_orderBy
    orderDirection: OrderDirection
    where: SetEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetEvent!]!
  cfav1LiquidationPeriodChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CFAv1LiquidationPeriodChangedEvent
  cfav1LiquidationPeriodChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CFAv1LiquidationPeriodChangedEvent_orderBy
    orderDirection: OrderDirection
    where: CFAv1LiquidationPeriodChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CFAv1LiquidationPeriodChangedEvent!]!
  configChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConfigChangedEvent
  configChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ConfigChangedEvent_orderBy
    orderDirection: OrderDirection
    where: ConfigChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConfigChangedEvent!]!
  rewardAddressChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardAddressChangedEvent
  rewardAddressChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardAddressChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RewardAddressChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardAddressChangedEvent!]!
  pppconfigurationChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PPPConfigurationChangedEvent
  pppconfigurationChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PPPConfigurationChangedEvent_orderBy
    orderDirection: OrderDirection
    where: PPPConfigurationChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PPPConfigurationChangedEvent!]!
  trustedForwarderChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TrustedForwarderChangedEvent
  trustedForwarderChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TrustedForwarderChangedEvent_orderBy
    orderDirection: OrderDirection
    where: TrustedForwarderChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TrustedForwarderChangedEvent!]!
  agreementLiquidatedByEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedByEvent
  agreementLiquidatedByEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedByEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedByEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedByEvent!]!
  agreementLiquidatedV2Event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedV2Event
  agreementLiquidatedV2Events(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedV2Event_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedV2Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedV2Event!]!
  burnedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BurnedEvent
  burnedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BurnedEvent_orderBy
    orderDirection: OrderDirection
    where: BurnedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BurnedEvent!]!
  mintedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MintedEvent
  mintedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: MintedEvent_orderBy
    orderDirection: OrderDirection
    where: MintedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MintedEvent!]!
  sentEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SentEvent
  sentEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SentEvent_orderBy
    orderDirection: OrderDirection
    where: SentEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SentEvent!]!
  transferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferEvent
  transferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TransferEvent_orderBy
    orderDirection: OrderDirection
    where: TransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransferEvent!]!
  tokenDowngradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDowngradedEvent
  tokenDowngradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenDowngradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenDowngradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenDowngradedEvent!]!
  tokenUpgradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenUpgradedEvent
  tokenUpgradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenUpgradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenUpgradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenUpgradedEvent!]!
  customSuperTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CustomSuperTokenCreatedEvent
  customSuperTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CustomSuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: CustomSuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CustomSuperTokenCreatedEvent!]!
  superTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenCreatedEvent
  superTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenCreatedEvent!]!
  superTokenLogicCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicCreatedEvent
  superTokenLogicCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicCreatedEvent!]!
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  index(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Index
  indexes(
    skip: Int = 0
    first: Int = 100
    orderBy: Index_orderBy
    orderDirection: OrderDirection
    where: Index_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Index!]!
  indexSubscription(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscription
  indexSubscriptions(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscription_orderBy
    orderDirection: OrderDirection
    where: IndexSubscription_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscription!]!
  stream(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stream
  streams(
    skip: Int = 0
    first: Int = 100
    orderBy: Stream_orderBy
    orderDirection: OrderDirection
    where: Stream_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Stream!]!
  flowOperator(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperator
  flowOperators(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperator_orderBy
    orderDirection: OrderDirection
    where: FlowOperator_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperator!]!
  streamPeriod(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamPeriod
  streamPeriods(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamPeriod_orderBy
    orderDirection: OrderDirection
    where: StreamPeriod_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamPeriod!]!
  streamRevision(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamRevision
  streamRevisions(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamRevision_orderBy
    orderDirection: OrderDirection
    where: StreamRevision_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamRevision!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  resolverEntry(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEntry
  resolverEntries(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEntry_orderBy
    orderDirection: OrderDirection
    where: ResolverEntry_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEntry!]!
  accountTokenSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshot
  accountTokenSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshot_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshot!]!
  accountTokenSnapshotLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshotLog
  accountTokenSnapshotLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshotLog_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshotLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshotLog!]!
  tokenStatistic(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatistic
  tokenStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatistic_orderBy
    orderDirection: OrderDirection
    where: TokenStatistic_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatistic!]!
  tokenStatisticLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatisticLog
  tokenStatisticLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatisticLog_orderBy
    orderDirection: OrderDirection
    where: TokenStatisticLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatisticLog!]!
  sfmeta(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SFMeta
  sfmetas(
    skip: Int = 0
    first: Int = 100
    orderBy: SFMeta_orderBy
    orderDirection: OrderDirection
    where: SFMeta_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SFMeta!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type ResolverEntry {
  """
  ID: the keccak256 hash of the set name
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
  targetAddress: Bytes!
  isToken: Boolean!
  isListed: Boolean!
  setEvents(skip: Int = 0, first: Int = 100, orderBy: SetEvent_orderBy, orderDirection: OrderDirection, where: SetEvent_filter): [SetEvent!]!
}

input ResolverEntry_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  targetAddress: Bytes
  targetAddress_not: Bytes
  targetAddress_in: [Bytes!]
  targetAddress_not_in: [Bytes!]
  targetAddress_contains: Bytes
  targetAddress_not_contains: Bytes
  isToken: Boolean
  isToken_not: Boolean
  isToken_in: [Boolean!]
  isToken_not_in: [Boolean!]
  isListed: Boolean
  isListed_not: Boolean
  isListed_in: [Boolean!]
  isListed_not_in: [Boolean!]
  setEvents_: SetEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ResolverEntry_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  targetAddress
  isToken
  isListed
  setEvents
}

type RewardAddressChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  rewardAddress: Bytes!
}

input RewardAddressChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  rewardAddress: Bytes
  rewardAddress_not: Bytes
  rewardAddress_in: [Bytes!]
  rewardAddress_not_in: [Bytes!]
  rewardAddress_contains: Bytes
  rewardAddress_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum RewardAddressChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  isKeySet
  rewardAddress
}

type RoleAdminChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  role: Bytes!
  previousAdminRole: Bytes!
  newAdminRole: Bytes!
}

input RoleAdminChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  role: Bytes
  role_not: Bytes
  role_in: [Bytes!]
  role_not_in: [Bytes!]
  role_contains: Bytes
  role_not_contains: Bytes
  previousAdminRole: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_not_in: [Bytes!]
  previousAdminRole_contains: Bytes
  previousAdminRole_not_contains: Bytes
  newAdminRole: Bytes
  newAdminRole_not: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_not_in: [Bytes!]
  newAdminRole_contains: Bytes
  newAdminRole_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum RoleAdminChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  role
  previousAdminRole
  newAdminRole
}

type RoleGrantedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  role: Bytes!
  account: Bytes!
  sender: Bytes!
}

input RoleGrantedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  role: Bytes
  role_not: Bytes
  role_in: [Bytes!]
  role_not_in: [Bytes!]
  role_contains: Bytes
  role_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum RoleGrantedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  role
  account
  sender
}

type RoleRevokedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  role: Bytes!
  account: Bytes!
  sender: Bytes!
}

input RoleRevokedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  role: Bytes
  role_not: Bytes
  role_in: [Bytes!]
  role_not_in: [Bytes!]
  role_contains: Bytes
  role_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum RoleRevokedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  role
  account
  sender
}

type SentEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, operator and from addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  operator: Bytes!
  from: Bytes!
  to: Bytes!
  token: Bytes!
  amount: BigInt!
  data: Bytes!
  operatorData: Bytes!
}

input SentEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  operator: Bytes
  operator_not: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  data: Bytes
  data_not: Bytes
  data_in: [Bytes!]
  data_not_in: [Bytes!]
  data_contains: Bytes
  data_not_contains: Bytes
  operatorData: Bytes
  operatorData_not: Bytes
  operatorData_in: [Bytes!]
  operatorData_not_in: [Bytes!]
  operatorData_contains: Bytes
  operatorData_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SentEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  operator
  from
  to
  token
  amount
  data
  operatorData
}

type SetEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  Because the name property is indexed, the
  returned value will be a keccak256 hash
  of the string.
  
  """
  hashedName: Bytes!
  target: Bytes!
  resolverEntry: ResolverEntry!
}

input SetEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  hashedName: Bytes
  hashedName_not: Bytes
  hashedName_in: [Bytes!]
  hashedName_not_in: [Bytes!]
  hashedName_contains: Bytes
  hashedName_not_contains: Bytes
  target: Bytes
  target_not: Bytes
  target_in: [Bytes!]
  target_not_in: [Bytes!]
  target_contains: Bytes
  target_not_contains: Bytes
  resolverEntry: String
  resolverEntry_not: String
  resolverEntry_gt: String
  resolverEntry_lt: String
  resolverEntry_gte: String
  resolverEntry_lte: String
  resolverEntry_in: [String!]
  resolverEntry_not_in: [String!]
  resolverEntry_contains: String
  resolverEntry_contains_nocase: String
  resolverEntry_not_contains: String
  resolverEntry_not_contains_nocase: String
  resolverEntry_starts_with: String
  resolverEntry_starts_with_nocase: String
  resolverEntry_not_starts_with: String
  resolverEntry_not_starts_with_nocase: String
  resolverEntry_ends_with: String
  resolverEntry_ends_with_nocase: String
  resolverEntry_not_ends_with: String
  resolverEntry_not_ends_with_nocase: String
  resolverEntry_: ResolverEntry_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SetEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  hashedName
  target
  resolverEntry
}

type SFMeta {
  """
  The id is the commit hash.
  
  """
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!

  """
  Whether the branch is feature/dev/v1.
  
  """
  configuration: String!

  """
  The branch the current deployment is coming from.
  
  """
  branch: String!
}

input SFMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  configuration: String
  configuration_not: String
  configuration_gt: String
  configuration_lt: String
  configuration_gte: String
  configuration_lte: String
  configuration_in: [String!]
  configuration_not_in: [String!]
  configuration_contains: String
  configuration_contains_nocase: String
  configuration_not_contains: String
  configuration_not_contains_nocase: String
  configuration_starts_with: String
  configuration_starts_with_nocase: String
  configuration_not_starts_with: String
  configuration_not_starts_with_nocase: String
  configuration_ends_with: String
  configuration_ends_with_nocase: String
  configuration_not_ends_with: String
  configuration_not_ends_with_nocase: String
  branch: String
  branch_not: String
  branch_gt: String
  branch_lt: String
  branch_gte: String
  branch_lte: String
  branch_in: [String!]
  branch_not_in: [String!]
  branch_contains: String
  branch_contains_nocase: String
  branch_not_contains: String
  branch_not_contains_nocase: String
  branch_starts_with: String
  branch_starts_with_nocase: String
  branch_not_starts_with: String
  branch_not_starts_with_nocase: String
  branch_ends_with: String
  branch_ends_with_nocase: String
  branch_not_ends_with: String
  branch_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SFMeta_orderBy {
  id
  timestamp
  blockNumber
  configuration
  branch
}

"""
Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
A account can start a stream, update the flow rate, but when they close it, it is
considered "dead". The next stream you create with the same `sender` and `receiver`
will create a new stream entity. Therefore, multiple stream entities can be created
between the same `sender` and `receiver`.

"""
type Stream {
  """
  ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
  currentFlowRate: BigInt!
  deposit: BigInt!

  """
  The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`. The formula to get the current streamed
  amount is:
  `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
  
  """
  streamedUntilUpdatedAt: BigInt!
  token: Token!
  sender: Account!
  receiver: Account!
  flowUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: FlowUpdatedEvent_orderBy, orderDirection: OrderDirection, where: FlowUpdatedEvent_filter): [FlowUpdatedEvent!]!
  streamPeriods(skip: Int = 0, first: Int = 100, orderBy: StreamPeriod_orderBy, orderDirection: OrderDirection, where: StreamPeriod_filter): [StreamPeriod!]!
}

input Stream_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  currentFlowRate: BigInt
  currentFlowRate_not: BigInt
  currentFlowRate_gt: BigInt
  currentFlowRate_lt: BigInt
  currentFlowRate_gte: BigInt
  currentFlowRate_lte: BigInt
  currentFlowRate_in: [BigInt!]
  currentFlowRate_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  streamedUntilUpdatedAt: BigInt
  streamedUntilUpdatedAt_not: BigInt
  streamedUntilUpdatedAt_gt: BigInt
  streamedUntilUpdatedAt_lt: BigInt
  streamedUntilUpdatedAt_gte: BigInt
  streamedUntilUpdatedAt_lte: BigInt
  streamedUntilUpdatedAt_in: [BigInt!]
  streamedUntilUpdatedAt_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Account_filter
  receiver: String
  receiver_not: String
  receiver_gt: String
  receiver_lt: String
  receiver_gte: String
  receiver_lte: String
  receiver_in: [String!]
  receiver_not_in: [String!]
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_: Account_filter
  flowUpdatedEvents_: FlowUpdatedEvent_filter
  streamPeriods_: StreamPeriod_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Stream_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  currentFlowRate
  deposit
  streamedUntilUpdatedAt
  token
  sender
  receiver
  flowUpdatedEvents
  streamPeriods
}

"""
StreamPeriod: A higher order entity that represents a period of time in a Stream with a constant flowRate.

"""
type StreamPeriod {
  """
  ID composed of: streamId - periodRevisionIndex
  
  """
  id: ID!
  stream: Stream!
  sender: Account!
  receiver: Account!
  token: Token!
  flowRate: BigInt!
  deposit: BigInt!
  startedAtTimestamp: BigInt!
  startedAtBlockNumber: BigInt!
  startedAtEvent: FlowUpdatedEvent!

  """
  Following values are null until the StreamPeriod is terminated
  
  """
  stoppedAtTimestamp: BigInt
  stoppedAtBlockNumber: BigInt
  stoppedAtEvent: FlowUpdatedEvent
  totalAmountStreamed: BigInt
}

input StreamPeriod_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stream: String
  stream_not: String
  stream_gt: String
  stream_lt: String
  stream_gte: String
  stream_lte: String
  stream_in: [String!]
  stream_not_in: [String!]
  stream_contains: String
  stream_contains_nocase: String
  stream_not_contains: String
  stream_not_contains_nocase: String
  stream_starts_with: String
  stream_starts_with_nocase: String
  stream_not_starts_with: String
  stream_not_starts_with_nocase: String
  stream_ends_with: String
  stream_ends_with_nocase: String
  stream_not_ends_with: String
  stream_not_ends_with_nocase: String
  stream_: Stream_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Account_filter
  receiver: String
  receiver_not: String
  receiver_gt: String
  receiver_lt: String
  receiver_gte: String
  receiver_lte: String
  receiver_in: [String!]
  receiver_not_in: [String!]
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  flowRate: BigInt
  flowRate_not: BigInt
  flowRate_gt: BigInt
  flowRate_lt: BigInt
  flowRate_gte: BigInt
  flowRate_lte: BigInt
  flowRate_in: [BigInt!]
  flowRate_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  startedAtTimestamp: BigInt
  startedAtTimestamp_not: BigInt
  startedAtTimestamp_gt: BigInt
  startedAtTimestamp_lt: BigInt
  startedAtTimestamp_gte: BigInt
  startedAtTimestamp_lte: BigInt
  startedAtTimestamp_in: [BigInt!]
  startedAtTimestamp_not_in: [BigInt!]
  startedAtBlockNumber: BigInt
  startedAtBlockNumber_not: BigInt
  startedAtBlockNumber_gt: BigInt
  startedAtBlockNumber_lt: BigInt
  startedAtBlockNumber_gte: BigInt
  startedAtBlockNumber_lte: BigInt
  startedAtBlockNumber_in: [BigInt!]
  startedAtBlockNumber_not_in: [BigInt!]
  startedAtEvent: String
  startedAtEvent_not: String
  startedAtEvent_gt: String
  startedAtEvent_lt: String
  startedAtEvent_gte: String
  startedAtEvent_lte: String
  startedAtEvent_in: [String!]
  startedAtEvent_not_in: [String!]
  startedAtEvent_contains: String
  startedAtEvent_contains_nocase: String
  startedAtEvent_not_contains: String
  startedAtEvent_not_contains_nocase: String
  startedAtEvent_starts_with: String
  startedAtEvent_starts_with_nocase: String
  startedAtEvent_not_starts_with: String
  startedAtEvent_not_starts_with_nocase: String
  startedAtEvent_ends_with: String
  startedAtEvent_ends_with_nocase: String
  startedAtEvent_not_ends_with: String
  startedAtEvent_not_ends_with_nocase: String
  startedAtEvent_: FlowUpdatedEvent_filter
  stoppedAtTimestamp: BigInt
  stoppedAtTimestamp_not: BigInt
  stoppedAtTimestamp_gt: BigInt
  stoppedAtTimestamp_lt: BigInt
  stoppedAtTimestamp_gte: BigInt
  stoppedAtTimestamp_lte: BigInt
  stoppedAtTimestamp_in: [BigInt!]
  stoppedAtTimestamp_not_in: [BigInt!]
  stoppedAtBlockNumber: BigInt
  stoppedAtBlockNumber_not: BigInt
  stoppedAtBlockNumber_gt: BigInt
  stoppedAtBlockNumber_lt: BigInt
  stoppedAtBlockNumber_gte: BigInt
  stoppedAtBlockNumber_lte: BigInt
  stoppedAtBlockNumber_in: [BigInt!]
  stoppedAtBlockNumber_not_in: [BigInt!]
  stoppedAtEvent: String
  stoppedAtEvent_not: String
  stoppedAtEvent_gt: String
  stoppedAtEvent_lt: String
  stoppedAtEvent_gte: String
  stoppedAtEvent_lte: String
  stoppedAtEvent_in: [String!]
  stoppedAtEvent_not_in: [String!]
  stoppedAtEvent_contains: String
  stoppedAtEvent_contains_nocase: String
  stoppedAtEvent_not_contains: String
  stoppedAtEvent_not_contains_nocase: String
  stoppedAtEvent_starts_with: String
  stoppedAtEvent_starts_with_nocase: String
  stoppedAtEvent_not_starts_with: String
  stoppedAtEvent_not_starts_with_nocase: String
  stoppedAtEvent_ends_with: String
  stoppedAtEvent_ends_with_nocase: String
  stoppedAtEvent_not_ends_with: String
  stoppedAtEvent_not_ends_with_nocase: String
  stoppedAtEvent_: FlowUpdatedEvent_filter
  totalAmountStreamed: BigInt
  totalAmountStreamed_not: BigInt
  totalAmountStreamed_gt: BigInt
  totalAmountStreamed_lt: BigInt
  totalAmountStreamed_gte: BigInt
  totalAmountStreamed_lte: BigInt
  totalAmountStreamed_in: [BigInt!]
  totalAmountStreamed_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum StreamPeriod_orderBy {
  id
  stream
  sender
  receiver
  token
  flowRate
  deposit
  startedAtTimestamp
  startedAtBlockNumber
  startedAtEvent
  stoppedAtTimestamp
  stoppedAtBlockNumber
  stoppedAtEvent
  totalAmountStreamed
}

type StreamRevision {
  id: ID!
  revisionIndex: Int!
  periodRevisionIndex: Int!
}

input StreamRevision_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  revisionIndex: Int
  revisionIndex_not: Int
  revisionIndex_gt: Int
  revisionIndex_lt: Int
  revisionIndex_gte: Int
  revisionIndex_lte: Int
  revisionIndex_in: [Int!]
  revisionIndex_not_in: [Int!]
  periodRevisionIndex: Int
  periodRevisionIndex_not: Int
  periodRevisionIndex_gt: Int
  periodRevisionIndex_lt: Int
  periodRevisionIndex_gte: Int
  periodRevisionIndex_lte: Int
  periodRevisionIndex_in: [Int!]
  periodRevisionIndex_not_in: [Int!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum StreamRevision_orderBy {
  id
  revisionIndex
  periodRevisionIndex
}

type Subscription {
  flowUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowUpdatedEvent
  flowUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowUpdatedEvent!]!
  flowOperatorUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperatorUpdatedEvent
  flowOperatorUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperatorUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowOperatorUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperatorUpdatedEvent!]!
  indexCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexCreatedEvent
  indexCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexCreatedEvent!]!
  indexDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexDistributionClaimedEvent
  indexDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexDistributionClaimedEvent!]!
  indexUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUpdatedEvent
  indexUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUpdatedEvent!]!
  indexSubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscribedEvent
  indexSubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexSubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscribedEvent!]!
  indexUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnitsUpdatedEvent
  indexUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnitsUpdatedEvent!]!
  indexUnsubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnsubscribedEvent
  indexUnsubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnsubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnsubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnsubscribedEvent!]!
  subscriptionApprovedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionApprovedEvent
  subscriptionApprovedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionApprovedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionApprovedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionApprovedEvent!]!
  subscriptionDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionDistributionClaimedEvent
  subscriptionDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionDistributionClaimedEvent!]!
  subscriptionRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionRevokedEvent
  subscriptionRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionRevokedEvent!]!
  subscriptionUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionUnitsUpdatedEvent
  subscriptionUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionUnitsUpdatedEvent!]!
  agreementClassRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassRegisteredEvent
  agreementClassRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassRegisteredEvent!]!
  agreementClassUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassUpdatedEvent
  agreementClassUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassUpdatedEvent!]!
  appRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppRegisteredEvent
  appRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AppRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AppRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppRegisteredEvent!]!
  governanceReplacedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GovernanceReplacedEvent
  governanceReplacedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: GovernanceReplacedEvent_orderBy
    orderDirection: OrderDirection
    where: GovernanceReplacedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GovernanceReplacedEvent!]!
  jailEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JailEvent
  jailEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: JailEvent_orderBy
    orderDirection: OrderDirection
    where: JailEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [JailEvent!]!
  superTokenFactoryUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenFactoryUpdatedEvent
  superTokenFactoryUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenFactoryUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenFactoryUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenFactoryUpdatedEvent!]!
  superTokenLogicUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicUpdatedEvent
  superTokenLogicUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicUpdatedEvent!]!
  roleAdminChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleAdminChangedEvent
  roleAdminChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleAdminChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleAdminChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleAdminChangedEvent!]!
  roleGrantedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleGrantedEvent
  roleGrantedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleGrantedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleGrantedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleGrantedEvent!]!
  roleRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleRevokedEvent
  roleRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleRevokedEvent!]!
  setEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetEvent
  setEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SetEvent_orderBy
    orderDirection: OrderDirection
    where: SetEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetEvent!]!
  cfav1LiquidationPeriodChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CFAv1LiquidationPeriodChangedEvent
  cfav1LiquidationPeriodChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CFAv1LiquidationPeriodChangedEvent_orderBy
    orderDirection: OrderDirection
    where: CFAv1LiquidationPeriodChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CFAv1LiquidationPeriodChangedEvent!]!
  configChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConfigChangedEvent
  configChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ConfigChangedEvent_orderBy
    orderDirection: OrderDirection
    where: ConfigChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConfigChangedEvent!]!
  rewardAddressChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardAddressChangedEvent
  rewardAddressChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardAddressChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RewardAddressChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardAddressChangedEvent!]!
  pppconfigurationChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PPPConfigurationChangedEvent
  pppconfigurationChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PPPConfigurationChangedEvent_orderBy
    orderDirection: OrderDirection
    where: PPPConfigurationChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PPPConfigurationChangedEvent!]!
  trustedForwarderChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TrustedForwarderChangedEvent
  trustedForwarderChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TrustedForwarderChangedEvent_orderBy
    orderDirection: OrderDirection
    where: TrustedForwarderChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TrustedForwarderChangedEvent!]!
  agreementLiquidatedByEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedByEvent
  agreementLiquidatedByEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedByEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedByEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedByEvent!]!
  agreementLiquidatedV2Event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedV2Event
  agreementLiquidatedV2Events(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedV2Event_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedV2Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedV2Event!]!
  burnedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BurnedEvent
  burnedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BurnedEvent_orderBy
    orderDirection: OrderDirection
    where: BurnedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BurnedEvent!]!
  mintedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MintedEvent
  mintedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: MintedEvent_orderBy
    orderDirection: OrderDirection
    where: MintedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MintedEvent!]!
  sentEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SentEvent
  sentEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SentEvent_orderBy
    orderDirection: OrderDirection
    where: SentEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SentEvent!]!
  transferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferEvent
  transferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TransferEvent_orderBy
    orderDirection: OrderDirection
    where: TransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransferEvent!]!
  tokenDowngradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDowngradedEvent
  tokenDowngradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenDowngradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenDowngradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenDowngradedEvent!]!
  tokenUpgradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenUpgradedEvent
  tokenUpgradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenUpgradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenUpgradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenUpgradedEvent!]!
  customSuperTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CustomSuperTokenCreatedEvent
  customSuperTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CustomSuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: CustomSuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CustomSuperTokenCreatedEvent!]!
  superTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenCreatedEvent
  superTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenCreatedEvent!]!
  superTokenLogicCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicCreatedEvent
  superTokenLogicCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicCreatedEvent!]!
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  index(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Index
  indexes(
    skip: Int = 0
    first: Int = 100
    orderBy: Index_orderBy
    orderDirection: OrderDirection
    where: Index_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Index!]!
  indexSubscription(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscription
  indexSubscriptions(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscription_orderBy
    orderDirection: OrderDirection
    where: IndexSubscription_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscription!]!
  stream(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stream
  streams(
    skip: Int = 0
    first: Int = 100
    orderBy: Stream_orderBy
    orderDirection: OrderDirection
    where: Stream_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Stream!]!
  flowOperator(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperator
  flowOperators(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperator_orderBy
    orderDirection: OrderDirection
    where: FlowOperator_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperator!]!
  streamPeriod(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamPeriod
  streamPeriods(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamPeriod_orderBy
    orderDirection: OrderDirection
    where: StreamPeriod_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamPeriod!]!
  streamRevision(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamRevision
  streamRevisions(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamRevision_orderBy
    orderDirection: OrderDirection
    where: StreamRevision_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamRevision!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  resolverEntry(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEntry
  resolverEntries(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEntry_orderBy
    orderDirection: OrderDirection
    where: ResolverEntry_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEntry!]!
  accountTokenSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshot
  accountTokenSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshot_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshot!]!
  accountTokenSnapshotLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshotLog
  accountTokenSnapshotLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshotLog_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshotLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshotLog!]!
  tokenStatistic(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatistic
  tokenStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatistic_orderBy
    orderDirection: OrderDirection
    where: TokenStatistic_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatistic!]!
  tokenStatisticLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatisticLog
  tokenStatisticLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatisticLog_orderBy
    orderDirection: OrderDirection
    where: TokenStatisticLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatisticLog!]!
  sfmeta(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SFMeta
  sfmetas(
    skip: Int = 0
    first: Int = 100
    orderBy: SFMeta_orderBy
    orderDirection: OrderDirection
    where: SFMeta_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SFMeta!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type SubscriptionApprovedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  subscriber: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  userData: Bytes!
  subscription: IndexSubscription!
}

input SubscriptionApprovedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SubscriptionApprovedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  userData
  subscription
}

type SubscriptionDistributionClaimedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  subscriber: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  amount: BigInt!
  subscription: IndexSubscription!
}

input SubscriptionDistributionClaimedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SubscriptionDistributionClaimedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  amount
  subscription
}

type SubscriptionRevokedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  subscriber: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  userData: Bytes!
  subscription: IndexSubscription!
}

input SubscriptionRevokedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SubscriptionRevokedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  userData
  subscription
}

type SubscriptionUnitsUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, publisher and subscriber addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  subscriber: Bytes!
  publisher: Bytes!
  indexId: BigInt!
  units: BigInt!
  userData: Bytes!
  oldUnits: BigInt!
  subscription: IndexSubscription!
}

input SubscriptionUnitsUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  units: BigInt
  units_not: BigInt
  units_gt: BigInt
  units_lt: BigInt
  units_gte: BigInt
  units_lte: BigInt
  units_in: [BigInt!]
  units_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  oldUnits: BigInt
  oldUnits_not: BigInt
  oldUnits_gt: BigInt
  oldUnits_lt: BigInt
  oldUnits_gte: BigInt
  oldUnits_lte: BigInt
  oldUnits_in: [BigInt!]
  oldUnits_not_in: [BigInt!]
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SubscriptionUnitsUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  units
  userData
  oldUnits
  subscription
}

type SuperTokenCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token address.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
}

input SuperTokenCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SuperTokenCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
}

type SuperTokenFactoryUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  newFactory: Bytes!
}

input SuperTokenFactoryUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  newFactory: Bytes
  newFactory_not: Bytes
  newFactory_in: [Bytes!]
  newFactory_not_in: [Bytes!]
  newFactory_contains: Bytes
  newFactory_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SuperTokenFactoryUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  newFactory
}

type SuperTokenLogicCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  tokenLogic: Bytes!
}

input SuperTokenLogicCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  tokenLogic: Bytes
  tokenLogic_not: Bytes
  tokenLogic_in: [Bytes!]
  tokenLogic_not_in: [Bytes!]
  tokenLogic_contains: Bytes
  tokenLogic_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SuperTokenLogicCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  tokenLogic
}

type SuperTokenLogicUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  code: Bytes!
}

input SuperTokenLogicUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  code: Bytes
  code_not: Bytes
  code_in: [Bytes!]
  code_not_in: [Bytes!]
  code_contains: Bytes
  code_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum SuperTokenLogicUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  code
}

"""
Token: A higher order entity created for super tokens that are "valid" (tokens that have
Superfluid's host contract address set as the host).

"""
type Token {
  """
  ID: the token address
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  decimals: Int!
  name: String!
  symbol: String!
  isSuperToken: Boolean!

  """
  This indicates whether the token is a NativeAssetSuperToken.
  
  """
  isNativeAssetSuperToken: Boolean!

  """
  This indicates whether the token is a part of our resolver list.
  
  """
  isListed: Boolean!

  """
  The address of the underlying ERC20 token.
  
  """
  underlyingAddress: Bytes!

  """
  The underlying ERC20 token for a SuperToken or
  null for a regular ERC20 token.
  
  """
  underlyingToken: Token
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  isSuperToken: Boolean
  isSuperToken_not: Boolean
  isSuperToken_in: [Boolean!]
  isSuperToken_not_in: [Boolean!]
  isNativeAssetSuperToken: Boolean
  isNativeAssetSuperToken_not: Boolean
  isNativeAssetSuperToken_in: [Boolean!]
  isNativeAssetSuperToken_not_in: [Boolean!]
  isListed: Boolean
  isListed_not: Boolean
  isListed_in: [Boolean!]
  isListed_not_in: [Boolean!]
  underlyingAddress: Bytes
  underlyingAddress_not: Bytes
  underlyingAddress_in: [Bytes!]
  underlyingAddress_not_in: [Bytes!]
  underlyingAddress_contains: Bytes
  underlyingAddress_not_contains: Bytes
  underlyingToken: String
  underlyingToken_not: String
  underlyingToken_gt: String
  underlyingToken_lt: String
  underlyingToken_gte: String
  underlyingToken_lte: String
  underlyingToken_in: [String!]
  underlyingToken_not_in: [String!]
  underlyingToken_contains: String
  underlyingToken_contains_nocase: String
  underlyingToken_not_contains: String
  underlyingToken_not_contains_nocase: String
  underlyingToken_starts_with: String
  underlyingToken_starts_with_nocase: String
  underlyingToken_not_starts_with: String
  underlyingToken_not_starts_with_nocase: String
  underlyingToken_ends_with: String
  underlyingToken_ends_with_nocase: String
  underlyingToken_not_ends_with: String
  underlyingToken_not_ends_with_nocase: String
  underlyingToken_: Token_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Token_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  decimals
  name
  symbol
  isSuperToken
  isNativeAssetSuperToken
  isListed
  underlyingAddress
  underlyingToken
}

type TokenDowngradedEvent implements Event {
  id: ID!
  account: Account!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token and account addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  amount: BigInt!
}

input TokenDowngradedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TokenDowngradedEvent_orderBy {
  id
  account
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  amount
}

"""
TokenStatistic: An aggregate entity which aggregates data of a single `token`.

"""
type TokenStatistic {
  """
  id: token address
  
  """
  id: ID!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  The total number of currently active `token` streams.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The all-time number of closed streams.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The total number of Indexes created with `token`.
  
  """
  totalNumberOfIndexes: Int!

  """
  The total number of "active" (has greater than 0 units and has distributed it at
  least once) Indexes created with `token`.
  
  """
  totalNumberOfActiveIndexes: Int!

  """
  The number of subscriptions which have units allocated to them
  created with Indexes that distribute `token`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  The total deposit held by the CFA agreement for this particular `token`.
  
  """
  totalDeposit: BigInt!

  """
  The total outflow rate of the `token` (how much value is being moved).
  
  """
  totalOutflowRate: BigInt!

  """
  The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedUntilUpdatedAt: BigInt!

  """
  The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountTransferredUntilUpdatedAt: BigInt!

  """
  The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountDistributedUntilUpdatedAt: BigInt!

  """
  The total supply of the token - this is impacted by users upgrading/downgrading their
  tokens.
  
  """
  totalSupply: BigInt!
  token: Token!
  tokenStatisticLogs(skip: Int = 0, first: Int = 100, orderBy: TokenStatisticLog_orderBy, orderDirection: OrderDirection, where: TokenStatisticLog_filter): [TokenStatisticLog!]!
}

input TokenStatistic_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  totalNumberOfIndexes: Int
  totalNumberOfIndexes_not: Int
  totalNumberOfIndexes_gt: Int
  totalNumberOfIndexes_lt: Int
  totalNumberOfIndexes_gte: Int
  totalNumberOfIndexes_lte: Int
  totalNumberOfIndexes_in: [Int!]
  totalNumberOfIndexes_not_in: [Int!]
  totalNumberOfActiveIndexes: Int
  totalNumberOfActiveIndexes_not: Int
  totalNumberOfActiveIndexes_gt: Int
  totalNumberOfActiveIndexes_lt: Int
  totalNumberOfActiveIndexes_gte: Int
  totalNumberOfActiveIndexes_lte: Int
  totalNumberOfActiveIndexes_in: [Int!]
  totalNumberOfActiveIndexes_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt: BigInt
  totalAmountStreamedUntilUpdatedAt_not: BigInt
  totalAmountStreamedUntilUpdatedAt_gt: BigInt
  totalAmountStreamedUntilUpdatedAt_lt: BigInt
  totalAmountStreamedUntilUpdatedAt_gte: BigInt
  totalAmountStreamedUntilUpdatedAt_lte: BigInt
  totalAmountStreamedUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt_not_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt: BigInt
  totalAmountTransferredUntilUpdatedAt_not: BigInt
  totalAmountTransferredUntilUpdatedAt_gt: BigInt
  totalAmountTransferredUntilUpdatedAt_lt: BigInt
  totalAmountTransferredUntilUpdatedAt_gte: BigInt
  totalAmountTransferredUntilUpdatedAt_lte: BigInt
  totalAmountTransferredUntilUpdatedAt_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt_not_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt: BigInt
  totalAmountDistributedUntilUpdatedAt_not: BigInt
  totalAmountDistributedUntilUpdatedAt_gt: BigInt
  totalAmountDistributedUntilUpdatedAt_lt: BigInt
  totalAmountDistributedUntilUpdatedAt_gte: BigInt
  totalAmountDistributedUntilUpdatedAt_lte: BigInt
  totalAmountDistributedUntilUpdatedAt_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  tokenStatisticLogs_: TokenStatisticLog_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TokenStatistic_orderBy {
  id
  updatedAtTimestamp
  updatedAtBlockNumber
  totalNumberOfActiveStreams
  totalNumberOfClosedStreams
  totalNumberOfIndexes
  totalNumberOfActiveIndexes
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  totalDeposit
  totalOutflowRate
  totalAmountStreamedUntilUpdatedAt
  totalAmountTransferredUntilUpdatedAt
  totalAmountDistributedUntilUpdatedAt
  totalSupply
  token
  tokenStatisticLogs
}

"""
TokenStatisticLog: Historical entries of TokenStatistic updates.

"""
type TokenStatisticLog {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
  order: BigInt!
  triggeredByEventName: String!

  """
  The total number of currently active `token` streams.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The all-time number of closed streams.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The total number of Indexes created with `token`.
  
  """
  totalNumberOfIndexes: Int!

  """
  The total number of "active" (has greater than 0 units and has distributed it at
  least once) Indexes created with `token`.
  
  """
  totalNumberOfActiveIndexes: Int!

  """
  The number of subscriptions which have units allocated to them
  created with Indexes that distribute `token`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  The total deposit held by the CFA agreement for this particular `token`.
  
  """
  totalDeposit: BigInt!

  """
  The total outflow rate of the `token` (how much value is being moved).
  
  """
  totalOutflowRate: BigInt!

  """
  The all-time total amount streamed (outflows) until the `timestamp`/`block`.
  
  """
  totalAmountStreamed: BigInt!

  """
  The all-time total amount transferred until the `timestamp`/`block`.
  
  """
  totalAmountTransferred: BigInt!

  """
  The all-time total amount distributed until the `timestamp`/`block`.
  
  """
  totalAmountDistributed: BigInt!

  """
  The total supply of the token - this is impacted by users upgrading/downgrading their
  tokens.
  
  """
  totalSupply: BigInt!
  token: Token!
  tokenStatistic: TokenStatistic!
}

input TokenStatisticLog_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  triggeredByEventName: String
  triggeredByEventName_not: String
  triggeredByEventName_gt: String
  triggeredByEventName_lt: String
  triggeredByEventName_gte: String
  triggeredByEventName_lte: String
  triggeredByEventName_in: [String!]
  triggeredByEventName_not_in: [String!]
  triggeredByEventName_contains: String
  triggeredByEventName_contains_nocase: String
  triggeredByEventName_not_contains: String
  triggeredByEventName_not_contains_nocase: String
  triggeredByEventName_starts_with: String
  triggeredByEventName_starts_with_nocase: String
  triggeredByEventName_not_starts_with: String
  triggeredByEventName_not_starts_with_nocase: String
  triggeredByEventName_ends_with: String
  triggeredByEventName_ends_with_nocase: String
  triggeredByEventName_not_ends_with: String
  triggeredByEventName_not_ends_with_nocase: String
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  totalNumberOfIndexes: Int
  totalNumberOfIndexes_not: Int
  totalNumberOfIndexes_gt: Int
  totalNumberOfIndexes_lt: Int
  totalNumberOfIndexes_gte: Int
  totalNumberOfIndexes_lte: Int
  totalNumberOfIndexes_in: [Int!]
  totalNumberOfIndexes_not_in: [Int!]
  totalNumberOfActiveIndexes: Int
  totalNumberOfActiveIndexes_not: Int
  totalNumberOfActiveIndexes_gt: Int
  totalNumberOfActiveIndexes_lt: Int
  totalNumberOfActiveIndexes_gte: Int
  totalNumberOfActiveIndexes_lte: Int
  totalNumberOfActiveIndexes_in: [Int!]
  totalNumberOfActiveIndexes_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamed: BigInt
  totalAmountStreamed_not: BigInt
  totalAmountStreamed_gt: BigInt
  totalAmountStreamed_lt: BigInt
  totalAmountStreamed_gte: BigInt
  totalAmountStreamed_lte: BigInt
  totalAmountStreamed_in: [BigInt!]
  totalAmountStreamed_not_in: [BigInt!]
  totalAmountTransferred: BigInt
  totalAmountTransferred_not: BigInt
  totalAmountTransferred_gt: BigInt
  totalAmountTransferred_lt: BigInt
  totalAmountTransferred_gte: BigInt
  totalAmountTransferred_lte: BigInt
  totalAmountTransferred_in: [BigInt!]
  totalAmountTransferred_not_in: [BigInt!]
  totalAmountDistributed: BigInt
  totalAmountDistributed_not: BigInt
  totalAmountDistributed_gt: BigInt
  totalAmountDistributed_lt: BigInt
  totalAmountDistributed_gte: BigInt
  totalAmountDistributed_lte: BigInt
  totalAmountDistributed_in: [BigInt!]
  totalAmountDistributed_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  tokenStatistic: String
  tokenStatistic_not: String
  tokenStatistic_gt: String
  tokenStatistic_lt: String
  tokenStatistic_gte: String
  tokenStatistic_lte: String
  tokenStatistic_in: [String!]
  tokenStatistic_not_in: [String!]
  tokenStatistic_contains: String
  tokenStatistic_contains_nocase: String
  tokenStatistic_not_contains: String
  tokenStatistic_not_contains_nocase: String
  tokenStatistic_starts_with: String
  tokenStatistic_starts_with_nocase: String
  tokenStatistic_not_starts_with: String
  tokenStatistic_not_starts_with_nocase: String
  tokenStatistic_ends_with: String
  tokenStatistic_ends_with_nocase: String
  tokenStatistic_not_ends_with: String
  tokenStatistic_not_ends_with_nocase: String
  tokenStatistic_: TokenStatistic_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TokenStatisticLog_orderBy {
  id
  timestamp
  blockNumber
  transactionHash
  logIndex
  order
  triggeredByEventName
  totalNumberOfActiveStreams
  totalNumberOfClosedStreams
  totalNumberOfIndexes
  totalNumberOfActiveIndexes
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  totalDeposit
  totalOutflowRate
  totalAmountStreamed
  totalAmountTransferred
  totalAmountDistributed
  totalSupply
  token
  tokenStatistic
}

type TokenUpgradedEvent implements Event {
  id: ID!
  account: Account!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token and account addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  amount: BigInt!
}

input TokenUpgradedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TokenUpgradedEvent_orderBy {
  id
  account
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  amount
}

type TransferEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Holds the token, from and to addresses.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  from: Account!
  to: Account!
  value: BigInt!
  token: Bytes!
}

input TransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: Account_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: Account_filter
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TransferEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  from
  to
  value
  token
}

type TrustedForwarderChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  forwarder: Bytes!
  enabled: Boolean!
}

input TrustedForwarderChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  forwarder: Bytes
  forwarder_not: Bytes
  forwarder_in: [Bytes!]
  forwarder_not_in: [Bytes!]
  forwarder_contains: Bytes
  forwarder_not_contains: Bytes
  enabled: Boolean
  enabled_not: Boolean
  enabled_in: [Boolean!]
  enabled_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum TrustedForwarderChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  isKeySet
  forwarder
  enabled
}

