"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

"""
Account: A higher order entity created for any addresses which interact with Superfluid contracts.

"""
type Account {
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  Indicates whether the address/account is a super app.
  
  """
  isSuperApp: Boolean!
  inflows(skip: Int = 0, first: Int = 100, orderBy: Stream_orderBy, orderDirection: OrderDirection, where: Stream_filter): [Stream!]!
  outflows(skip: Int = 0, first: Int = 100, orderBy: Stream_orderBy, orderDirection: OrderDirection, where: Stream_filter): [Stream!]!
  subscriptions(skip: Int = 0, first: Int = 100, orderBy: IndexSubscription_orderBy, orderDirection: OrderDirection, where: IndexSubscription_filter): [IndexSubscription!]!
  publishedIndexes(skip: Int = 0, first: Int = 100, orderBy: Index_orderBy, orderDirection: OrderDirection, where: Index_filter): [Index!]!
  sentTransferEvents(skip: Int = 0, first: Int = 100, orderBy: TransferEvent_orderBy, orderDirection: OrderDirection, where: TransferEvent_filter): [TransferEvent!]!
  receivedTransferEvents(skip: Int = 0, first: Int = 100, orderBy: TransferEvent_orderBy, orderDirection: OrderDirection, where: TransferEvent_filter): [TransferEvent!]!
  tokenUpgradedEvents(skip: Int = 0, first: Int = 100, orderBy: TokenUpgradedEvent_orderBy, orderDirection: OrderDirection, where: TokenUpgradedEvent_filter): [TokenUpgradedEvent!]!
  tokenDowngradedEvents(skip: Int = 0, first: Int = 100, orderBy: TokenDowngradedEvent_orderBy, orderDirection: OrderDirection, where: TokenDowngradedEvent_filter): [TokenDowngradedEvent!]!
  accountTokenSnapshots(skip: Int = 0, first: Int = 100, orderBy: AccountTokenSnapshot_orderBy, orderDirection: OrderDirection, where: AccountTokenSnapshot_filter): [AccountTokenSnapshot!]!
}

input Account_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  isSuperApp: Boolean
  isSuperApp_not: Boolean
  isSuperApp_in: [Boolean!]
  isSuperApp_not_in: [Boolean!]
  inflows_: Stream_filter
  outflows_: Stream_filter
  subscriptions_: IndexSubscription_filter
  publishedIndexes_: Index_filter
  sentTransferEvents_: TransferEvent_filter
  receivedTransferEvents_: TransferEvent_filter
  tokenUpgradedEvents_: TokenUpgradedEvent_filter
  tokenDowngradedEvents_: TokenDowngradedEvent_filter
  accountTokenSnapshots_: AccountTokenSnapshot_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Account_filter]
  or: [Account_filter]
}

enum Account_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  isSuperApp
  inflows
  outflows
  subscriptions
  publishedIndexes
  sentTransferEvents
  receivedTransferEvents
  tokenUpgradedEvents
  tokenDowngradedEvents
  accountTokenSnapshots
}

"""
AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.

"""
type AccountTokenSnapshot {
  """
  ID composed of: accountID-tokenID
  
  """
  id: ID!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  isLiquidationEstimateOptimistic, If `totalSubscriptionsWithUnits > 0`, it is true.
  "Optimistic" can be thought of as conservative as it refers to the earliest
  time the user may be liquidated as they may receive ongoing distributions
  which aren't tracked by the subgraph.
  
  """
  isLiquidationEstimateOptimistic: Boolean!

  """
  Optimistic liquidation estimation property.
  
  """
  maybeCriticalAtTimestamp: BigInt

  """
  The count of currently open streams for an account, both incoming and outgoing.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The count of active outgoing streams from this account.
  
  """
  activeOutgoingStreamCount: Int!

  """
  The count of active incoming streams to this account.
  
  """
  activeIncomingStreamCount: Int!

  """
  The count of closed streams by `account`, both incoming and outgoing.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The count of closed outgoing streams by `account`.
  
  """
  inactiveOutgoingStreamCount: Int!

  """
  The count of closed incoming streams by `account`.
  
  """
  inactiveIncomingStreamCount: Int!

  """
  The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all currently (as of updatedAt) approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  balanceUntilUpdatedAt: BigInt!

  """
  The total deposit this account has held by the CFA agreement for `account` active streams.
  
  """
  totalDeposit: BigInt!

  """
  The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalNetFlowRate: BigInt!

  """
  The total inflow rate (receive flowRate per second) of the `account`.
  
  """
  totalInflowRate: BigInt!

  """
  The total outflow rate (send flowrate per second) of the `account`.
  
  """
  totalOutflowRate: BigInt!

  """
  The total amount of `token` streamed into this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedInUntilUpdatedAt: BigInt!

  """
  The total amount of `token` streamed from this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedOutUntilUpdatedAt: BigInt!

  """
  The total amount of `token` streamed through this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedUntilUpdatedAt: BigInt!

  """
  The total amount of `token` this `account` has transferred.
  
  """
  totalAmountTransferredUntilUpdatedAt: BigInt!
  account: Account!
  token: Token!
  flowOperators(skip: Int = 0, first: Int = 100, orderBy: FlowOperator_orderBy, orderDirection: OrderDirection, where: FlowOperator_filter): [FlowOperator!]!
  accountTokenSnapshotLogs(skip: Int = 0, first: Int = 100, orderBy: AccountTokenSnapshotLog_orderBy, orderDirection: OrderDirection, where: AccountTokenSnapshotLog_filter): [AccountTokenSnapshotLog!]!
}

input AccountTokenSnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  isLiquidationEstimateOptimistic: Boolean
  isLiquidationEstimateOptimistic_not: Boolean
  isLiquidationEstimateOptimistic_in: [Boolean!]
  isLiquidationEstimateOptimistic_not_in: [Boolean!]
  maybeCriticalAtTimestamp: BigInt
  maybeCriticalAtTimestamp_not: BigInt
  maybeCriticalAtTimestamp_gt: BigInt
  maybeCriticalAtTimestamp_lt: BigInt
  maybeCriticalAtTimestamp_gte: BigInt
  maybeCriticalAtTimestamp_lte: BigInt
  maybeCriticalAtTimestamp_in: [BigInt!]
  maybeCriticalAtTimestamp_not_in: [BigInt!]
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  activeOutgoingStreamCount: Int
  activeOutgoingStreamCount_not: Int
  activeOutgoingStreamCount_gt: Int
  activeOutgoingStreamCount_lt: Int
  activeOutgoingStreamCount_gte: Int
  activeOutgoingStreamCount_lte: Int
  activeOutgoingStreamCount_in: [Int!]
  activeOutgoingStreamCount_not_in: [Int!]
  activeIncomingStreamCount: Int
  activeIncomingStreamCount_not: Int
  activeIncomingStreamCount_gt: Int
  activeIncomingStreamCount_lt: Int
  activeIncomingStreamCount_gte: Int
  activeIncomingStreamCount_lte: Int
  activeIncomingStreamCount_in: [Int!]
  activeIncomingStreamCount_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  inactiveOutgoingStreamCount: Int
  inactiveOutgoingStreamCount_not: Int
  inactiveOutgoingStreamCount_gt: Int
  inactiveOutgoingStreamCount_lt: Int
  inactiveOutgoingStreamCount_gte: Int
  inactiveOutgoingStreamCount_lte: Int
  inactiveOutgoingStreamCount_in: [Int!]
  inactiveOutgoingStreamCount_not_in: [Int!]
  inactiveIncomingStreamCount: Int
  inactiveIncomingStreamCount_not: Int
  inactiveIncomingStreamCount_gt: Int
  inactiveIncomingStreamCount_lt: Int
  inactiveIncomingStreamCount_gte: Int
  inactiveIncomingStreamCount_lte: Int
  inactiveIncomingStreamCount_in: [Int!]
  inactiveIncomingStreamCount_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  balanceUntilUpdatedAt: BigInt
  balanceUntilUpdatedAt_not: BigInt
  balanceUntilUpdatedAt_gt: BigInt
  balanceUntilUpdatedAt_lt: BigInt
  balanceUntilUpdatedAt_gte: BigInt
  balanceUntilUpdatedAt_lte: BigInt
  balanceUntilUpdatedAt_in: [BigInt!]
  balanceUntilUpdatedAt_not_in: [BigInt!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalNetFlowRate: BigInt
  totalNetFlowRate_not: BigInt
  totalNetFlowRate_gt: BigInt
  totalNetFlowRate_lt: BigInt
  totalNetFlowRate_gte: BigInt
  totalNetFlowRate_lte: BigInt
  totalNetFlowRate_in: [BigInt!]
  totalNetFlowRate_not_in: [BigInt!]
  totalInflowRate: BigInt
  totalInflowRate_not: BigInt
  totalInflowRate_gt: BigInt
  totalInflowRate_lt: BigInt
  totalInflowRate_gte: BigInt
  totalInflowRate_lte: BigInt
  totalInflowRate_in: [BigInt!]
  totalInflowRate_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamedInUntilUpdatedAt: BigInt
  totalAmountStreamedInUntilUpdatedAt_not: BigInt
  totalAmountStreamedInUntilUpdatedAt_gt: BigInt
  totalAmountStreamedInUntilUpdatedAt_lt: BigInt
  totalAmountStreamedInUntilUpdatedAt_gte: BigInt
  totalAmountStreamedInUntilUpdatedAt_lte: BigInt
  totalAmountStreamedInUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedInUntilUpdatedAt_not_in: [BigInt!]
  totalAmountStreamedOutUntilUpdatedAt: BigInt
  totalAmountStreamedOutUntilUpdatedAt_not: BigInt
  totalAmountStreamedOutUntilUpdatedAt_gt: BigInt
  totalAmountStreamedOutUntilUpdatedAt_lt: BigInt
  totalAmountStreamedOutUntilUpdatedAt_gte: BigInt
  totalAmountStreamedOutUntilUpdatedAt_lte: BigInt
  totalAmountStreamedOutUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedOutUntilUpdatedAt_not_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt: BigInt
  totalAmountStreamedUntilUpdatedAt_not: BigInt
  totalAmountStreamedUntilUpdatedAt_gt: BigInt
  totalAmountStreamedUntilUpdatedAt_lt: BigInt
  totalAmountStreamedUntilUpdatedAt_gte: BigInt
  totalAmountStreamedUntilUpdatedAt_lte: BigInt
  totalAmountStreamedUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt_not_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt: BigInt
  totalAmountTransferredUntilUpdatedAt_not: BigInt
  totalAmountTransferredUntilUpdatedAt_gt: BigInt
  totalAmountTransferredUntilUpdatedAt_lt: BigInt
  totalAmountTransferredUntilUpdatedAt_gte: BigInt
  totalAmountTransferredUntilUpdatedAt_lte: BigInt
  totalAmountTransferredUntilUpdatedAt_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt_not_in: [BigInt!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  flowOperators_: FlowOperator_filter
  accountTokenSnapshotLogs_: AccountTokenSnapshotLog_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AccountTokenSnapshot_filter]
  or: [AccountTokenSnapshot_filter]
}

enum AccountTokenSnapshot_orderBy {
  id
  updatedAtTimestamp
  updatedAtBlockNumber
  isLiquidationEstimateOptimistic
  maybeCriticalAtTimestamp
  totalNumberOfActiveStreams
  activeOutgoingStreamCount
  activeIncomingStreamCount
  totalNumberOfClosedStreams
  inactiveOutgoingStreamCount
  inactiveIncomingStreamCount
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  balanceUntilUpdatedAt
  totalDeposit
  totalNetFlowRate
  totalInflowRate
  totalOutflowRate
  totalAmountStreamedInUntilUpdatedAt
  totalAmountStreamedOutUntilUpdatedAt
  totalAmountStreamedUntilUpdatedAt
  totalAmountTransferredUntilUpdatedAt
  account
  account__id
  account__createdAtTimestamp
  account__createdAtBlockNumber
  account__updatedAtTimestamp
  account__updatedAtBlockNumber
  account__isSuperApp
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  flowOperators
  accountTokenSnapshotLogs
}

"""
AccountTokenSnapshotLog: Historical entries of `AccountTokenSnapshot` updates.

"""
type AccountTokenSnapshotLog {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
  order: BigInt!
  triggeredByEventName: String!

  """
  Optimistic liquidation estimation property.
  
  """
  maybeCriticalAtTimestamp: BigInt

  """
  The current (as of timestamp) number of open streams.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The count of active outgoing streams from this account.
  
  """
  activeOutgoingStreamCount: Int!

  """
  The count of active incoming streams to this account.
  
  """
  activeIncomingStreamCount: Int!

  """
  The current (as of timestamp) count of closed streams.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The count of closed outgoing streams by `account`.
  
  """
  inactiveOutgoingStreamCount: Int!

  """
  The count of closed incoming streams by `account`.
  
  """
  inactiveIncomingStreamCount: Int!

  """
  The current (as of timestamp) number of subscriptions with units allocated to them tied to this `account`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all currently (as of timestamp) approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  Balance of `account` as of `timestamp`/`block`.
  
  """
  balance: BigInt!

  """
  The total (as of timestamp) deposit this account has held by the CFA agreement for `account` active streams.
  
  """
  totalDeposit: BigInt!

  """
  The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block`.
  This can be obtained by: `totalInflowRate - totalOutflowRate`
  
  """
  totalNetFlowRate: BigInt!

  """
  The total (as of timestamp) inflow rate (receive flowRate per second) of the `account`.
  
  """
  totalInflowRate: BigInt!

  """
  The total (as of timestamp) outflow rate (send flowrate per second) of the `account`.
  
  """
  totalOutflowRate: BigInt!

  """
  The total (as of timestamp) amount of `token` streamed into this `account` until the `timestamp`/`block`.
  
  """
  totalAmountStreamedIn: BigInt!

  """
  The total (as of timestamp) amount of `token` streamed from this `account` until the `timestamp`/`block`.
  
  """
  totalAmountStreamedOut: BigInt!

  """
  The total (as of timestamp) net amount of `token` streamed through this `account` until the `timestamp`/`block`.
  
  """
  totalAmountStreamed: BigInt!

  """
  The total (as of timestamp) amount of `token` this `account` has transferred out until the `timestamp`/`block`.
  
  """
  totalAmountTransferred: BigInt!
  account: Account!
  token: Token!
  accountTokenSnapshot: AccountTokenSnapshot!
}

input AccountTokenSnapshotLog_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  triggeredByEventName: String
  triggeredByEventName_not: String
  triggeredByEventName_gt: String
  triggeredByEventName_lt: String
  triggeredByEventName_gte: String
  triggeredByEventName_lte: String
  triggeredByEventName_in: [String!]
  triggeredByEventName_not_in: [String!]
  triggeredByEventName_contains: String
  triggeredByEventName_contains_nocase: String
  triggeredByEventName_not_contains: String
  triggeredByEventName_not_contains_nocase: String
  triggeredByEventName_starts_with: String
  triggeredByEventName_starts_with_nocase: String
  triggeredByEventName_not_starts_with: String
  triggeredByEventName_not_starts_with_nocase: String
  triggeredByEventName_ends_with: String
  triggeredByEventName_ends_with_nocase: String
  triggeredByEventName_not_ends_with: String
  triggeredByEventName_not_ends_with_nocase: String
  maybeCriticalAtTimestamp: BigInt
  maybeCriticalAtTimestamp_not: BigInt
  maybeCriticalAtTimestamp_gt: BigInt
  maybeCriticalAtTimestamp_lt: BigInt
  maybeCriticalAtTimestamp_gte: BigInt
  maybeCriticalAtTimestamp_lte: BigInt
  maybeCriticalAtTimestamp_in: [BigInt!]
  maybeCriticalAtTimestamp_not_in: [BigInt!]
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  activeOutgoingStreamCount: Int
  activeOutgoingStreamCount_not: Int
  activeOutgoingStreamCount_gt: Int
  activeOutgoingStreamCount_lt: Int
  activeOutgoingStreamCount_gte: Int
  activeOutgoingStreamCount_lte: Int
  activeOutgoingStreamCount_in: [Int!]
  activeOutgoingStreamCount_not_in: [Int!]
  activeIncomingStreamCount: Int
  activeIncomingStreamCount_not: Int
  activeIncomingStreamCount_gt: Int
  activeIncomingStreamCount_lt: Int
  activeIncomingStreamCount_gte: Int
  activeIncomingStreamCount_lte: Int
  activeIncomingStreamCount_in: [Int!]
  activeIncomingStreamCount_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  inactiveOutgoingStreamCount: Int
  inactiveOutgoingStreamCount_not: Int
  inactiveOutgoingStreamCount_gt: Int
  inactiveOutgoingStreamCount_lt: Int
  inactiveOutgoingStreamCount_gte: Int
  inactiveOutgoingStreamCount_lte: Int
  inactiveOutgoingStreamCount_in: [Int!]
  inactiveOutgoingStreamCount_not_in: [Int!]
  inactiveIncomingStreamCount: Int
  inactiveIncomingStreamCount_not: Int
  inactiveIncomingStreamCount_gt: Int
  inactiveIncomingStreamCount_lt: Int
  inactiveIncomingStreamCount_gte: Int
  inactiveIncomingStreamCount_lte: Int
  inactiveIncomingStreamCount_in: [Int!]
  inactiveIncomingStreamCount_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  balance: BigInt
  balance_not: BigInt
  balance_gt: BigInt
  balance_lt: BigInt
  balance_gte: BigInt
  balance_lte: BigInt
  balance_in: [BigInt!]
  balance_not_in: [BigInt!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalNetFlowRate: BigInt
  totalNetFlowRate_not: BigInt
  totalNetFlowRate_gt: BigInt
  totalNetFlowRate_lt: BigInt
  totalNetFlowRate_gte: BigInt
  totalNetFlowRate_lte: BigInt
  totalNetFlowRate_in: [BigInt!]
  totalNetFlowRate_not_in: [BigInt!]
  totalInflowRate: BigInt
  totalInflowRate_not: BigInt
  totalInflowRate_gt: BigInt
  totalInflowRate_lt: BigInt
  totalInflowRate_gte: BigInt
  totalInflowRate_lte: BigInt
  totalInflowRate_in: [BigInt!]
  totalInflowRate_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamedIn: BigInt
  totalAmountStreamedIn_not: BigInt
  totalAmountStreamedIn_gt: BigInt
  totalAmountStreamedIn_lt: BigInt
  totalAmountStreamedIn_gte: BigInt
  totalAmountStreamedIn_lte: BigInt
  totalAmountStreamedIn_in: [BigInt!]
  totalAmountStreamedIn_not_in: [BigInt!]
  totalAmountStreamedOut: BigInt
  totalAmountStreamedOut_not: BigInt
  totalAmountStreamedOut_gt: BigInt
  totalAmountStreamedOut_lt: BigInt
  totalAmountStreamedOut_gte: BigInt
  totalAmountStreamedOut_lte: BigInt
  totalAmountStreamedOut_in: [BigInt!]
  totalAmountStreamedOut_not_in: [BigInt!]
  totalAmountStreamed: BigInt
  totalAmountStreamed_not: BigInt
  totalAmountStreamed_gt: BigInt
  totalAmountStreamed_lt: BigInt
  totalAmountStreamed_gte: BigInt
  totalAmountStreamed_lte: BigInt
  totalAmountStreamed_in: [BigInt!]
  totalAmountStreamed_not_in: [BigInt!]
  totalAmountTransferred: BigInt
  totalAmountTransferred_not: BigInt
  totalAmountTransferred_gt: BigInt
  totalAmountTransferred_lt: BigInt
  totalAmountTransferred_gte: BigInt
  totalAmountTransferred_lte: BigInt
  totalAmountTransferred_in: [BigInt!]
  totalAmountTransferred_not_in: [BigInt!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  accountTokenSnapshot: String
  accountTokenSnapshot_not: String
  accountTokenSnapshot_gt: String
  accountTokenSnapshot_lt: String
  accountTokenSnapshot_gte: String
  accountTokenSnapshot_lte: String
  accountTokenSnapshot_in: [String!]
  accountTokenSnapshot_not_in: [String!]
  accountTokenSnapshot_contains: String
  accountTokenSnapshot_contains_nocase: String
  accountTokenSnapshot_not_contains: String
  accountTokenSnapshot_not_contains_nocase: String
  accountTokenSnapshot_starts_with: String
  accountTokenSnapshot_starts_with_nocase: String
  accountTokenSnapshot_not_starts_with: String
  accountTokenSnapshot_not_starts_with_nocase: String
  accountTokenSnapshot_ends_with: String
  accountTokenSnapshot_ends_with_nocase: String
  accountTokenSnapshot_not_ends_with: String
  accountTokenSnapshot_not_ends_with_nocase: String
  accountTokenSnapshot_: AccountTokenSnapshot_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AccountTokenSnapshotLog_filter]
  or: [AccountTokenSnapshotLog_filter]
}

enum AccountTokenSnapshotLog_orderBy {
  id
  timestamp
  blockNumber
  transactionHash
  logIndex
  order
  triggeredByEventName
  maybeCriticalAtTimestamp
  totalNumberOfActiveStreams
  activeOutgoingStreamCount
  activeIncomingStreamCount
  totalNumberOfClosedStreams
  inactiveOutgoingStreamCount
  inactiveIncomingStreamCount
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  balance
  totalDeposit
  totalNetFlowRate
  totalInflowRate
  totalOutflowRate
  totalAmountStreamedIn
  totalAmountStreamedOut
  totalAmountStreamed
  totalAmountTransferred
  account
  account__id
  account__createdAtTimestamp
  account__createdAtBlockNumber
  account__updatedAtTimestamp
  account__updatedAtBlockNumber
  account__isSuperApp
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  accountTokenSnapshot
  accountTokenSnapshot__id
  accountTokenSnapshot__updatedAtTimestamp
  accountTokenSnapshot__updatedAtBlockNumber
  accountTokenSnapshot__isLiquidationEstimateOptimistic
  accountTokenSnapshot__maybeCriticalAtTimestamp
  accountTokenSnapshot__totalNumberOfActiveStreams
  accountTokenSnapshot__activeOutgoingStreamCount
  accountTokenSnapshot__activeIncomingStreamCount
  accountTokenSnapshot__totalNumberOfClosedStreams
  accountTokenSnapshot__inactiveOutgoingStreamCount
  accountTokenSnapshot__inactiveIncomingStreamCount
  accountTokenSnapshot__totalSubscriptionsWithUnits
  accountTokenSnapshot__totalApprovedSubscriptions
  accountTokenSnapshot__balanceUntilUpdatedAt
  accountTokenSnapshot__totalDeposit
  accountTokenSnapshot__totalNetFlowRate
  accountTokenSnapshot__totalInflowRate
  accountTokenSnapshot__totalOutflowRate
  accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt
  accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt
  accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt
  accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt
}

type AgreementClassRegisteredEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  agreementType: Bytes!
  code: Bytes!
}

input AgreementClassRegisteredEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  agreementType: Bytes
  agreementType_not: Bytes
  agreementType_gt: Bytes
  agreementType_lt: Bytes
  agreementType_gte: Bytes
  agreementType_lte: Bytes
  agreementType_in: [Bytes!]
  agreementType_not_in: [Bytes!]
  agreementType_contains: Bytes
  agreementType_not_contains: Bytes
  code: Bytes
  code_not: Bytes
  code_gt: Bytes
  code_lt: Bytes
  code_gte: Bytes
  code_lte: Bytes
  code_in: [Bytes!]
  code_not_in: [Bytes!]
  code_contains: Bytes
  code_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AgreementClassRegisteredEvent_filter]
  or: [AgreementClassRegisteredEvent_filter]
}

enum AgreementClassRegisteredEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  agreementType
  code
}

type AgreementClassUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  agreementType: Bytes!
  code: Bytes!
}

input AgreementClassUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  agreementType: Bytes
  agreementType_not: Bytes
  agreementType_gt: Bytes
  agreementType_lt: Bytes
  agreementType_gte: Bytes
  agreementType_lte: Bytes
  agreementType_in: [Bytes!]
  agreementType_not_in: [Bytes!]
  agreementType_contains: Bytes
  agreementType_not_contains: Bytes
  code: Bytes
  code_not: Bytes
  code_gt: Bytes
  code_lt: Bytes
  code_gte: Bytes
  code_lte: Bytes
  code_in: [Bytes!]
  code_not_in: [Bytes!]
  code_contains: Bytes
  code_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AgreementClassUpdatedEvent_filter]
  or: [AgreementClassUpdatedEvent_filter]
}

enum AgreementClassUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  agreementType
  code
}

"""
NOTE: This event was deprecated since the introduction of the 3Ps system.
Replaced by: `AgreementLiquidatedV2Event`
See: https://docs.superfluid.finance/superfluid/sentinels/liquidations-and-toga#patricians-plebs-and-pirates-3ps for more details on the 3Ps system.
See: https://github.com/superfluid-finance/protocol-monorepo/blob/dev/packages/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol#L425 for more details on the events.

"""
type AgreementLiquidatedByEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = liquidatorAccount (executor of liquidation)
  addresses[2] = penaltyAccount (the sender of the flow/stream)
  addresses[3] = bondAccount (the address receiving the reward - the reward account for the token, pre 3Ps)
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  liquidatorAccount: Bytes!
  agreementClass: Bytes!
  agreementId: Bytes!
  penaltyAccount: Bytes!
  bondAccount: Bytes!
  rewardAmount: BigInt!
  bailoutAmount: BigInt!

  """
  The full deposit amount of the stream that was liquidated.
  
  """
  deposit: BigInt!

  """
  The flow rate of the stream at the time of liquidation.
  
  """
  flowRateAtLiquidation: BigInt!
}

input AgreementLiquidatedByEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  liquidatorAccount: Bytes
  liquidatorAccount_not: Bytes
  liquidatorAccount_gt: Bytes
  liquidatorAccount_lt: Bytes
  liquidatorAccount_gte: Bytes
  liquidatorAccount_lte: Bytes
  liquidatorAccount_in: [Bytes!]
  liquidatorAccount_not_in: [Bytes!]
  liquidatorAccount_contains: Bytes
  liquidatorAccount_not_contains: Bytes
  agreementClass: Bytes
  agreementClass_not: Bytes
  agreementClass_gt: Bytes
  agreementClass_lt: Bytes
  agreementClass_gte: Bytes
  agreementClass_lte: Bytes
  agreementClass_in: [Bytes!]
  agreementClass_not_in: [Bytes!]
  agreementClass_contains: Bytes
  agreementClass_not_contains: Bytes
  agreementId: Bytes
  agreementId_not: Bytes
  agreementId_gt: Bytes
  agreementId_lt: Bytes
  agreementId_gte: Bytes
  agreementId_lte: Bytes
  agreementId_in: [Bytes!]
  agreementId_not_in: [Bytes!]
  agreementId_contains: Bytes
  agreementId_not_contains: Bytes
  penaltyAccount: Bytes
  penaltyAccount_not: Bytes
  penaltyAccount_gt: Bytes
  penaltyAccount_lt: Bytes
  penaltyAccount_gte: Bytes
  penaltyAccount_lte: Bytes
  penaltyAccount_in: [Bytes!]
  penaltyAccount_not_in: [Bytes!]
  penaltyAccount_contains: Bytes
  penaltyAccount_not_contains: Bytes
  bondAccount: Bytes
  bondAccount_not: Bytes
  bondAccount_gt: Bytes
  bondAccount_lt: Bytes
  bondAccount_gte: Bytes
  bondAccount_lte: Bytes
  bondAccount_in: [Bytes!]
  bondAccount_not_in: [Bytes!]
  bondAccount_contains: Bytes
  bondAccount_not_contains: Bytes
  rewardAmount: BigInt
  rewardAmount_not: BigInt
  rewardAmount_gt: BigInt
  rewardAmount_lt: BigInt
  rewardAmount_gte: BigInt
  rewardAmount_lte: BigInt
  rewardAmount_in: [BigInt!]
  rewardAmount_not_in: [BigInt!]
  bailoutAmount: BigInt
  bailoutAmount_not: BigInt
  bailoutAmount_gt: BigInt
  bailoutAmount_lt: BigInt
  bailoutAmount_gte: BigInt
  bailoutAmount_lte: BigInt
  bailoutAmount_in: [BigInt!]
  bailoutAmount_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  flowRateAtLiquidation: BigInt
  flowRateAtLiquidation_not: BigInt
  flowRateAtLiquidation_gt: BigInt
  flowRateAtLiquidation_lt: BigInt
  flowRateAtLiquidation_gte: BigInt
  flowRateAtLiquidation_lte: BigInt
  flowRateAtLiquidation_in: [BigInt!]
  flowRateAtLiquidation_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AgreementLiquidatedByEvent_filter]
  or: [AgreementLiquidatedByEvent_filter]
}

enum AgreementLiquidatedByEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  liquidatorAccount
  agreementClass
  agreementId
  penaltyAccount
  bondAccount
  rewardAmount
  bailoutAmount
  deposit
  flowRateAtLiquidation
}

type AgreementLiquidatedV2Event implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `liquidatorAccount` (executor of liquidation)
  addresses[2] = `targetAccount` (the sender of the flow/stream)
  addresses[3] = `rewardAmountReceiver` (the address receiving the reward) addresses
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  agreementClass: Bytes!
  agreementId: Bytes!
  liquidatorAccount: Bytes!
  targetAccount: Bytes!
  rewardAmountReceiver: Bytes!
  rewardAmount: BigInt!
  targetAccountBalanceDelta: BigInt!
  version: BigInt!
  liquidationType: Int!

  """
  The full deposit amount of the stream that was liquidated.
  
  """
  deposit: BigInt!

  """
  The flow rate of the stream at the time of liquidation.
  
  """
  flowRateAtLiquidation: BigInt!

  """
  TO BE DEPRECATED in v2 endpoint - use rewardAmountReceiver instead
  
  """
  rewardAccount: Bytes!
}

input AgreementLiquidatedV2Event_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  agreementClass: Bytes
  agreementClass_not: Bytes
  agreementClass_gt: Bytes
  agreementClass_lt: Bytes
  agreementClass_gte: Bytes
  agreementClass_lte: Bytes
  agreementClass_in: [Bytes!]
  agreementClass_not_in: [Bytes!]
  agreementClass_contains: Bytes
  agreementClass_not_contains: Bytes
  agreementId: Bytes
  agreementId_not: Bytes
  agreementId_gt: Bytes
  agreementId_lt: Bytes
  agreementId_gte: Bytes
  agreementId_lte: Bytes
  agreementId_in: [Bytes!]
  agreementId_not_in: [Bytes!]
  agreementId_contains: Bytes
  agreementId_not_contains: Bytes
  liquidatorAccount: Bytes
  liquidatorAccount_not: Bytes
  liquidatorAccount_gt: Bytes
  liquidatorAccount_lt: Bytes
  liquidatorAccount_gte: Bytes
  liquidatorAccount_lte: Bytes
  liquidatorAccount_in: [Bytes!]
  liquidatorAccount_not_in: [Bytes!]
  liquidatorAccount_contains: Bytes
  liquidatorAccount_not_contains: Bytes
  targetAccount: Bytes
  targetAccount_not: Bytes
  targetAccount_gt: Bytes
  targetAccount_lt: Bytes
  targetAccount_gte: Bytes
  targetAccount_lte: Bytes
  targetAccount_in: [Bytes!]
  targetAccount_not_in: [Bytes!]
  targetAccount_contains: Bytes
  targetAccount_not_contains: Bytes
  rewardAmountReceiver: Bytes
  rewardAmountReceiver_not: Bytes
  rewardAmountReceiver_gt: Bytes
  rewardAmountReceiver_lt: Bytes
  rewardAmountReceiver_gte: Bytes
  rewardAmountReceiver_lte: Bytes
  rewardAmountReceiver_in: [Bytes!]
  rewardAmountReceiver_not_in: [Bytes!]
  rewardAmountReceiver_contains: Bytes
  rewardAmountReceiver_not_contains: Bytes
  rewardAmount: BigInt
  rewardAmount_not: BigInt
  rewardAmount_gt: BigInt
  rewardAmount_lt: BigInt
  rewardAmount_gte: BigInt
  rewardAmount_lte: BigInt
  rewardAmount_in: [BigInt!]
  rewardAmount_not_in: [BigInt!]
  targetAccountBalanceDelta: BigInt
  targetAccountBalanceDelta_not: BigInt
  targetAccountBalanceDelta_gt: BigInt
  targetAccountBalanceDelta_lt: BigInt
  targetAccountBalanceDelta_gte: BigInt
  targetAccountBalanceDelta_lte: BigInt
  targetAccountBalanceDelta_in: [BigInt!]
  targetAccountBalanceDelta_not_in: [BigInt!]
  version: BigInt
  version_not: BigInt
  version_gt: BigInt
  version_lt: BigInt
  version_gte: BigInt
  version_lte: BigInt
  version_in: [BigInt!]
  version_not_in: [BigInt!]
  liquidationType: Int
  liquidationType_not: Int
  liquidationType_gt: Int
  liquidationType_lt: Int
  liquidationType_gte: Int
  liquidationType_lte: Int
  liquidationType_in: [Int!]
  liquidationType_not_in: [Int!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  flowRateAtLiquidation: BigInt
  flowRateAtLiquidation_not: BigInt
  flowRateAtLiquidation_gt: BigInt
  flowRateAtLiquidation_lt: BigInt
  flowRateAtLiquidation_gte: BigInt
  flowRateAtLiquidation_lte: BigInt
  flowRateAtLiquidation_in: [BigInt!]
  flowRateAtLiquidation_not_in: [BigInt!]
  rewardAccount: Bytes
  rewardAccount_not: Bytes
  rewardAccount_gt: Bytes
  rewardAccount_lt: Bytes
  rewardAccount_gte: Bytes
  rewardAccount_lte: Bytes
  rewardAccount_in: [Bytes!]
  rewardAccount_not_in: [Bytes!]
  rewardAccount_contains: Bytes
  rewardAccount_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AgreementLiquidatedV2Event_filter]
  or: [AgreementLiquidatedV2Event_filter]
}

enum AgreementLiquidatedV2Event_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  agreementClass
  agreementId
  liquidatorAccount
  targetAccount
  rewardAmountReceiver
  rewardAmount
  targetAccountBalanceDelta
  version
  liquidationType
  deposit
  flowRateAtLiquidation
  rewardAccount
}

type AppRegisteredEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  app: Bytes!
}

input AppRegisteredEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  app: Bytes
  app_not: Bytes
  app_gt: Bytes
  app_lt: Bytes
  app_gte: Bytes
  app_lte: Bytes
  app_in: [Bytes!]
  app_not_in: [Bytes!]
  app_contains: Bytes
  app_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AppRegisteredEvent_filter]
  or: [AppRegisteredEvent_filter]
}

enum AppRegisteredEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  app
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

type BondIncreasedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  The address of the `token` (supertoken).
  
  """
  token: Bytes!

  """
  The additional amount added to the bond by the current Patrician In Charge (PIC).
  
  """
  additionalBond: BigInt!
}

input BondIncreasedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  additionalBond: BigInt
  additionalBond_not: BigInt
  additionalBond_gt: BigInt
  additionalBond_lt: BigInt
  additionalBond_gte: BigInt
  additionalBond_lte: BigInt
  additionalBond_in: [BigInt!]
  additionalBond_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BondIncreasedEvent_filter]
  or: [BondIncreasedEvent_filter]
}

enum BondIncreasedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  additionalBond
}

type BurnedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `from`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  operator: Bytes!
  from: Bytes!
  token: Bytes!
  amount: BigInt!
  data: Bytes!
  operatorData: Bytes!
}

input BurnedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  operator: Bytes
  operator_not: Bytes
  operator_gt: Bytes
  operator_lt: Bytes
  operator_gte: Bytes
  operator_lte: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  data: Bytes
  data_not: Bytes
  data_gt: Bytes
  data_lt: Bytes
  data_gte: Bytes
  data_lte: Bytes
  data_in: [Bytes!]
  data_not_in: [Bytes!]
  data_contains: Bytes
  data_not_contains: Bytes
  operatorData: Bytes
  operatorData_not: Bytes
  operatorData_gt: Bytes
  operatorData_lt: Bytes
  operatorData_gte: Bytes
  operatorData_lte: Bytes
  operatorData_in: [Bytes!]
  operatorData_not_in: [Bytes!]
  operatorData_contains: Bytes
  operatorData_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BurnedEvent_filter]
  or: [BurnedEvent_filter]
}

enum BurnedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  operator
  from
  token
  amount
  data
  operatorData
}

scalar Bytes

type CFAv1LiquidationPeriodChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  order: BigInt!
  logIndex: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  liquidationPeriod: BigInt!
}

input CFAv1LiquidationPeriodChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_gt: Bytes
  governanceAddress_lt: Bytes
  governanceAddress_gte: Bytes
  governanceAddress_lte: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_gt: Bytes
  host_lt: Bytes
  host_gte: Bytes
  host_lte: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_gt: Bytes
  superToken_lt: Bytes
  superToken_gte: Bytes
  superToken_lte: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  liquidationPeriod: BigInt
  liquidationPeriod_not: BigInt
  liquidationPeriod_gt: BigInt
  liquidationPeriod_lt: BigInt
  liquidationPeriod_gte: BigInt
  liquidationPeriod_lte: BigInt
  liquidationPeriod_in: [BigInt!]
  liquidationPeriod_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CFAv1LiquidationPeriodChangedEvent_filter]
  or: [CFAv1LiquidationPeriodChangedEvent_filter]
}

enum CFAv1LiquidationPeriodChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  order
  logIndex
  host
  superToken
  isKeySet
  liquidationPeriod
}

type ConfigChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  key: Bytes!
  isKeySet: Boolean!
  value: BigInt!
}

input ConfigChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_gt: Bytes
  governanceAddress_lt: Bytes
  governanceAddress_gte: Bytes
  governanceAddress_lte: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_gt: Bytes
  host_lt: Bytes
  host_gte: Bytes
  host_lte: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_gt: Bytes
  superToken_lt: Bytes
  superToken_gte: Bytes
  superToken_lte: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  key: Bytes
  key_not: Bytes
  key_gt: Bytes
  key_lt: Bytes
  key_gte: Bytes
  key_lte: Bytes
  key_in: [Bytes!]
  key_not_in: [Bytes!]
  key_contains: Bytes
  key_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ConfigChangedEvent_filter]
  or: [ConfigChangedEvent_filter]
}

enum ConfigChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  key
  isKeySet
  value
}

type CustomSuperTokenCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
}

input CustomSuperTokenCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CustomSuperTokenCreatedEvent_filter]
  or: [CustomSuperTokenCreatedEvent_filter]
}

enum CustomSuperTokenCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
}

"""
Event: An interface which is shared by all event entities and contains basic transaction data.

"""
interface Event {
  """
  The id of the event entity.
  
  """
  id: ID!

  """
  The block number which the event was logged in.
  
  """
  blockNumber: BigInt!

  """
  The index of the event, e.g. first event emitted would have `logIndex` of 0.
  
  """
  logIndex: BigInt!

  """
  A number used internally to sort the order of transactions.
  The formula: `blockNumber * ORDER_MULTIPLIER + logIndex`
  where: ORDER_MULTIPLIER = 10000
  
  """
  order: BigInt!

  """
  The name of the event - is a 1-to-1 match with the name in our smart contracts.
  
  """
  name: String!

  """
  Contains the addresses for accounts that were "impacted" by the event.
  This typically involves accounts which experienced a state change as a result of the transaction which emitted this event.
  
  """
  addresses: [Bytes!]!

  """
  The block timestamp which the event was logged in.
  
  """
  timestamp: BigInt!

  """
  The transaction hash of the transaction that the event was logged in.
  
  """
  transactionHash: Bytes!

  """
  The gas price of the transaction that the event was logged in.
  
  """
  gasPrice: BigInt!

  """
  The gas used for this transaction.
  
  """
  gasUsed: BigInt!
}

input Event_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Event_filter]
  or: [Event_filter]
}

enum Event_orderBy {
  id
  blockNumber
  logIndex
  order
  name
  addresses
  timestamp
  transactionHash
  gasPrice
  gasUsed
}

type ExitRateChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  The address of the `token` (supertoken).
  
  """
  token: Bytes!

  """
  The flowrate at which the bond is streamed back to the Patrician In Charge.
  
  """
  exitRate: BigInt!
}

input ExitRateChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  exitRate: BigInt
  exitRate_not: BigInt
  exitRate_gt: BigInt
  exitRate_lt: BigInt
  exitRate_gte: BigInt
  exitRate_lte: BigInt
  exitRate_in: [BigInt!]
  exitRate_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ExitRateChangedEvent_filter]
  or: [ExitRateChangedEvent_filter]
}

enum ExitRateChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  exitRate
}

"""
FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`.

"""
type FlowOperator {
  """
  ID composed of: flowOperator-token-sender
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  The permissions granted to the `flowOperator`.
  Bitmask representation:
  Delete | Update | Create
  | D | U | C |
  | 0 | 0 | 0 |
  
  """
  permissions: Int!

  """
  The flow rate allowance granted to the `flowOperator` by the `sender`. This
  can be reset if the `sender` updates the `flowOperator` flow rate allowance.
  
  """
  flowRateAllowanceGranted: BigInt!

  """
  The remaining flow rate allowance the `flowOperator` has.
  This will go down every time when the `flowOperator` uses the allowance, that
  is, if they increase flowRate for `sender` or create a new flow on behalf of `sender`.
  It can only be reset if the `sender` updates the flow rate allowance.
  NOTE: this value will NOT go down if max flow rate allowance is set.
  
  """
  flowRateAllowanceRemaining: BigInt!

  """
  The transfer allowance granted to the `flowOperator` by the `sender`.
  
  """
  allowance: BigInt!
  flowOperator: Bytes!
  sender: Account!
  token: Token!
  accountTokenSnapshot: AccountTokenSnapshot!
  flowOperatorUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: FlowOperatorUpdatedEvent_orderBy, orderDirection: OrderDirection, where: FlowOperatorUpdatedEvent_filter): [FlowOperatorUpdatedEvent!]!
}

input FlowOperator_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  permissions: Int
  permissions_not: Int
  permissions_gt: Int
  permissions_lt: Int
  permissions_gte: Int
  permissions_lte: Int
  permissions_in: [Int!]
  permissions_not_in: [Int!]
  flowRateAllowanceGranted: BigInt
  flowRateAllowanceGranted_not: BigInt
  flowRateAllowanceGranted_gt: BigInt
  flowRateAllowanceGranted_lt: BigInt
  flowRateAllowanceGranted_gte: BigInt
  flowRateAllowanceGranted_lte: BigInt
  flowRateAllowanceGranted_in: [BigInt!]
  flowRateAllowanceGranted_not_in: [BigInt!]
  flowRateAllowanceRemaining: BigInt
  flowRateAllowanceRemaining_not: BigInt
  flowRateAllowanceRemaining_gt: BigInt
  flowRateAllowanceRemaining_lt: BigInt
  flowRateAllowanceRemaining_gte: BigInt
  flowRateAllowanceRemaining_lte: BigInt
  flowRateAllowanceRemaining_in: [BigInt!]
  flowRateAllowanceRemaining_not_in: [BigInt!]
  allowance: BigInt
  allowance_not: BigInt
  allowance_gt: BigInt
  allowance_lt: BigInt
  allowance_gte: BigInt
  allowance_lte: BigInt
  allowance_in: [BigInt!]
  allowance_not_in: [BigInt!]
  flowOperator: Bytes
  flowOperator_not: Bytes
  flowOperator_gt: Bytes
  flowOperator_lt: Bytes
  flowOperator_gte: Bytes
  flowOperator_lte: Bytes
  flowOperator_in: [Bytes!]
  flowOperator_not_in: [Bytes!]
  flowOperator_contains: Bytes
  flowOperator_not_contains: Bytes
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  accountTokenSnapshot: String
  accountTokenSnapshot_not: String
  accountTokenSnapshot_gt: String
  accountTokenSnapshot_lt: String
  accountTokenSnapshot_gte: String
  accountTokenSnapshot_lte: String
  accountTokenSnapshot_in: [String!]
  accountTokenSnapshot_not_in: [String!]
  accountTokenSnapshot_contains: String
  accountTokenSnapshot_contains_nocase: String
  accountTokenSnapshot_not_contains: String
  accountTokenSnapshot_not_contains_nocase: String
  accountTokenSnapshot_starts_with: String
  accountTokenSnapshot_starts_with_nocase: String
  accountTokenSnapshot_not_starts_with: String
  accountTokenSnapshot_not_starts_with_nocase: String
  accountTokenSnapshot_ends_with: String
  accountTokenSnapshot_ends_with_nocase: String
  accountTokenSnapshot_not_ends_with: String
  accountTokenSnapshot_not_ends_with_nocase: String
  accountTokenSnapshot_: AccountTokenSnapshot_filter
  flowOperatorUpdatedEvents_: FlowOperatorUpdatedEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FlowOperator_filter]
  or: [FlowOperator_filter]
}

enum FlowOperator_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  permissions
  flowRateAllowanceGranted
  flowRateAllowanceRemaining
  allowance
  flowOperator
  sender
  sender__id
  sender__createdAtTimestamp
  sender__createdAtBlockNumber
  sender__updatedAtTimestamp
  sender__updatedAtBlockNumber
  sender__isSuperApp
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  accountTokenSnapshot
  accountTokenSnapshot__id
  accountTokenSnapshot__updatedAtTimestamp
  accountTokenSnapshot__updatedAtBlockNumber
  accountTokenSnapshot__isLiquidationEstimateOptimistic
  accountTokenSnapshot__maybeCriticalAtTimestamp
  accountTokenSnapshot__totalNumberOfActiveStreams
  accountTokenSnapshot__activeOutgoingStreamCount
  accountTokenSnapshot__activeIncomingStreamCount
  accountTokenSnapshot__totalNumberOfClosedStreams
  accountTokenSnapshot__inactiveOutgoingStreamCount
  accountTokenSnapshot__inactiveIncomingStreamCount
  accountTokenSnapshot__totalSubscriptionsWithUnits
  accountTokenSnapshot__totalApprovedSubscriptions
  accountTokenSnapshot__balanceUntilUpdatedAt
  accountTokenSnapshot__totalDeposit
  accountTokenSnapshot__totalNetFlowRate
  accountTokenSnapshot__totalInflowRate
  accountTokenSnapshot__totalOutflowRate
  accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt
  accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt
  accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt
  accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt
  flowOperatorUpdatedEvents
}

type FlowOperatorUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = sender
  addresses[2] = `flowOperator`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  The address of the `token` being streamed.
  
  """
  token: Bytes!
  sender: Bytes!

  """
  The permissions granted to the `flowOperator`.
  Octo bitmask representation.
  
  """
  permissions: Int!
  flowRateAllowance: BigInt!
  flowOperator: FlowOperator!
}

input FlowOperatorUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  permissions: Int
  permissions_not: Int
  permissions_gt: Int
  permissions_lt: Int
  permissions_gte: Int
  permissions_lte: Int
  permissions_in: [Int!]
  permissions_not_in: [Int!]
  flowRateAllowance: BigInt
  flowRateAllowance_not: BigInt
  flowRateAllowance_gt: BigInt
  flowRateAllowance_lt: BigInt
  flowRateAllowance_gte: BigInt
  flowRateAllowance_lte: BigInt
  flowRateAllowance_in: [BigInt!]
  flowRateAllowance_not_in: [BigInt!]
  flowOperator: String
  flowOperator_not: String
  flowOperator_gt: String
  flowOperator_lt: String
  flowOperator_gte: String
  flowOperator_lte: String
  flowOperator_in: [String!]
  flowOperator_not_in: [String!]
  flowOperator_contains: String
  flowOperator_contains_nocase: String
  flowOperator_not_contains: String
  flowOperator_not_contains_nocase: String
  flowOperator_starts_with: String
  flowOperator_starts_with_nocase: String
  flowOperator_not_starts_with: String
  flowOperator_not_starts_with_nocase: String
  flowOperator_ends_with: String
  flowOperator_ends_with_nocase: String
  flowOperator_not_ends_with: String
  flowOperator_not_ends_with_nocase: String
  flowOperator_: FlowOperator_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FlowOperatorUpdatedEvent_filter]
  or: [FlowOperatorUpdatedEvent_filter]
}

enum FlowOperatorUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  sender
  permissions
  flowRateAllowance
  flowOperator
  flowOperator__id
  flowOperator__createdAtTimestamp
  flowOperator__createdAtBlockNumber
  flowOperator__updatedAtTimestamp
  flowOperator__updatedAtBlockNumber
  flowOperator__permissions
  flowOperator__flowRateAllowanceGranted
  flowOperator__flowRateAllowanceRemaining
  flowOperator__allowance
  flowOperator__flowOperator
}

"""
FlowUpdated: An `Event` entity that is emitted
when a flow is created, updated, or deleted.

"""
type FlowUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (supertoken)
  addresses[1] = `sender`
  addresses[2] = `receiver`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  The address of the `token` (supertoken) being streamed.
  
  """
  token: Bytes!

  """
  The address of the flow sender.
  
  """
  sender: Bytes!

  """
  The address of the flow receiver.
  
  """
  receiver: Bytes!

  """
  The address that is executing the flow update transaction.
  This will be the zero address until the flowOperator feature is live.
  
  """
  flowOperator: Bytes!

  """
  The flow rate per second.
  
  """
  flowRate: BigInt!

  """
  The total (global/account level) flow rate of `sender` for `token` as of this event.
  
  """
  totalSenderFlowRate: BigInt!

  """
  The total (global/account level) flow rate of `receiver` for `token` as of this event.
  
  """
  totalReceiverFlowRate: BigInt!

  """
  The deposit amount put up for the creation of the flow.
  
  """
  deposit: BigInt!

  """
  Arbitrary bytes (additional data) passed upon flow creation.
  
  """
  userData: Bytes!

  """
  The previous flow rate, the absolute (positive) value.
  
  """
  oldFlowRate: BigInt!

  """
  The "type" of the `FlowUpdated` event.
  0 = create
  1 = update
  2 = terminate
  
  """
  type: Int!

  """
  The total amount streamed until the timestamp
  for the Stream entity linked to this event.
  
  """
  totalAmountStreamedUntilTimestamp: BigInt!

  """
  The stream entity which is being modified.
  
  """
  stream: Stream!
}

input FlowUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes
  receiver: Bytes
  receiver_not: Bytes
  receiver_gt: Bytes
  receiver_lt: Bytes
  receiver_gte: Bytes
  receiver_lte: Bytes
  receiver_in: [Bytes!]
  receiver_not_in: [Bytes!]
  receiver_contains: Bytes
  receiver_not_contains: Bytes
  flowOperator: Bytes
  flowOperator_not: Bytes
  flowOperator_gt: Bytes
  flowOperator_lt: Bytes
  flowOperator_gte: Bytes
  flowOperator_lte: Bytes
  flowOperator_in: [Bytes!]
  flowOperator_not_in: [Bytes!]
  flowOperator_contains: Bytes
  flowOperator_not_contains: Bytes
  flowRate: BigInt
  flowRate_not: BigInt
  flowRate_gt: BigInt
  flowRate_lt: BigInt
  flowRate_gte: BigInt
  flowRate_lte: BigInt
  flowRate_in: [BigInt!]
  flowRate_not_in: [BigInt!]
  totalSenderFlowRate: BigInt
  totalSenderFlowRate_not: BigInt
  totalSenderFlowRate_gt: BigInt
  totalSenderFlowRate_lt: BigInt
  totalSenderFlowRate_gte: BigInt
  totalSenderFlowRate_lte: BigInt
  totalSenderFlowRate_in: [BigInt!]
  totalSenderFlowRate_not_in: [BigInt!]
  totalReceiverFlowRate: BigInt
  totalReceiverFlowRate_not: BigInt
  totalReceiverFlowRate_gt: BigInt
  totalReceiverFlowRate_lt: BigInt
  totalReceiverFlowRate_gte: BigInt
  totalReceiverFlowRate_lte: BigInt
  totalReceiverFlowRate_in: [BigInt!]
  totalReceiverFlowRate_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  oldFlowRate: BigInt
  oldFlowRate_not: BigInt
  oldFlowRate_gt: BigInt
  oldFlowRate_lt: BigInt
  oldFlowRate_gte: BigInt
  oldFlowRate_lte: BigInt
  oldFlowRate_in: [BigInt!]
  oldFlowRate_not_in: [BigInt!]
  type: Int
  type_not: Int
  type_gt: Int
  type_lt: Int
  type_gte: Int
  type_lte: Int
  type_in: [Int!]
  type_not_in: [Int!]
  totalAmountStreamedUntilTimestamp: BigInt
  totalAmountStreamedUntilTimestamp_not: BigInt
  totalAmountStreamedUntilTimestamp_gt: BigInt
  totalAmountStreamedUntilTimestamp_lt: BigInt
  totalAmountStreamedUntilTimestamp_gte: BigInt
  totalAmountStreamedUntilTimestamp_lte: BigInt
  totalAmountStreamedUntilTimestamp_in: [BigInt!]
  totalAmountStreamedUntilTimestamp_not_in: [BigInt!]
  stream: String
  stream_not: String
  stream_gt: String
  stream_lt: String
  stream_gte: String
  stream_lte: String
  stream_in: [String!]
  stream_not_in: [String!]
  stream_contains: String
  stream_contains_nocase: String
  stream_not_contains: String
  stream_not_contains_nocase: String
  stream_starts_with: String
  stream_starts_with_nocase: String
  stream_not_starts_with: String
  stream_not_starts_with_nocase: String
  stream_ends_with: String
  stream_ends_with_nocase: String
  stream_not_ends_with: String
  stream_not_ends_with_nocase: String
  stream_: Stream_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [FlowUpdatedEvent_filter]
  or: [FlowUpdatedEvent_filter]
}

enum FlowUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  sender
  receiver
  flowOperator
  flowRate
  totalSenderFlowRate
  totalReceiverFlowRate
  deposit
  userData
  oldFlowRate
  type
  totalAmountStreamedUntilTimestamp
  stream
  stream__id
  stream__createdAtTimestamp
  stream__createdAtBlockNumber
  stream__updatedAtTimestamp
  stream__updatedAtBlockNumber
  stream__currentFlowRate
  stream__deposit
  stream__streamedUntilUpdatedAt
  stream__userData
}

type GovernanceReplacedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  oldGovernance: Bytes!
  newGovernance: Bytes!
}

input GovernanceReplacedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  oldGovernance: Bytes
  oldGovernance_not: Bytes
  oldGovernance_gt: Bytes
  oldGovernance_lt: Bytes
  oldGovernance_gte: Bytes
  oldGovernance_lte: Bytes
  oldGovernance_in: [Bytes!]
  oldGovernance_not_in: [Bytes!]
  oldGovernance_contains: Bytes
  oldGovernance_not_contains: Bytes
  newGovernance: Bytes
  newGovernance_not: Bytes
  newGovernance_gt: Bytes
  newGovernance_lt: Bytes
  newGovernance_gte: Bytes
  newGovernance_lte: Bytes
  newGovernance_in: [Bytes!]
  newGovernance_not_in: [Bytes!]
  newGovernance_contains: Bytes
  newGovernance_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [GovernanceReplacedEvent_filter]
  or: [GovernanceReplacedEvent_filter]
}

enum GovernanceReplacedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  blockNumber
  logIndex
  order
  addresses
  oldGovernance
  newGovernance
}

"""
Index: An Index higher order entity.

"""
type Index {
  """
  ID composed of: publisherAddress-tokenAddress-indexId
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  NOTE: indexId is not the same as the id of the `Index` entity.
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!
  indexValue: BigInt!

  """
  The number of subscriptions which have units allocated to them on the `Index`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  The number of units allocated by the `Index` that are pending.
  This refers to the current (as of updatedAt) `totalUnitsPending`-not all that has ever been pending.
  
  """
  totalUnitsPending: BigInt!

  """
  The number of units allocated by the `Index` that are approved.
  This refers to the current (as of updatedAt) `totalUnitsApproved`-not all that has ever been approved.
  
  """
  totalUnitsApproved: BigInt!

  """
  The sum of `totalUnitsPending` and `totalUnitsApproved`.
  
  """
  totalUnits: BigInt!

  """
  The total amount distributed from this `Index`.
  
  """
  totalAmountDistributedUntilUpdatedAt: BigInt!
  token: Token!
  publisher: Account!

  """
  The subscriptions of the index, it will include approved, unapproved
  and deleted subscriptions.
  
  """
  subscriptions(skip: Int = 0, first: Int = 100, orderBy: IndexSubscription_orderBy, orderDirection: OrderDirection, where: IndexSubscription_filter): [IndexSubscription!]!

  """
  IndexCreated event, there will only be one.
  
  """
  indexCreatedEvent: IndexCreatedEvent!
  indexDistributionClaimedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexDistributionClaimedEvent_orderBy, orderDirection: OrderDirection, where: IndexDistributionClaimedEvent_filter): [IndexDistributionClaimedEvent!]!
  indexUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexUpdatedEvent_orderBy, orderDirection: OrderDirection, where: IndexUpdatedEvent_filter): [IndexUpdatedEvent!]!
  indexSubscribedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexSubscribedEvent_orderBy, orderDirection: OrderDirection, where: IndexSubscribedEvent_filter): [IndexSubscribedEvent!]!
  indexUnitsUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexUnitsUpdatedEvent_orderBy, orderDirection: OrderDirection, where: IndexUnitsUpdatedEvent_filter): [IndexUnitsUpdatedEvent!]!
  indexUnsubscribedEvents(skip: Int = 0, first: Int = 100, orderBy: IndexUnsubscribedEvent_orderBy, orderDirection: OrderDirection, where: IndexUnsubscribedEvent_filter): [IndexUnsubscribedEvent!]!
}

input Index_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  indexValue: BigInt
  indexValue_not: BigInt
  indexValue_gt: BigInt
  indexValue_lt: BigInt
  indexValue_gte: BigInt
  indexValue_lte: BigInt
  indexValue_in: [BigInt!]
  indexValue_not_in: [BigInt!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalUnitsPending: BigInt
  totalUnitsPending_not: BigInt
  totalUnitsPending_gt: BigInt
  totalUnitsPending_lt: BigInt
  totalUnitsPending_gte: BigInt
  totalUnitsPending_lte: BigInt
  totalUnitsPending_in: [BigInt!]
  totalUnitsPending_not_in: [BigInt!]
  totalUnitsApproved: BigInt
  totalUnitsApproved_not: BigInt
  totalUnitsApproved_gt: BigInt
  totalUnitsApproved_lt: BigInt
  totalUnitsApproved_gte: BigInt
  totalUnitsApproved_lte: BigInt
  totalUnitsApproved_in: [BigInt!]
  totalUnitsApproved_not_in: [BigInt!]
  totalUnits: BigInt
  totalUnits_not: BigInt
  totalUnits_gt: BigInt
  totalUnits_lt: BigInt
  totalUnits_gte: BigInt
  totalUnits_lte: BigInt
  totalUnits_in: [BigInt!]
  totalUnits_not_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt: BigInt
  totalAmountDistributedUntilUpdatedAt_not: BigInt
  totalAmountDistributedUntilUpdatedAt_gt: BigInt
  totalAmountDistributedUntilUpdatedAt_lt: BigInt
  totalAmountDistributedUntilUpdatedAt_gte: BigInt
  totalAmountDistributedUntilUpdatedAt_lte: BigInt
  totalAmountDistributedUntilUpdatedAt_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  publisher: String
  publisher_not: String
  publisher_gt: String
  publisher_lt: String
  publisher_gte: String
  publisher_lte: String
  publisher_in: [String!]
  publisher_not_in: [String!]
  publisher_contains: String
  publisher_contains_nocase: String
  publisher_not_contains: String
  publisher_not_contains_nocase: String
  publisher_starts_with: String
  publisher_starts_with_nocase: String
  publisher_not_starts_with: String
  publisher_not_starts_with_nocase: String
  publisher_ends_with: String
  publisher_ends_with_nocase: String
  publisher_not_ends_with: String
  publisher_not_ends_with_nocase: String
  publisher_: Account_filter
  subscriptions_: IndexSubscription_filter
  indexCreatedEvent: String
  indexCreatedEvent_not: String
  indexCreatedEvent_gt: String
  indexCreatedEvent_lt: String
  indexCreatedEvent_gte: String
  indexCreatedEvent_lte: String
  indexCreatedEvent_in: [String!]
  indexCreatedEvent_not_in: [String!]
  indexCreatedEvent_contains: String
  indexCreatedEvent_contains_nocase: String
  indexCreatedEvent_not_contains: String
  indexCreatedEvent_not_contains_nocase: String
  indexCreatedEvent_starts_with: String
  indexCreatedEvent_starts_with_nocase: String
  indexCreatedEvent_not_starts_with: String
  indexCreatedEvent_not_starts_with_nocase: String
  indexCreatedEvent_ends_with: String
  indexCreatedEvent_ends_with_nocase: String
  indexCreatedEvent_not_ends_with: String
  indexCreatedEvent_not_ends_with_nocase: String
  indexCreatedEvent_: IndexCreatedEvent_filter
  indexDistributionClaimedEvents_: IndexDistributionClaimedEvent_filter
  indexUpdatedEvents_: IndexUpdatedEvent_filter
  indexSubscribedEvents_: IndexSubscribedEvent_filter
  indexUnitsUpdatedEvents_: IndexUnitsUpdatedEvent_filter
  indexUnsubscribedEvents_: IndexUnsubscribedEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Index_filter]
  or: [Index_filter]
}

enum Index_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  indexId
  indexValue
  totalSubscriptionsWithUnits
  totalUnitsPending
  totalUnitsApproved
  totalUnits
  totalAmountDistributedUntilUpdatedAt
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  publisher
  publisher__id
  publisher__createdAtTimestamp
  publisher__createdAtBlockNumber
  publisher__updatedAtTimestamp
  publisher__updatedAtBlockNumber
  publisher__isSuperApp
  subscriptions
  indexCreatedEvent
  indexCreatedEvent__id
  indexCreatedEvent__transactionHash
  indexCreatedEvent__gasPrice
  indexCreatedEvent__gasUsed
  indexCreatedEvent__timestamp
  indexCreatedEvent__name
  indexCreatedEvent__blockNumber
  indexCreatedEvent__logIndex
  indexCreatedEvent__order
  indexCreatedEvent__token
  indexCreatedEvent__publisher
  indexCreatedEvent__indexId
  indexCreatedEvent__userData
  indexDistributionClaimedEvents
  indexUpdatedEvents
  indexSubscribedEvents
  indexUnitsUpdatedEvents
  indexUnsubscribedEvents
}

type IndexCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!
  userData: Bytes!
  index: Index!
}

input IndexCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [IndexCreatedEvent_filter]
  or: [IndexCreatedEvent_filter]
}

enum IndexCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  userData
  index
  index__id
  index__createdAtTimestamp
  index__createdAtBlockNumber
  index__updatedAtTimestamp
  index__updatedAtBlockNumber
  index__indexId
  index__indexValue
  index__totalSubscriptionsWithUnits
  index__totalUnitsPending
  index__totalUnitsApproved
  index__totalUnits
  index__totalAmountDistributedUntilUpdatedAt
}

type IndexDistributionClaimedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!
  amount: BigInt!
  index: Index!
}

input IndexDistributionClaimedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [IndexDistributionClaimedEvent_filter]
  or: [IndexDistributionClaimedEvent_filter]
}

enum IndexDistributionClaimedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  amount
  index
  index__id
  index__createdAtTimestamp
  index__createdAtBlockNumber
  index__updatedAtTimestamp
  index__updatedAtBlockNumber
  index__indexId
  index__indexValue
  index__totalSubscriptionsWithUnits
  index__totalUnitsPending
  index__totalUnitsApproved
  index__totalUnits
  index__totalAmountDistributedUntilUpdatedAt
}

type IndexSubscribedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!
  userData: Bytes!
  index: Index!
}

input IndexSubscribedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [IndexSubscribedEvent_filter]
  or: [IndexSubscribedEvent_filter]
}

enum IndexSubscribedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  userData
  index
  index__id
  index__createdAtTimestamp
  index__createdAtBlockNumber
  index__updatedAtTimestamp
  index__updatedAtBlockNumber
  index__indexId
  index__indexValue
  index__totalSubscriptionsWithUnits
  index__totalUnitsPending
  index__totalUnitsApproved
  index__totalUnits
  index__totalAmountDistributedUntilUpdatedAt
}

"""
IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.

"""
type IndexSubscription {
  """
  ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
  subscriber: Account!

  """
  A boolean indicating whether the `IndexSubscription` is approved.
  Approved subscriptions don't require `subscriber` to claim tokens that are distributed from the publisher.
  
  """
  approved: Boolean!

  """
  If `units` is `0`, it indicates that the subscription is "deleted" and `subscriber` is no longer subscribed to `index`.
  
  """
  units: BigInt!

  """
  The total amount of tokens you've received via IDA until
  `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountReceivedUntilUpdatedAt: BigInt!

  """
  The previous index value - used to calculate
  `totalAmountReceivedUntilUpdatedAt` field as of the
  `index.updatedAtTimestamp`.
  The formula to get this value is:
  `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue -
  indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
  
  """
  indexValueUntilUpdatedAt: BigInt!
  index: Index!

  """
  IndexSubscription approved events on the subscription.
  
  """
  subscriptionApprovedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionApprovedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionApprovedEvent_filter): [SubscriptionApprovedEvent!]!
  subscriptionDistributionClaimedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionDistributionClaimedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionDistributionClaimedEvent_filter): [SubscriptionDistributionClaimedEvent!]!
  subscriptionRevokedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionRevokedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionRevokedEvent_filter): [SubscriptionRevokedEvent!]!
  subscriptionUnitsUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: SubscriptionUnitsUpdatedEvent_orderBy, orderDirection: OrderDirection, where: SubscriptionUnitsUpdatedEvent_filter): [SubscriptionUnitsUpdatedEvent!]!
}

input IndexSubscription_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  subscriber: String
  subscriber_not: String
  subscriber_gt: String
  subscriber_lt: String
  subscriber_gte: String
  subscriber_lte: String
  subscriber_in: [String!]
  subscriber_not_in: [String!]
  subscriber_contains: String
  subscriber_contains_nocase: String
  subscriber_not_contains: String
  subscriber_not_contains_nocase: String
  subscriber_starts_with: String
  subscriber_starts_with_nocase: String
  subscriber_not_starts_with: String
  subscriber_not_starts_with_nocase: String
  subscriber_ends_with: String
  subscriber_ends_with_nocase: String
  subscriber_not_ends_with: String
  subscriber_not_ends_with_nocase: String
  subscriber_: Account_filter
  approved: Boolean
  approved_not: Boolean
  approved_in: [Boolean!]
  approved_not_in: [Boolean!]
  units: BigInt
  units_not: BigInt
  units_gt: BigInt
  units_lt: BigInt
  units_gte: BigInt
  units_lte: BigInt
  units_in: [BigInt!]
  units_not_in: [BigInt!]
  totalAmountReceivedUntilUpdatedAt: BigInt
  totalAmountReceivedUntilUpdatedAt_not: BigInt
  totalAmountReceivedUntilUpdatedAt_gt: BigInt
  totalAmountReceivedUntilUpdatedAt_lt: BigInt
  totalAmountReceivedUntilUpdatedAt_gte: BigInt
  totalAmountReceivedUntilUpdatedAt_lte: BigInt
  totalAmountReceivedUntilUpdatedAt_in: [BigInt!]
  totalAmountReceivedUntilUpdatedAt_not_in: [BigInt!]
  indexValueUntilUpdatedAt: BigInt
  indexValueUntilUpdatedAt_not: BigInt
  indexValueUntilUpdatedAt_gt: BigInt
  indexValueUntilUpdatedAt_lt: BigInt
  indexValueUntilUpdatedAt_gte: BigInt
  indexValueUntilUpdatedAt_lte: BigInt
  indexValueUntilUpdatedAt_in: [BigInt!]
  indexValueUntilUpdatedAt_not_in: [BigInt!]
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter
  subscriptionApprovedEvents_: SubscriptionApprovedEvent_filter
  subscriptionDistributionClaimedEvents_: SubscriptionDistributionClaimedEvent_filter
  subscriptionRevokedEvents_: SubscriptionRevokedEvent_filter
  subscriptionUnitsUpdatedEvents_: SubscriptionUnitsUpdatedEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [IndexSubscription_filter]
  or: [IndexSubscription_filter]
}

enum IndexSubscription_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  subscriber
  subscriber__id
  subscriber__createdAtTimestamp
  subscriber__createdAtBlockNumber
  subscriber__updatedAtTimestamp
  subscriber__updatedAtBlockNumber
  subscriber__isSuperApp
  approved
  units
  totalAmountReceivedUntilUpdatedAt
  indexValueUntilUpdatedAt
  index
  index__id
  index__createdAtTimestamp
  index__createdAtBlockNumber
  index__updatedAtTimestamp
  index__updatedAtBlockNumber
  index__indexId
  index__indexValue
  index__totalSubscriptionsWithUnits
  index__totalUnitsPending
  index__totalUnitsApproved
  index__totalUnits
  index__totalAmountDistributedUntilUpdatedAt
  subscriptionApprovedEvents
  subscriptionDistributionClaimedEvents
  subscriptionRevokedEvents
  subscriptionUnitsUpdatedEvents
}

type IndexUnitsUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!
  units: BigInt!
  userData: Bytes!
  oldUnits: BigInt!
  index: Index!
}

input IndexUnitsUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  units: BigInt
  units_not: BigInt
  units_gt: BigInt
  units_lt: BigInt
  units_gte: BigInt
  units_lte: BigInt
  units_in: [BigInt!]
  units_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  oldUnits: BigInt
  oldUnits_not: BigInt
  oldUnits_gt: BigInt
  oldUnits_lt: BigInt
  oldUnits_gte: BigInt
  oldUnits_lte: BigInt
  oldUnits_in: [BigInt!]
  oldUnits_not_in: [BigInt!]
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [IndexUnitsUpdatedEvent_filter]
  or: [IndexUnitsUpdatedEvent_filter]
}

enum IndexUnitsUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  units
  userData
  oldUnits
  index
  index__id
  index__createdAtTimestamp
  index__createdAtBlockNumber
  index__updatedAtTimestamp
  index__updatedAtBlockNumber
  index__indexId
  index__indexValue
  index__totalSubscriptionsWithUnits
  index__totalUnitsPending
  index__totalUnitsApproved
  index__totalUnits
  index__totalAmountDistributedUntilUpdatedAt
}

type IndexUnsubscribedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!
  userData: Bytes!
  index: Index!
}

input IndexUnsubscribedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [IndexUnsubscribedEvent_filter]
  or: [IndexUnsubscribedEvent_filter]
}

enum IndexUnsubscribedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  subscriber
  userData
  index
  index__id
  index__createdAtTimestamp
  index__createdAtBlockNumber
  index__updatedAtTimestamp
  index__updatedAtBlockNumber
  index__indexId
  index__indexValue
  index__totalSubscriptionsWithUnits
  index__totalUnitsPending
  index__totalUnitsApproved
  index__totalUnits
  index__totalAmountDistributedUntilUpdatedAt
}

type IndexUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!
  oldIndexValue: BigInt!
  newIndexValue: BigInt!
  totalUnitsPending: BigInt!
  totalUnitsApproved: BigInt!
  userData: Bytes!
  index: Index!
}

input IndexUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  oldIndexValue: BigInt
  oldIndexValue_not: BigInt
  oldIndexValue_gt: BigInt
  oldIndexValue_lt: BigInt
  oldIndexValue_gte: BigInt
  oldIndexValue_lte: BigInt
  oldIndexValue_in: [BigInt!]
  oldIndexValue_not_in: [BigInt!]
  newIndexValue: BigInt
  newIndexValue_not: BigInt
  newIndexValue_gt: BigInt
  newIndexValue_lt: BigInt
  newIndexValue_gte: BigInt
  newIndexValue_lte: BigInt
  newIndexValue_in: [BigInt!]
  newIndexValue_not_in: [BigInt!]
  totalUnitsPending: BigInt
  totalUnitsPending_not: BigInt
  totalUnitsPending_gt: BigInt
  totalUnitsPending_lt: BigInt
  totalUnitsPending_gte: BigInt
  totalUnitsPending_lte: BigInt
  totalUnitsPending_in: [BigInt!]
  totalUnitsPending_not_in: [BigInt!]
  totalUnitsApproved: BigInt
  totalUnitsApproved_not: BigInt
  totalUnitsApproved_gt: BigInt
  totalUnitsApproved_lt: BigInt
  totalUnitsApproved_gte: BigInt
  totalUnitsApproved_lte: BigInt
  totalUnitsApproved_in: [BigInt!]
  totalUnitsApproved_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  index: String
  index_not: String
  index_gt: String
  index_lt: String
  index_gte: String
  index_lte: String
  index_in: [String!]
  index_not_in: [String!]
  index_contains: String
  index_contains_nocase: String
  index_not_contains: String
  index_not_contains_nocase: String
  index_starts_with: String
  index_starts_with_nocase: String
  index_not_starts_with: String
  index_not_starts_with_nocase: String
  index_ends_with: String
  index_ends_with_nocase: String
  index_not_ends_with: String
  index_not_ends_with_nocase: String
  index_: Index_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [IndexUpdatedEvent_filter]
  or: [IndexUpdatedEvent_filter]
}

enum IndexUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  publisher
  indexId
  oldIndexValue
  newIndexValue
  totalUnitsPending
  totalUnitsApproved
  userData
  index
  index__id
  index__createdAtTimestamp
  index__createdAtBlockNumber
  index__updatedAtTimestamp
  index__updatedAtBlockNumber
  index__indexId
  index__indexValue
  index__totalSubscriptionsWithUnits
  index__totalUnitsPending
  index__totalUnitsApproved
  index__totalUnits
  index__totalAmountDistributedUntilUpdatedAt
}

type JailEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  app: Bytes!
  reason: BigInt!
}

input JailEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  app: Bytes
  app_not: Bytes
  app_gt: Bytes
  app_lt: Bytes
  app_gte: Bytes
  app_lte: Bytes
  app_in: [Bytes!]
  app_not_in: [Bytes!]
  app_contains: Bytes
  app_not_contains: Bytes
  reason: BigInt
  reason_not: BigInt
  reason_gt: BigInt
  reason_lt: BigInt
  reason_gte: BigInt
  reason_lte: BigInt
  reason_in: [BigInt!]
  reason_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [JailEvent_filter]
  or: [JailEvent_filter]
}

enum JailEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  app
  reason
}

type MintedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `operator`
  addresses[2] = `to`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  operator: Bytes!
  to: Bytes!
  amount: BigInt!
  data: Bytes!
  token: Bytes!
  operatorData: Bytes!
}

input MintedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  operator: Bytes
  operator_not: Bytes
  operator_gt: Bytes
  operator_lt: Bytes
  operator_gte: Bytes
  operator_lte: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  data: Bytes
  data_not: Bytes
  data_gt: Bytes
  data_lt: Bytes
  data_gte: Bytes
  data_lte: Bytes
  data_in: [Bytes!]
  data_not_in: [Bytes!]
  data_contains: Bytes
  data_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  operatorData: Bytes
  operatorData_not: Bytes
  operatorData_gt: Bytes
  operatorData_lt: Bytes
  operatorData_gte: Bytes
  operatorData_lte: Bytes
  operatorData_in: [Bytes!]
  operatorData_not_in: [Bytes!]
  operatorData_contains: Bytes
  operatorData_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MintedEvent_filter]
  or: [MintedEvent_filter]
}

enum MintedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  operator
  to
  amount
  data
  token
  operatorData
}

type NewPICEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `pic` (new Patrician In Charge)
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  The address of the `token` (supertoken) the PIC is posting a bond for.
  
  """
  token: Bytes!

  """
  The address of the new Patrician In Charge (PIC).
  
  """
  pic: Bytes!

  """
  The bond the new PIC staked in order to claim the position.
  
  """
  bond: BigInt!

  """
  The flowrate at which the bond is streamed back to the PIC.
  
  """
  exitRate: BigInt!
}

input NewPICEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  pic: Bytes
  pic_not: Bytes
  pic_gt: Bytes
  pic_lt: Bytes
  pic_gte: Bytes
  pic_lte: Bytes
  pic_in: [Bytes!]
  pic_not_in: [Bytes!]
  pic_contains: Bytes
  pic_not_contains: Bytes
  bond: BigInt
  bond_not: BigInt
  bond_gt: BigInt
  bond_lt: BigInt
  bond_gte: BigInt
  bond_lte: BigInt
  bond_in: [BigInt!]
  bond_not_in: [BigInt!]
  exitRate: BigInt
  exitRate_not: BigInt
  exitRate_gt: BigInt
  exitRate_lt: BigInt
  exitRate_gte: BigInt
  exitRate_lte: BigInt
  exitRate_in: [BigInt!]
  exitRate_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [NewPICEvent_filter]
  or: [NewPICEvent_filter]
}

enum NewPICEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  pic
  bond
  exitRate
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PPPConfigurationChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  liquidationPeriod: BigInt!
  patricianPeriod: BigInt!
}

input PPPConfigurationChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_gt: Bytes
  governanceAddress_lt: Bytes
  governanceAddress_gte: Bytes
  governanceAddress_lte: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_gt: Bytes
  host_lt: Bytes
  host_gte: Bytes
  host_lte: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_gt: Bytes
  superToken_lt: Bytes
  superToken_gte: Bytes
  superToken_lte: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  liquidationPeriod: BigInt
  liquidationPeriod_not: BigInt
  liquidationPeriod_gt: BigInt
  liquidationPeriod_lt: BigInt
  liquidationPeriod_gte: BigInt
  liquidationPeriod_lte: BigInt
  liquidationPeriod_in: [BigInt!]
  liquidationPeriod_not_in: [BigInt!]
  patricianPeriod: BigInt
  patricianPeriod_not: BigInt
  patricianPeriod_gt: BigInt
  patricianPeriod_lt: BigInt
  patricianPeriod_gte: BigInt
  patricianPeriod_lte: BigInt
  patricianPeriod_in: [BigInt!]
  patricianPeriod_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PPPConfigurationChangedEvent_filter]
  or: [PPPConfigurationChangedEvent_filter]
}

enum PPPConfigurationChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  isKeySet
  liquidationPeriod
  patricianPeriod
}

type Query {
  flowUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowUpdatedEvent
  flowUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowUpdatedEvent!]!
  flowOperatorUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperatorUpdatedEvent
  flowOperatorUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperatorUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowOperatorUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperatorUpdatedEvent!]!
  indexCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexCreatedEvent
  indexCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexCreatedEvent!]!
  indexDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexDistributionClaimedEvent
  indexDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexDistributionClaimedEvent!]!
  indexUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUpdatedEvent
  indexUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUpdatedEvent!]!
  indexSubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscribedEvent
  indexSubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexSubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscribedEvent!]!
  indexUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnitsUpdatedEvent
  indexUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnitsUpdatedEvent!]!
  indexUnsubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnsubscribedEvent
  indexUnsubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnsubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnsubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnsubscribedEvent!]!
  subscriptionApprovedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionApprovedEvent
  subscriptionApprovedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionApprovedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionApprovedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionApprovedEvent!]!
  subscriptionDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionDistributionClaimedEvent
  subscriptionDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionDistributionClaimedEvent!]!
  subscriptionRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionRevokedEvent
  subscriptionRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionRevokedEvent!]!
  subscriptionUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionUnitsUpdatedEvent
  subscriptionUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionUnitsUpdatedEvent!]!
  agreementClassRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassRegisteredEvent
  agreementClassRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassRegisteredEvent!]!
  agreementClassUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassUpdatedEvent
  agreementClassUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassUpdatedEvent!]!
  appRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppRegisteredEvent
  appRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AppRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AppRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppRegisteredEvent!]!
  governanceReplacedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GovernanceReplacedEvent
  governanceReplacedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: GovernanceReplacedEvent_orderBy
    orderDirection: OrderDirection
    where: GovernanceReplacedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GovernanceReplacedEvent!]!
  jailEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JailEvent
  jailEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: JailEvent_orderBy
    orderDirection: OrderDirection
    where: JailEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [JailEvent!]!
  superTokenFactoryUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenFactoryUpdatedEvent
  superTokenFactoryUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenFactoryUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenFactoryUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenFactoryUpdatedEvent!]!
  superTokenLogicUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicUpdatedEvent
  superTokenLogicUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicUpdatedEvent!]!
  roleAdminChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleAdminChangedEvent
  roleAdminChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleAdminChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleAdminChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleAdminChangedEvent!]!
  roleGrantedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleGrantedEvent
  roleGrantedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleGrantedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleGrantedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleGrantedEvent!]!
  roleRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleRevokedEvent
  roleRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleRevokedEvent!]!
  setEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetEvent
  setEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SetEvent_orderBy
    orderDirection: OrderDirection
    where: SetEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetEvent!]!
  cfav1LiquidationPeriodChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CFAv1LiquidationPeriodChangedEvent
  cfav1LiquidationPeriodChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CFAv1LiquidationPeriodChangedEvent_orderBy
    orderDirection: OrderDirection
    where: CFAv1LiquidationPeriodChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CFAv1LiquidationPeriodChangedEvent!]!
  configChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConfigChangedEvent
  configChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ConfigChangedEvent_orderBy
    orderDirection: OrderDirection
    where: ConfigChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConfigChangedEvent!]!
  rewardAddressChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardAddressChangedEvent
  rewardAddressChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardAddressChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RewardAddressChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardAddressChangedEvent!]!
  pppconfigurationChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PPPConfigurationChangedEvent
  pppconfigurationChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PPPConfigurationChangedEvent_orderBy
    orderDirection: OrderDirection
    where: PPPConfigurationChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PPPConfigurationChangedEvent!]!
  superTokenMinimumDepositChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenMinimumDepositChangedEvent
  superTokenMinimumDepositChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenMinimumDepositChangedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenMinimumDepositChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenMinimumDepositChangedEvent!]!
  trustedForwarderChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TrustedForwarderChangedEvent
  trustedForwarderChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TrustedForwarderChangedEvent_orderBy
    orderDirection: OrderDirection
    where: TrustedForwarderChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TrustedForwarderChangedEvent!]!
  agreementLiquidatedByEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedByEvent
  agreementLiquidatedByEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedByEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedByEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedByEvent!]!
  agreementLiquidatedV2Event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedV2Event
  agreementLiquidatedV2Events(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedV2Event_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedV2Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedV2Event!]!
  burnedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BurnedEvent
  burnedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BurnedEvent_orderBy
    orderDirection: OrderDirection
    where: BurnedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BurnedEvent!]!
  mintedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MintedEvent
  mintedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: MintedEvent_orderBy
    orderDirection: OrderDirection
    where: MintedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MintedEvent!]!
  sentEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SentEvent
  sentEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SentEvent_orderBy
    orderDirection: OrderDirection
    where: SentEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SentEvent!]!
  transferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferEvent
  transferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TransferEvent_orderBy
    orderDirection: OrderDirection
    where: TransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransferEvent!]!
  tokenDowngradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDowngradedEvent
  tokenDowngradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenDowngradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenDowngradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenDowngradedEvent!]!
  tokenUpgradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenUpgradedEvent
  tokenUpgradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenUpgradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenUpgradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenUpgradedEvent!]!
  customSuperTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CustomSuperTokenCreatedEvent
  customSuperTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CustomSuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: CustomSuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CustomSuperTokenCreatedEvent!]!
  superTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenCreatedEvent
  superTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenCreatedEvent!]!
  superTokenLogicCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicCreatedEvent
  superTokenLogicCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicCreatedEvent!]!
  newPICEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewPICEvent
  newPICEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: NewPICEvent_orderBy
    orderDirection: OrderDirection
    where: NewPICEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewPICEvent!]!
  exitRateChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExitRateChangedEvent
  exitRateChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ExitRateChangedEvent_orderBy
    orderDirection: OrderDirection
    where: ExitRateChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ExitRateChangedEvent!]!
  bondIncreasedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondIncreasedEvent
  bondIncreasedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BondIncreasedEvent_orderBy
    orderDirection: OrderDirection
    where: BondIncreasedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondIncreasedEvent!]!
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  index(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Index
  indexes(
    skip: Int = 0
    first: Int = 100
    orderBy: Index_orderBy
    orderDirection: OrderDirection
    where: Index_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Index!]!
  indexSubscription(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscription
  indexSubscriptions(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscription_orderBy
    orderDirection: OrderDirection
    where: IndexSubscription_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscription!]!
  stream(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stream
  streams(
    skip: Int = 0
    first: Int = 100
    orderBy: Stream_orderBy
    orderDirection: OrderDirection
    where: Stream_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Stream!]!
  flowOperator(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperator
  flowOperators(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperator_orderBy
    orderDirection: OrderDirection
    where: FlowOperator_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperator!]!
  streamPeriod(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamPeriod
  streamPeriods(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamPeriod_orderBy
    orderDirection: OrderDirection
    where: StreamPeriod_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamPeriod!]!
  tokenGovernanceConfig(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenGovernanceConfig
  tokenGovernanceConfigs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenGovernanceConfig_orderBy
    orderDirection: OrderDirection
    where: TokenGovernanceConfig_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenGovernanceConfig!]!
  streamRevision(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamRevision
  streamRevisions(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamRevision_orderBy
    orderDirection: OrderDirection
    where: StreamRevision_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamRevision!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  resolverEntry(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEntry
  resolverEntries(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEntry_orderBy
    orderDirection: OrderDirection
    where: ResolverEntry_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEntry!]!
  accountTokenSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshot
  accountTokenSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshot_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshot!]!
  accountTokenSnapshotLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshotLog
  accountTokenSnapshotLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshotLog_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshotLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshotLog!]!
  tokenStatistic(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatistic
  tokenStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatistic_orderBy
    orderDirection: OrderDirection
    where: TokenStatistic_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatistic!]!
  tokenStatisticLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatisticLog
  tokenStatisticLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatisticLog_orderBy
    orderDirection: OrderDirection
    where: TokenStatisticLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatisticLog!]!
  sfmeta(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SFMeta
  sfmetas(
    skip: Int = 0
    first: Int = 100
    orderBy: SFMeta_orderBy
    orderDirection: OrderDirection
    where: SFMeta_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SFMeta!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type ResolverEntry {
  """
  ID: the keccak256 hash of the set name
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
  targetAddress: Bytes!
  isToken: Boolean!
  isListed: Boolean!
  setEvents(skip: Int = 0, first: Int = 100, orderBy: SetEvent_orderBy, orderDirection: OrderDirection, where: SetEvent_filter): [SetEvent!]!
}

input ResolverEntry_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  targetAddress: Bytes
  targetAddress_not: Bytes
  targetAddress_gt: Bytes
  targetAddress_lt: Bytes
  targetAddress_gte: Bytes
  targetAddress_lte: Bytes
  targetAddress_in: [Bytes!]
  targetAddress_not_in: [Bytes!]
  targetAddress_contains: Bytes
  targetAddress_not_contains: Bytes
  isToken: Boolean
  isToken_not: Boolean
  isToken_in: [Boolean!]
  isToken_not_in: [Boolean!]
  isListed: Boolean
  isListed_not: Boolean
  isListed_in: [Boolean!]
  isListed_not_in: [Boolean!]
  setEvents_: SetEvent_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [ResolverEntry_filter]
  or: [ResolverEntry_filter]
}

enum ResolverEntry_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  targetAddress
  isToken
  isListed
  setEvents
}

type RewardAddressChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  rewardAddress: Bytes!
}

input RewardAddressChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_gt: Bytes
  governanceAddress_lt: Bytes
  governanceAddress_gte: Bytes
  governanceAddress_lte: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_gt: Bytes
  host_lt: Bytes
  host_gte: Bytes
  host_lte: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_gt: Bytes
  superToken_lt: Bytes
  superToken_gte: Bytes
  superToken_lte: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  rewardAddress: Bytes
  rewardAddress_not: Bytes
  rewardAddress_gt: Bytes
  rewardAddress_lt: Bytes
  rewardAddress_gte: Bytes
  rewardAddress_lte: Bytes
  rewardAddress_in: [Bytes!]
  rewardAddress_not_in: [Bytes!]
  rewardAddress_contains: Bytes
  rewardAddress_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RewardAddressChangedEvent_filter]
  or: [RewardAddressChangedEvent_filter]
}

enum RewardAddressChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  isKeySet
  rewardAddress
}

type RoleAdminChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  role: Bytes!
  previousAdminRole: Bytes!
  newAdminRole: Bytes!
}

input RoleAdminChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  role: Bytes
  role_not: Bytes
  role_gt: Bytes
  role_lt: Bytes
  role_gte: Bytes
  role_lte: Bytes
  role_in: [Bytes!]
  role_not_in: [Bytes!]
  role_contains: Bytes
  role_not_contains: Bytes
  previousAdminRole: Bytes
  previousAdminRole_not: Bytes
  previousAdminRole_gt: Bytes
  previousAdminRole_lt: Bytes
  previousAdminRole_gte: Bytes
  previousAdminRole_lte: Bytes
  previousAdminRole_in: [Bytes!]
  previousAdminRole_not_in: [Bytes!]
  previousAdminRole_contains: Bytes
  previousAdminRole_not_contains: Bytes
  newAdminRole: Bytes
  newAdminRole_not: Bytes
  newAdminRole_gt: Bytes
  newAdminRole_lt: Bytes
  newAdminRole_gte: Bytes
  newAdminRole_lte: Bytes
  newAdminRole_in: [Bytes!]
  newAdminRole_not_in: [Bytes!]
  newAdminRole_contains: Bytes
  newAdminRole_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RoleAdminChangedEvent_filter]
  or: [RoleAdminChangedEvent_filter]
}

enum RoleAdminChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  role
  previousAdminRole
  newAdminRole
}

type RoleGrantedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  role: Bytes!
  account: Bytes!
  sender: Bytes!
}

input RoleGrantedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  role: Bytes
  role_not: Bytes
  role_gt: Bytes
  role_lt: Bytes
  role_gte: Bytes
  role_lte: Bytes
  role_in: [Bytes!]
  role_not_in: [Bytes!]
  role_contains: Bytes
  role_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RoleGrantedEvent_filter]
  or: [RoleGrantedEvent_filter]
}

enum RoleGrantedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  role
  account
  sender
}

type RoleRevokedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  role: Bytes!
  account: Bytes!
  sender: Bytes!
}

input RoleRevokedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  role: Bytes
  role_not: Bytes
  role_gt: Bytes
  role_lt: Bytes
  role_gte: Bytes
  role_lte: Bytes
  role_in: [Bytes!]
  role_not_in: [Bytes!]
  role_contains: Bytes
  role_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  sender: Bytes
  sender_not: Bytes
  sender_gt: Bytes
  sender_lt: Bytes
  sender_gte: Bytes
  sender_lte: Bytes
  sender_in: [Bytes!]
  sender_not_in: [Bytes!]
  sender_contains: Bytes
  sender_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [RoleRevokedEvent_filter]
  or: [RoleRevokedEvent_filter]
}

enum RoleRevokedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  role
  account
  sender
}

type SentEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `operator`
  addresses[2] = `from`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  operator: Bytes!
  from: Bytes!
  to: Bytes!
  token: Bytes!
  amount: BigInt!
  data: Bytes!
  operatorData: Bytes!
}

input SentEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  operator: Bytes
  operator_not: Bytes
  operator_gt: Bytes
  operator_lt: Bytes
  operator_gte: Bytes
  operator_lte: Bytes
  operator_in: [Bytes!]
  operator_not_in: [Bytes!]
  operator_contains: Bytes
  operator_not_contains: Bytes
  from: Bytes
  from_not: Bytes
  from_gt: Bytes
  from_lt: Bytes
  from_gte: Bytes
  from_lte: Bytes
  from_in: [Bytes!]
  from_not_in: [Bytes!]
  from_contains: Bytes
  from_not_contains: Bytes
  to: Bytes
  to_not: Bytes
  to_gt: Bytes
  to_lt: Bytes
  to_gte: Bytes
  to_lte: Bytes
  to_in: [Bytes!]
  to_not_in: [Bytes!]
  to_contains: Bytes
  to_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  data: Bytes
  data_not: Bytes
  data_gt: Bytes
  data_lt: Bytes
  data_gte: Bytes
  data_lte: Bytes
  data_in: [Bytes!]
  data_not_in: [Bytes!]
  data_contains: Bytes
  data_not_contains: Bytes
  operatorData: Bytes
  operatorData_not: Bytes
  operatorData_gt: Bytes
  operatorData_lt: Bytes
  operatorData_gte: Bytes
  operatorData_lte: Bytes
  operatorData_in: [Bytes!]
  operatorData_not_in: [Bytes!]
  operatorData_contains: Bytes
  operatorData_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SentEvent_filter]
  or: [SentEvent_filter]
}

enum SentEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  operator
  from
  to
  token
  amount
  data
  operatorData
}

type SetEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!

  """
  Because the name property is indexed, the
  returned value will be a keccak256 hash
  of the string.
  
  """
  hashedName: Bytes!
  target: Bytes!
  resolverEntry: ResolverEntry!
}

input SetEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  hashedName: Bytes
  hashedName_not: Bytes
  hashedName_gt: Bytes
  hashedName_lt: Bytes
  hashedName_gte: Bytes
  hashedName_lte: Bytes
  hashedName_in: [Bytes!]
  hashedName_not_in: [Bytes!]
  hashedName_contains: Bytes
  hashedName_not_contains: Bytes
  target: Bytes
  target_not: Bytes
  target_gt: Bytes
  target_lt: Bytes
  target_gte: Bytes
  target_lte: Bytes
  target_in: [Bytes!]
  target_not_in: [Bytes!]
  target_contains: Bytes
  target_not_contains: Bytes
  resolverEntry: String
  resolverEntry_not: String
  resolverEntry_gt: String
  resolverEntry_lt: String
  resolverEntry_gte: String
  resolverEntry_lte: String
  resolverEntry_in: [String!]
  resolverEntry_not_in: [String!]
  resolverEntry_contains: String
  resolverEntry_contains_nocase: String
  resolverEntry_not_contains: String
  resolverEntry_not_contains_nocase: String
  resolverEntry_starts_with: String
  resolverEntry_starts_with_nocase: String
  resolverEntry_not_starts_with: String
  resolverEntry_not_starts_with_nocase: String
  resolverEntry_ends_with: String
  resolverEntry_ends_with_nocase: String
  resolverEntry_not_ends_with: String
  resolverEntry_not_ends_with_nocase: String
  resolverEntry_: ResolverEntry_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SetEvent_filter]
  or: [SetEvent_filter]
}

enum SetEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  hashedName
  target
  resolverEntry
  resolverEntry__id
  resolverEntry__createdAtTimestamp
  resolverEntry__createdAtBlockNumber
  resolverEntry__updatedAtTimestamp
  resolverEntry__updatedAtBlockNumber
  resolverEntry__targetAddress
  resolverEntry__isToken
  resolverEntry__isListed
}

type SFMeta {
  """
  The id is the commit hash.
  
  """
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!

  """
  Whether the branch is feature/dev/v1.
  
  """
  configuration: String!

  """
  The branch the current deployment is coming from.
  
  """
  branch: String!
}

input SFMeta_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  configuration: String
  configuration_not: String
  configuration_gt: String
  configuration_lt: String
  configuration_gte: String
  configuration_lte: String
  configuration_in: [String!]
  configuration_not_in: [String!]
  configuration_contains: String
  configuration_contains_nocase: String
  configuration_not_contains: String
  configuration_not_contains_nocase: String
  configuration_starts_with: String
  configuration_starts_with_nocase: String
  configuration_not_starts_with: String
  configuration_not_starts_with_nocase: String
  configuration_ends_with: String
  configuration_ends_with_nocase: String
  configuration_not_ends_with: String
  configuration_not_ends_with_nocase: String
  branch: String
  branch_not: String
  branch_gt: String
  branch_lt: String
  branch_gte: String
  branch_lte: String
  branch_in: [String!]
  branch_not_in: [String!]
  branch_contains: String
  branch_contains_nocase: String
  branch_not_contains: String
  branch_not_contains_nocase: String
  branch_starts_with: String
  branch_starts_with_nocase: String
  branch_not_starts_with: String
  branch_not_starts_with_nocase: String
  branch_ends_with: String
  branch_ends_with_nocase: String
  branch_not_ends_with: String
  branch_not_ends_with_nocase: String

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SFMeta_filter]
  or: [SFMeta_filter]
}

enum SFMeta_orderBy {
  id
  timestamp
  blockNumber
  configuration
  branch
}

"""
Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
The next stream you create with the same `sender` and `receiver` will create a new stream entity.
Therefore, multiple stream entities can be created between the same `sender` and `receiver`.

"""
type Stream {
  """
  ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!
  currentFlowRate: BigInt!
  deposit: BigInt!

  """
  The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`.
  The formula to get the current streamed amount is:
  `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
  
  """
  streamedUntilUpdatedAt: BigInt!
  token: Token!
  sender: Account!
  receiver: Account!

  """
  The `userData` stored on the Stream is the last `userData` that was set in a `FlowUpdatedEvent`,
  for this particular stream. To see the historical `userData` for this stream, you can query the `flowUpdatedEvents` field.
  
  """
  userData: Bytes!
  flowUpdatedEvents(skip: Int = 0, first: Int = 100, orderBy: FlowUpdatedEvent_orderBy, orderDirection: OrderDirection, where: FlowUpdatedEvent_filter): [FlowUpdatedEvent!]!
  streamPeriods(skip: Int = 0, first: Int = 100, orderBy: StreamPeriod_orderBy, orderDirection: OrderDirection, where: StreamPeriod_filter): [StreamPeriod!]!
}

input Stream_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  currentFlowRate: BigInt
  currentFlowRate_not: BigInt
  currentFlowRate_gt: BigInt
  currentFlowRate_lt: BigInt
  currentFlowRate_gte: BigInt
  currentFlowRate_lte: BigInt
  currentFlowRate_in: [BigInt!]
  currentFlowRate_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  streamedUntilUpdatedAt: BigInt
  streamedUntilUpdatedAt_not: BigInt
  streamedUntilUpdatedAt_gt: BigInt
  streamedUntilUpdatedAt_lt: BigInt
  streamedUntilUpdatedAt_gte: BigInt
  streamedUntilUpdatedAt_lte: BigInt
  streamedUntilUpdatedAt_in: [BigInt!]
  streamedUntilUpdatedAt_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Account_filter
  receiver: String
  receiver_not: String
  receiver_gt: String
  receiver_lt: String
  receiver_gte: String
  receiver_lte: String
  receiver_in: [String!]
  receiver_not_in: [String!]
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_: Account_filter
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  flowUpdatedEvents_: FlowUpdatedEvent_filter
  streamPeriods_: StreamPeriod_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Stream_filter]
  or: [Stream_filter]
}

enum Stream_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  currentFlowRate
  deposit
  streamedUntilUpdatedAt
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  sender
  sender__id
  sender__createdAtTimestamp
  sender__createdAtBlockNumber
  sender__updatedAtTimestamp
  sender__updatedAtBlockNumber
  sender__isSuperApp
  receiver
  receiver__id
  receiver__createdAtTimestamp
  receiver__createdAtBlockNumber
  receiver__updatedAtTimestamp
  receiver__updatedAtBlockNumber
  receiver__isSuperApp
  userData
  flowUpdatedEvents
  streamPeriods
}

"""
StreamPeriod: A higher order entity that represents a period of time in a Stream with a constant flowRate.

"""
type StreamPeriod {
  """
  ID composed of: streamId - periodRevisionIndex
  
  """
  id: ID!
  stream: Stream!
  sender: Account!
  receiver: Account!
  token: Token!
  flowRate: BigInt!
  deposit: BigInt!
  startedAtTimestamp: BigInt!
  startedAtBlockNumber: BigInt!
  startedAtEvent: FlowUpdatedEvent!

  """
  Following values are null until the StreamPeriod is terminated
  
  """
  stoppedAtTimestamp: BigInt
  stoppedAtBlockNumber: BigInt
  stoppedAtEvent: FlowUpdatedEvent
  totalAmountStreamed: BigInt
}

input StreamPeriod_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  stream: String
  stream_not: String
  stream_gt: String
  stream_lt: String
  stream_gte: String
  stream_lte: String
  stream_in: [String!]
  stream_not_in: [String!]
  stream_contains: String
  stream_contains_nocase: String
  stream_not_contains: String
  stream_not_contains_nocase: String
  stream_starts_with: String
  stream_starts_with_nocase: String
  stream_not_starts_with: String
  stream_not_starts_with_nocase: String
  stream_ends_with: String
  stream_ends_with_nocase: String
  stream_not_ends_with: String
  stream_not_ends_with_nocase: String
  stream_: Stream_filter
  sender: String
  sender_not: String
  sender_gt: String
  sender_lt: String
  sender_gte: String
  sender_lte: String
  sender_in: [String!]
  sender_not_in: [String!]
  sender_contains: String
  sender_contains_nocase: String
  sender_not_contains: String
  sender_not_contains_nocase: String
  sender_starts_with: String
  sender_starts_with_nocase: String
  sender_not_starts_with: String
  sender_not_starts_with_nocase: String
  sender_ends_with: String
  sender_ends_with_nocase: String
  sender_not_ends_with: String
  sender_not_ends_with_nocase: String
  sender_: Account_filter
  receiver: String
  receiver_not: String
  receiver_gt: String
  receiver_lt: String
  receiver_gte: String
  receiver_lte: String
  receiver_in: [String!]
  receiver_not_in: [String!]
  receiver_contains: String
  receiver_contains_nocase: String
  receiver_not_contains: String
  receiver_not_contains_nocase: String
  receiver_starts_with: String
  receiver_starts_with_nocase: String
  receiver_not_starts_with: String
  receiver_not_starts_with_nocase: String
  receiver_ends_with: String
  receiver_ends_with_nocase: String
  receiver_not_ends_with: String
  receiver_not_ends_with_nocase: String
  receiver_: Account_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  flowRate: BigInt
  flowRate_not: BigInt
  flowRate_gt: BigInt
  flowRate_lt: BigInt
  flowRate_gte: BigInt
  flowRate_lte: BigInt
  flowRate_in: [BigInt!]
  flowRate_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  startedAtTimestamp: BigInt
  startedAtTimestamp_not: BigInt
  startedAtTimestamp_gt: BigInt
  startedAtTimestamp_lt: BigInt
  startedAtTimestamp_gte: BigInt
  startedAtTimestamp_lte: BigInt
  startedAtTimestamp_in: [BigInt!]
  startedAtTimestamp_not_in: [BigInt!]
  startedAtBlockNumber: BigInt
  startedAtBlockNumber_not: BigInt
  startedAtBlockNumber_gt: BigInt
  startedAtBlockNumber_lt: BigInt
  startedAtBlockNumber_gte: BigInt
  startedAtBlockNumber_lte: BigInt
  startedAtBlockNumber_in: [BigInt!]
  startedAtBlockNumber_not_in: [BigInt!]
  startedAtEvent: String
  startedAtEvent_not: String
  startedAtEvent_gt: String
  startedAtEvent_lt: String
  startedAtEvent_gte: String
  startedAtEvent_lte: String
  startedAtEvent_in: [String!]
  startedAtEvent_not_in: [String!]
  startedAtEvent_contains: String
  startedAtEvent_contains_nocase: String
  startedAtEvent_not_contains: String
  startedAtEvent_not_contains_nocase: String
  startedAtEvent_starts_with: String
  startedAtEvent_starts_with_nocase: String
  startedAtEvent_not_starts_with: String
  startedAtEvent_not_starts_with_nocase: String
  startedAtEvent_ends_with: String
  startedAtEvent_ends_with_nocase: String
  startedAtEvent_not_ends_with: String
  startedAtEvent_not_ends_with_nocase: String
  startedAtEvent_: FlowUpdatedEvent_filter
  stoppedAtTimestamp: BigInt
  stoppedAtTimestamp_not: BigInt
  stoppedAtTimestamp_gt: BigInt
  stoppedAtTimestamp_lt: BigInt
  stoppedAtTimestamp_gte: BigInt
  stoppedAtTimestamp_lte: BigInt
  stoppedAtTimestamp_in: [BigInt!]
  stoppedAtTimestamp_not_in: [BigInt!]
  stoppedAtBlockNumber: BigInt
  stoppedAtBlockNumber_not: BigInt
  stoppedAtBlockNumber_gt: BigInt
  stoppedAtBlockNumber_lt: BigInt
  stoppedAtBlockNumber_gte: BigInt
  stoppedAtBlockNumber_lte: BigInt
  stoppedAtBlockNumber_in: [BigInt!]
  stoppedAtBlockNumber_not_in: [BigInt!]
  stoppedAtEvent: String
  stoppedAtEvent_not: String
  stoppedAtEvent_gt: String
  stoppedAtEvent_lt: String
  stoppedAtEvent_gte: String
  stoppedAtEvent_lte: String
  stoppedAtEvent_in: [String!]
  stoppedAtEvent_not_in: [String!]
  stoppedAtEvent_contains: String
  stoppedAtEvent_contains_nocase: String
  stoppedAtEvent_not_contains: String
  stoppedAtEvent_not_contains_nocase: String
  stoppedAtEvent_starts_with: String
  stoppedAtEvent_starts_with_nocase: String
  stoppedAtEvent_not_starts_with: String
  stoppedAtEvent_not_starts_with_nocase: String
  stoppedAtEvent_ends_with: String
  stoppedAtEvent_ends_with_nocase: String
  stoppedAtEvent_not_ends_with: String
  stoppedAtEvent_not_ends_with_nocase: String
  stoppedAtEvent_: FlowUpdatedEvent_filter
  totalAmountStreamed: BigInt
  totalAmountStreamed_not: BigInt
  totalAmountStreamed_gt: BigInt
  totalAmountStreamed_lt: BigInt
  totalAmountStreamed_gte: BigInt
  totalAmountStreamed_lte: BigInt
  totalAmountStreamed_in: [BigInt!]
  totalAmountStreamed_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StreamPeriod_filter]
  or: [StreamPeriod_filter]
}

enum StreamPeriod_orderBy {
  id
  stream
  stream__id
  stream__createdAtTimestamp
  stream__createdAtBlockNumber
  stream__updatedAtTimestamp
  stream__updatedAtBlockNumber
  stream__currentFlowRate
  stream__deposit
  stream__streamedUntilUpdatedAt
  stream__userData
  sender
  sender__id
  sender__createdAtTimestamp
  sender__createdAtBlockNumber
  sender__updatedAtTimestamp
  sender__updatedAtBlockNumber
  sender__isSuperApp
  receiver
  receiver__id
  receiver__createdAtTimestamp
  receiver__createdAtBlockNumber
  receiver__updatedAtTimestamp
  receiver__updatedAtBlockNumber
  receiver__isSuperApp
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  flowRate
  deposit
  startedAtTimestamp
  startedAtBlockNumber
  startedAtEvent
  startedAtEvent__id
  startedAtEvent__transactionHash
  startedAtEvent__gasPrice
  startedAtEvent__gasUsed
  startedAtEvent__timestamp
  startedAtEvent__name
  startedAtEvent__blockNumber
  startedAtEvent__logIndex
  startedAtEvent__order
  startedAtEvent__token
  startedAtEvent__sender
  startedAtEvent__receiver
  startedAtEvent__flowOperator
  startedAtEvent__flowRate
  startedAtEvent__totalSenderFlowRate
  startedAtEvent__totalReceiverFlowRate
  startedAtEvent__deposit
  startedAtEvent__userData
  startedAtEvent__oldFlowRate
  startedAtEvent__type
  startedAtEvent__totalAmountStreamedUntilTimestamp
  stoppedAtTimestamp
  stoppedAtBlockNumber
  stoppedAtEvent
  stoppedAtEvent__id
  stoppedAtEvent__transactionHash
  stoppedAtEvent__gasPrice
  stoppedAtEvent__gasUsed
  stoppedAtEvent__timestamp
  stoppedAtEvent__name
  stoppedAtEvent__blockNumber
  stoppedAtEvent__logIndex
  stoppedAtEvent__order
  stoppedAtEvent__token
  stoppedAtEvent__sender
  stoppedAtEvent__receiver
  stoppedAtEvent__flowOperator
  stoppedAtEvent__flowRate
  stoppedAtEvent__totalSenderFlowRate
  stoppedAtEvent__totalReceiverFlowRate
  stoppedAtEvent__deposit
  stoppedAtEvent__userData
  stoppedAtEvent__oldFlowRate
  stoppedAtEvent__type
  stoppedAtEvent__totalAmountStreamedUntilTimestamp
  totalAmountStreamed
}

type StreamRevision {
  """
  ID composed of: keccak256(abi.encode(sender,receiver))-tokenAddress
  
  """
  id: ID!
  revisionIndex: Int!
  periodRevisionIndex: Int!

  """
  The "most recently alive" stream between a sender and receiver.
  Note: The `revisionIndex` property may not be the same as the `revisionIndex`
  of `mostRecentStream`. Which means `mostRecentStream` has been closed and no
  new stream has been opened.
  
  """
  mostRecentStream: Stream!
}

input StreamRevision_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  revisionIndex: Int
  revisionIndex_not: Int
  revisionIndex_gt: Int
  revisionIndex_lt: Int
  revisionIndex_gte: Int
  revisionIndex_lte: Int
  revisionIndex_in: [Int!]
  revisionIndex_not_in: [Int!]
  periodRevisionIndex: Int
  periodRevisionIndex_not: Int
  periodRevisionIndex_gt: Int
  periodRevisionIndex_lt: Int
  periodRevisionIndex_gte: Int
  periodRevisionIndex_lte: Int
  periodRevisionIndex_in: [Int!]
  periodRevisionIndex_not_in: [Int!]
  mostRecentStream: String
  mostRecentStream_not: String
  mostRecentStream_gt: String
  mostRecentStream_lt: String
  mostRecentStream_gte: String
  mostRecentStream_lte: String
  mostRecentStream_in: [String!]
  mostRecentStream_not_in: [String!]
  mostRecentStream_contains: String
  mostRecentStream_contains_nocase: String
  mostRecentStream_not_contains: String
  mostRecentStream_not_contains_nocase: String
  mostRecentStream_starts_with: String
  mostRecentStream_starts_with_nocase: String
  mostRecentStream_not_starts_with: String
  mostRecentStream_not_starts_with_nocase: String
  mostRecentStream_ends_with: String
  mostRecentStream_ends_with_nocase: String
  mostRecentStream_not_ends_with: String
  mostRecentStream_not_ends_with_nocase: String
  mostRecentStream_: Stream_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StreamRevision_filter]
  or: [StreamRevision_filter]
}

enum StreamRevision_orderBy {
  id
  revisionIndex
  periodRevisionIndex
  mostRecentStream
  mostRecentStream__id
  mostRecentStream__createdAtTimestamp
  mostRecentStream__createdAtBlockNumber
  mostRecentStream__updatedAtTimestamp
  mostRecentStream__updatedAtBlockNumber
  mostRecentStream__currentFlowRate
  mostRecentStream__deposit
  mostRecentStream__streamedUntilUpdatedAt
  mostRecentStream__userData
}

type Subscription {
  flowUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowUpdatedEvent
  flowUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowUpdatedEvent!]!
  flowOperatorUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperatorUpdatedEvent
  flowOperatorUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperatorUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: FlowOperatorUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperatorUpdatedEvent!]!
  indexCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexCreatedEvent
  indexCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexCreatedEvent!]!
  indexDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexDistributionClaimedEvent
  indexDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexDistributionClaimedEvent!]!
  indexUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUpdatedEvent
  indexUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUpdatedEvent!]!
  indexSubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscribedEvent
  indexSubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexSubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscribedEvent!]!
  indexUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnitsUpdatedEvent
  indexUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnitsUpdatedEvent!]!
  indexUnsubscribedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexUnsubscribedEvent
  indexUnsubscribedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexUnsubscribedEvent_orderBy
    orderDirection: OrderDirection
    where: IndexUnsubscribedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexUnsubscribedEvent!]!
  subscriptionApprovedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionApprovedEvent
  subscriptionApprovedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionApprovedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionApprovedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionApprovedEvent!]!
  subscriptionDistributionClaimedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionDistributionClaimedEvent
  subscriptionDistributionClaimedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionDistributionClaimedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionDistributionClaimedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionDistributionClaimedEvent!]!
  subscriptionRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionRevokedEvent
  subscriptionRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionRevokedEvent!]!
  subscriptionUnitsUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SubscriptionUnitsUpdatedEvent
  subscriptionUnitsUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SubscriptionUnitsUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SubscriptionUnitsUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SubscriptionUnitsUpdatedEvent!]!
  agreementClassRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassRegisteredEvent
  agreementClassRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassRegisteredEvent!]!
  agreementClassUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementClassUpdatedEvent
  agreementClassUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementClassUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementClassUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementClassUpdatedEvent!]!
  appRegisteredEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AppRegisteredEvent
  appRegisteredEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AppRegisteredEvent_orderBy
    orderDirection: OrderDirection
    where: AppRegisteredEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AppRegisteredEvent!]!
  governanceReplacedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): GovernanceReplacedEvent
  governanceReplacedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: GovernanceReplacedEvent_orderBy
    orderDirection: OrderDirection
    where: GovernanceReplacedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [GovernanceReplacedEvent!]!
  jailEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): JailEvent
  jailEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: JailEvent_orderBy
    orderDirection: OrderDirection
    where: JailEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [JailEvent!]!
  superTokenFactoryUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenFactoryUpdatedEvent
  superTokenFactoryUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenFactoryUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenFactoryUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenFactoryUpdatedEvent!]!
  superTokenLogicUpdatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicUpdatedEvent
  superTokenLogicUpdatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicUpdatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicUpdatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicUpdatedEvent!]!
  roleAdminChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleAdminChangedEvent
  roleAdminChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleAdminChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleAdminChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleAdminChangedEvent!]!
  roleGrantedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleGrantedEvent
  roleGrantedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleGrantedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleGrantedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleGrantedEvent!]!
  roleRevokedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RoleRevokedEvent
  roleRevokedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RoleRevokedEvent_orderBy
    orderDirection: OrderDirection
    where: RoleRevokedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RoleRevokedEvent!]!
  setEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SetEvent
  setEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SetEvent_orderBy
    orderDirection: OrderDirection
    where: SetEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SetEvent!]!
  cfav1LiquidationPeriodChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CFAv1LiquidationPeriodChangedEvent
  cfav1LiquidationPeriodChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CFAv1LiquidationPeriodChangedEvent_orderBy
    orderDirection: OrderDirection
    where: CFAv1LiquidationPeriodChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CFAv1LiquidationPeriodChangedEvent!]!
  configChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ConfigChangedEvent
  configChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ConfigChangedEvent_orderBy
    orderDirection: OrderDirection
    where: ConfigChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ConfigChangedEvent!]!
  rewardAddressChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): RewardAddressChangedEvent
  rewardAddressChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: RewardAddressChangedEvent_orderBy
    orderDirection: OrderDirection
    where: RewardAddressChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [RewardAddressChangedEvent!]!
  pppconfigurationChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PPPConfigurationChangedEvent
  pppconfigurationChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: PPPConfigurationChangedEvent_orderBy
    orderDirection: OrderDirection
    where: PPPConfigurationChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PPPConfigurationChangedEvent!]!
  superTokenMinimumDepositChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenMinimumDepositChangedEvent
  superTokenMinimumDepositChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenMinimumDepositChangedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenMinimumDepositChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenMinimumDepositChangedEvent!]!
  trustedForwarderChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TrustedForwarderChangedEvent
  trustedForwarderChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TrustedForwarderChangedEvent_orderBy
    orderDirection: OrderDirection
    where: TrustedForwarderChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TrustedForwarderChangedEvent!]!
  agreementLiquidatedByEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedByEvent
  agreementLiquidatedByEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedByEvent_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedByEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedByEvent!]!
  agreementLiquidatedV2Event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AgreementLiquidatedV2Event
  agreementLiquidatedV2Events(
    skip: Int = 0
    first: Int = 100
    orderBy: AgreementLiquidatedV2Event_orderBy
    orderDirection: OrderDirection
    where: AgreementLiquidatedV2Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AgreementLiquidatedV2Event!]!
  burnedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BurnedEvent
  burnedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BurnedEvent_orderBy
    orderDirection: OrderDirection
    where: BurnedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BurnedEvent!]!
  mintedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MintedEvent
  mintedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: MintedEvent_orderBy
    orderDirection: OrderDirection
    where: MintedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MintedEvent!]!
  sentEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SentEvent
  sentEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SentEvent_orderBy
    orderDirection: OrderDirection
    where: SentEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SentEvent!]!
  transferEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TransferEvent
  transferEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TransferEvent_orderBy
    orderDirection: OrderDirection
    where: TransferEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TransferEvent!]!
  tokenDowngradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenDowngradedEvent
  tokenDowngradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenDowngradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenDowngradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenDowngradedEvent!]!
  tokenUpgradedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenUpgradedEvent
  tokenUpgradedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenUpgradedEvent_orderBy
    orderDirection: OrderDirection
    where: TokenUpgradedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenUpgradedEvent!]!
  customSuperTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CustomSuperTokenCreatedEvent
  customSuperTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: CustomSuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: CustomSuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CustomSuperTokenCreatedEvent!]!
  superTokenCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenCreatedEvent
  superTokenCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenCreatedEvent!]!
  superTokenLogicCreatedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SuperTokenLogicCreatedEvent
  superTokenLogicCreatedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: SuperTokenLogicCreatedEvent_orderBy
    orderDirection: OrderDirection
    where: SuperTokenLogicCreatedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SuperTokenLogicCreatedEvent!]!
  newPICEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): NewPICEvent
  newPICEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: NewPICEvent_orderBy
    orderDirection: OrderDirection
    where: NewPICEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [NewPICEvent!]!
  exitRateChangedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ExitRateChangedEvent
  exitRateChangedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: ExitRateChangedEvent_orderBy
    orderDirection: OrderDirection
    where: ExitRateChangedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ExitRateChangedEvent!]!
  bondIncreasedEvent(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BondIncreasedEvent
  bondIncreasedEvents(
    skip: Int = 0
    first: Int = 100
    orderBy: BondIncreasedEvent_orderBy
    orderDirection: OrderDirection
    where: BondIncreasedEvent_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BondIncreasedEvent!]!
  account(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Account
  accounts(
    skip: Int = 0
    first: Int = 100
    orderBy: Account_orderBy
    orderDirection: OrderDirection
    where: Account_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Account!]!
  index(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Index
  indexes(
    skip: Int = 0
    first: Int = 100
    orderBy: Index_orderBy
    orderDirection: OrderDirection
    where: Index_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Index!]!
  indexSubscription(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): IndexSubscription
  indexSubscriptions(
    skip: Int = 0
    first: Int = 100
    orderBy: IndexSubscription_orderBy
    orderDirection: OrderDirection
    where: IndexSubscription_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [IndexSubscription!]!
  stream(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Stream
  streams(
    skip: Int = 0
    first: Int = 100
    orderBy: Stream_orderBy
    orderDirection: OrderDirection
    where: Stream_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Stream!]!
  flowOperator(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): FlowOperator
  flowOperators(
    skip: Int = 0
    first: Int = 100
    orderBy: FlowOperator_orderBy
    orderDirection: OrderDirection
    where: FlowOperator_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [FlowOperator!]!
  streamPeriod(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamPeriod
  streamPeriods(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamPeriod_orderBy
    orderDirection: OrderDirection
    where: StreamPeriod_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamPeriod!]!
  tokenGovernanceConfig(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenGovernanceConfig
  tokenGovernanceConfigs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenGovernanceConfig_orderBy
    orderDirection: OrderDirection
    where: TokenGovernanceConfig_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenGovernanceConfig!]!
  streamRevision(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StreamRevision
  streamRevisions(
    skip: Int = 0
    first: Int = 100
    orderBy: StreamRevision_orderBy
    orderDirection: OrderDirection
    where: StreamRevision_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StreamRevision!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  resolverEntry(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ResolverEntry
  resolverEntries(
    skip: Int = 0
    first: Int = 100
    orderBy: ResolverEntry_orderBy
    orderDirection: OrderDirection
    where: ResolverEntry_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ResolverEntry!]!
  accountTokenSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshot
  accountTokenSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshot_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshot!]!
  accountTokenSnapshotLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AccountTokenSnapshotLog
  accountTokenSnapshotLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: AccountTokenSnapshotLog_orderBy
    orderDirection: OrderDirection
    where: AccountTokenSnapshotLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AccountTokenSnapshotLog!]!
  tokenStatistic(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatistic
  tokenStatistics(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatistic_orderBy
    orderDirection: OrderDirection
    where: TokenStatistic_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatistic!]!
  tokenStatisticLog(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenStatisticLog
  tokenStatisticLogs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenStatisticLog_orderBy
    orderDirection: OrderDirection
    where: TokenStatisticLog_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenStatisticLog!]!
  sfmeta(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): SFMeta
  sfmetas(
    skip: Int = 0
    first: Int = 100
    orderBy: SFMeta_orderBy
    orderDirection: OrderDirection
    where: SFMeta_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [SFMeta!]!
  event(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Event
  events(
    skip: Int = 0
    first: Int = 100
    orderBy: Event_orderBy
    orderDirection: OrderDirection
    where: Event_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Event!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type SubscriptionApprovedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!
  userData: Bytes!
  subscription: IndexSubscription!
}

input SubscriptionApprovedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SubscriptionApprovedEvent_filter]
  or: [SubscriptionApprovedEvent_filter]
}

enum SubscriptionApprovedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  userData
  subscription
  subscription__id
  subscription__createdAtTimestamp
  subscription__createdAtBlockNumber
  subscription__updatedAtTimestamp
  subscription__updatedAtBlockNumber
  subscription__approved
  subscription__units
  subscription__totalAmountReceivedUntilUpdatedAt
  subscription__indexValueUntilUpdatedAt
}

type SubscriptionDistributionClaimedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!
  amount: BigInt!
  subscription: IndexSubscription!
}

input SubscriptionDistributionClaimedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SubscriptionDistributionClaimedEvent_filter]
  or: [SubscriptionDistributionClaimedEvent_filter]
}

enum SubscriptionDistributionClaimedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  amount
  subscription
  subscription__id
  subscription__createdAtTimestamp
  subscription__createdAtBlockNumber
  subscription__updatedAtTimestamp
  subscription__updatedAtBlockNumber
  subscription__approved
  subscription__units
  subscription__totalAmountReceivedUntilUpdatedAt
  subscription__indexValueUntilUpdatedAt
}

type SubscriptionRevokedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!
  userData: Bytes!
  subscription: IndexSubscription!
}

input SubscriptionRevokedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SubscriptionRevokedEvent_filter]
  or: [SubscriptionRevokedEvent_filter]
}

enum SubscriptionRevokedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  userData
  subscription
  subscription__id
  subscription__createdAtTimestamp
  subscription__createdAtBlockNumber
  subscription__updatedAtTimestamp
  subscription__updatedAtBlockNumber
  subscription__approved
  subscription__units
  subscription__totalAmountReceivedUntilUpdatedAt
  subscription__indexValueUntilUpdatedAt
}

type SubscriptionUnitsUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `publisher`
  addresses[2] = `subscriber`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!

  """
  The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
  `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
  
  """
  subscriber: Bytes!

  """
  The creator of the `index`.
  
  """
  publisher: Bytes!

  """
  An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
  
  """
  indexId: BigInt!
  units: BigInt!
  userData: Bytes!
  oldUnits: BigInt!
  subscription: IndexSubscription!
}

input SubscriptionUnitsUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  subscriber: Bytes
  subscriber_not: Bytes
  subscriber_gt: Bytes
  subscriber_lt: Bytes
  subscriber_gte: Bytes
  subscriber_lte: Bytes
  subscriber_in: [Bytes!]
  subscriber_not_in: [Bytes!]
  subscriber_contains: Bytes
  subscriber_not_contains: Bytes
  publisher: Bytes
  publisher_not: Bytes
  publisher_gt: Bytes
  publisher_lt: Bytes
  publisher_gte: Bytes
  publisher_lte: Bytes
  publisher_in: [Bytes!]
  publisher_not_in: [Bytes!]
  publisher_contains: Bytes
  publisher_not_contains: Bytes
  indexId: BigInt
  indexId_not: BigInt
  indexId_gt: BigInt
  indexId_lt: BigInt
  indexId_gte: BigInt
  indexId_lte: BigInt
  indexId_in: [BigInt!]
  indexId_not_in: [BigInt!]
  units: BigInt
  units_not: BigInt
  units_gt: BigInt
  units_lt: BigInt
  units_gte: BigInt
  units_lte: BigInt
  units_in: [BigInt!]
  units_not_in: [BigInt!]
  userData: Bytes
  userData_not: Bytes
  userData_gt: Bytes
  userData_lt: Bytes
  userData_gte: Bytes
  userData_lte: Bytes
  userData_in: [Bytes!]
  userData_not_in: [Bytes!]
  userData_contains: Bytes
  userData_not_contains: Bytes
  oldUnits: BigInt
  oldUnits_not: BigInt
  oldUnits_gt: BigInt
  oldUnits_lt: BigInt
  oldUnits_gte: BigInt
  oldUnits_lte: BigInt
  oldUnits_in: [BigInt!]
  oldUnits_not_in: [BigInt!]
  subscription: String
  subscription_not: String
  subscription_gt: String
  subscription_lt: String
  subscription_gte: String
  subscription_lte: String
  subscription_in: [String!]
  subscription_not_in: [String!]
  subscription_contains: String
  subscription_contains_nocase: String
  subscription_not_contains: String
  subscription_not_contains_nocase: String
  subscription_starts_with: String
  subscription_starts_with_nocase: String
  subscription_not_starts_with: String
  subscription_not_starts_with_nocase: String
  subscription_ends_with: String
  subscription_ends_with_nocase: String
  subscription_not_ends_with: String
  subscription_not_ends_with_nocase: String
  subscription_: IndexSubscription_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SubscriptionUnitsUpdatedEvent_filter]
  or: [SubscriptionUnitsUpdatedEvent_filter]
}

enum SubscriptionUnitsUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  subscriber
  publisher
  indexId
  units
  userData
  oldUnits
  subscription
  subscription__id
  subscription__createdAtTimestamp
  subscription__createdAtBlockNumber
  subscription__updatedAtTimestamp
  subscription__updatedAtBlockNumber
  subscription__approved
  subscription__units
  subscription__totalAmountReceivedUntilUpdatedAt
  subscription__indexValueUntilUpdatedAt
}

type SuperTokenCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
}

input SuperTokenCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SuperTokenCreatedEvent_filter]
  or: [SuperTokenCreatedEvent_filter]
}

enum SuperTokenCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
}

type SuperTokenFactoryUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  newFactory: Bytes!
}

input SuperTokenFactoryUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  newFactory: Bytes
  newFactory_not: Bytes
  newFactory_gt: Bytes
  newFactory_lt: Bytes
  newFactory_gte: Bytes
  newFactory_lte: Bytes
  newFactory_in: [Bytes!]
  newFactory_not_in: [Bytes!]
  newFactory_contains: Bytes
  newFactory_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SuperTokenFactoryUpdatedEvent_filter]
  or: [SuperTokenFactoryUpdatedEvent_filter]
}

enum SuperTokenFactoryUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  newFactory
}

type SuperTokenLogicCreatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  tokenLogic: Bytes!
}

input SuperTokenLogicCreatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  tokenLogic: Bytes
  tokenLogic_not: Bytes
  tokenLogic_gt: Bytes
  tokenLogic_lt: Bytes
  tokenLogic_gte: Bytes
  tokenLogic_lte: Bytes
  tokenLogic_in: [Bytes!]
  tokenLogic_not_in: [Bytes!]
  tokenLogic_contains: Bytes
  tokenLogic_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SuperTokenLogicCreatedEvent_filter]
  or: [SuperTokenLogicCreatedEvent_filter]
}

enum SuperTokenLogicCreatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  tokenLogic
}

type SuperTokenLogicUpdatedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  code: Bytes!
}

input SuperTokenLogicUpdatedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  code: Bytes
  code_not: Bytes
  code_gt: Bytes
  code_lt: Bytes
  code_gte: Bytes
  code_lte: Bytes
  code_in: [Bytes!]
  code_not_in: [Bytes!]
  code_contains: Bytes
  code_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SuperTokenLogicUpdatedEvent_filter]
  or: [SuperTokenLogicUpdatedEvent_filter]
}

enum SuperTokenLogicUpdatedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  code
}

type SuperTokenMinimumDepositChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  minimumDeposit: BigInt!
}

input SuperTokenMinimumDepositChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_gt: Bytes
  governanceAddress_lt: Bytes
  governanceAddress_gte: Bytes
  governanceAddress_lte: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_gt: Bytes
  host_lt: Bytes
  host_gte: Bytes
  host_lte: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_gt: Bytes
  superToken_lt: Bytes
  superToken_gte: Bytes
  superToken_lte: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  minimumDeposit: BigInt
  minimumDeposit_not: BigInt
  minimumDeposit_gt: BigInt
  minimumDeposit_lt: BigInt
  minimumDeposit_gte: BigInt
  minimumDeposit_lte: BigInt
  minimumDeposit_in: [BigInt!]
  minimumDeposit_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [SuperTokenMinimumDepositChangedEvent_filter]
  or: [SuperTokenMinimumDepositChangedEvent_filter]
}

enum SuperTokenMinimumDepositChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  isKeySet
  minimumDeposit
}

"""
Token: A higher order entity created for super tokens (and underlying tokens)
that are "valid" (tokens that have Superfluid's host contract address set as the host).

"""
type Token {
  """
  ID: the token address
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  decimals: Int!
  name: String!
  symbol: String!
  isSuperToken: Boolean!

  """
  A boolean indicating whether the token is a NativeAssetSuperToken.
  
  """
  isNativeAssetSuperToken: Boolean!

  """
  A boolean indicating whether the token is a part of our resolver list.
  
  """
  isListed: Boolean!

  """
  The address of the underlying ERC20 token (zero address for non-ERC20WrapperSuperToken's)
  
  """
  underlyingAddress: Bytes!

  """
  The underlying ERC20 token for a ERC20WrapperSuperToken otherwise null.
  
  """
  underlyingToken: Token
  governanceConfig: TokenGovernanceConfig
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  isSuperToken: Boolean
  isSuperToken_not: Boolean
  isSuperToken_in: [Boolean!]
  isSuperToken_not_in: [Boolean!]
  isNativeAssetSuperToken: Boolean
  isNativeAssetSuperToken_not: Boolean
  isNativeAssetSuperToken_in: [Boolean!]
  isNativeAssetSuperToken_not_in: [Boolean!]
  isListed: Boolean
  isListed_not: Boolean
  isListed_in: [Boolean!]
  isListed_not_in: [Boolean!]
  underlyingAddress: Bytes
  underlyingAddress_not: Bytes
  underlyingAddress_gt: Bytes
  underlyingAddress_lt: Bytes
  underlyingAddress_gte: Bytes
  underlyingAddress_lte: Bytes
  underlyingAddress_in: [Bytes!]
  underlyingAddress_not_in: [Bytes!]
  underlyingAddress_contains: Bytes
  underlyingAddress_not_contains: Bytes
  underlyingToken: String
  underlyingToken_not: String
  underlyingToken_gt: String
  underlyingToken_lt: String
  underlyingToken_gte: String
  underlyingToken_lte: String
  underlyingToken_in: [String!]
  underlyingToken_not_in: [String!]
  underlyingToken_contains: String
  underlyingToken_contains_nocase: String
  underlyingToken_not_contains: String
  underlyingToken_not_contains_nocase: String
  underlyingToken_starts_with: String
  underlyingToken_starts_with_nocase: String
  underlyingToken_not_starts_with: String
  underlyingToken_not_starts_with_nocase: String
  underlyingToken_ends_with: String
  underlyingToken_ends_with_nocase: String
  underlyingToken_not_ends_with: String
  underlyingToken_not_ends_with_nocase: String
  underlyingToken_: Token_filter
  governanceConfig: String
  governanceConfig_not: String
  governanceConfig_gt: String
  governanceConfig_lt: String
  governanceConfig_gte: String
  governanceConfig_lte: String
  governanceConfig_in: [String!]
  governanceConfig_not_in: [String!]
  governanceConfig_contains: String
  governanceConfig_contains_nocase: String
  governanceConfig_not_contains: String
  governanceConfig_not_contains_nocase: String
  governanceConfig_starts_with: String
  governanceConfig_starts_with_nocase: String
  governanceConfig_not_starts_with: String
  governanceConfig_not_starts_with_nocase: String
  governanceConfig_ends_with: String
  governanceConfig_ends_with_nocase: String
  governanceConfig_not_ends_with: String
  governanceConfig_not_ends_with_nocase: String
  governanceConfig_: TokenGovernanceConfig_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  decimals
  name
  symbol
  isSuperToken
  isNativeAssetSuperToken
  isListed
  underlyingAddress
  underlyingToken
  underlyingToken__id
  underlyingToken__createdAtTimestamp
  underlyingToken__createdAtBlockNumber
  underlyingToken__decimals
  underlyingToken__name
  underlyingToken__symbol
  underlyingToken__isSuperToken
  underlyingToken__isNativeAssetSuperToken
  underlyingToken__isListed
  underlyingToken__underlyingAddress
  governanceConfig
  governanceConfig__id
  governanceConfig__createdAtTimestamp
  governanceConfig__createdAtBlockNumber
  governanceConfig__updatedAtTimestamp
  governanceConfig__updatedAtBlockNumber
  governanceConfig__isDefault
  governanceConfig__rewardAddress
  governanceConfig__liquidationPeriod
  governanceConfig__patricianPeriod
  governanceConfig__minimumDeposit
}

type TokenDowngradedEvent implements Event {
  id: ID!
  account: Account!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `account`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  amount: BigInt!
}

input TokenDowngradedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenDowngradedEvent_filter]
  or: [TokenDowngradedEvent_filter]
}

enum TokenDowngradedEvent_orderBy {
  id
  account
  account__id
  account__createdAtTimestamp
  account__createdAtBlockNumber
  account__updatedAtTimestamp
  account__updatedAtBlockNumber
  account__isSuperApp
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  amount
}

"""
TokenGovernanceConfig: A higher order entity that represents the governance configs for a token.
If `id` is `address(0)`, it will be used as the default config.

"""
type TokenGovernanceConfig {
  """
  id is the address of the SuperToken
  NOTE: the zero address is reserved for the default config for all tokens with unset configs.
  
  """
  id: ID!
  createdAtTimestamp: BigInt!
  createdAtBlockNumber: BigInt!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  If true, `id` is `address(0)` and this is the default config for all tokens with unset configs.
  
  """
  isDefault: Boolean!

  """
  The (default or token-specific) address that receives liquidation rewards for
  a token prior to 3Ps and the TOGA address after 3Ps.
  
  """
  rewardAddress: Bytes

  """
  The (default or token-specific) liquidation period (buffer amount required for a token).
  This field can be used to calculate the liquidation buffer (or deposit) amount
  for a token: `liquidationBufferAmount = liquidationPeriod * flowRate`.
  Note that if `minimumDeposit` is set, the liquidation buffer amount will be the greater of the two values.
  
  """
  liquidationPeriod: BigInt

  """
  The (default or token-specific) patrician period, the patrician period is the
  window in which a patrician receives all rewards for a liquidation, no matter
  the liquidating account.
  
  """
  patricianPeriod: BigInt

  """
  The (default or token-specific) minimum deposit amount.
  
  """
  minimumDeposit: BigInt

  """
  A reverse lookup to the token it is associated with and null if it is the default config.
  
  """
  token: Token
}

input TokenGovernanceConfig_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  createdAtBlockNumber: BigInt
  createdAtBlockNumber_not: BigInt
  createdAtBlockNumber_gt: BigInt
  createdAtBlockNumber_lt: BigInt
  createdAtBlockNumber_gte: BigInt
  createdAtBlockNumber_lte: BigInt
  createdAtBlockNumber_in: [BigInt!]
  createdAtBlockNumber_not_in: [BigInt!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  isDefault: Boolean
  isDefault_not: Boolean
  isDefault_in: [Boolean!]
  isDefault_not_in: [Boolean!]
  rewardAddress: Bytes
  rewardAddress_not: Bytes
  rewardAddress_gt: Bytes
  rewardAddress_lt: Bytes
  rewardAddress_gte: Bytes
  rewardAddress_lte: Bytes
  rewardAddress_in: [Bytes!]
  rewardAddress_not_in: [Bytes!]
  rewardAddress_contains: Bytes
  rewardAddress_not_contains: Bytes
  liquidationPeriod: BigInt
  liquidationPeriod_not: BigInt
  liquidationPeriod_gt: BigInt
  liquidationPeriod_lt: BigInt
  liquidationPeriod_gte: BigInt
  liquidationPeriod_lte: BigInt
  liquidationPeriod_in: [BigInt!]
  liquidationPeriod_not_in: [BigInt!]
  patricianPeriod: BigInt
  patricianPeriod_not: BigInt
  patricianPeriod_gt: BigInt
  patricianPeriod_lt: BigInt
  patricianPeriod_gte: BigInt
  patricianPeriod_lte: BigInt
  patricianPeriod_in: [BigInt!]
  patricianPeriod_not_in: [BigInt!]
  minimumDeposit: BigInt
  minimumDeposit_not: BigInt
  minimumDeposit_gt: BigInt
  minimumDeposit_lt: BigInt
  minimumDeposit_gte: BigInt
  minimumDeposit_lte: BigInt
  minimumDeposit_in: [BigInt!]
  minimumDeposit_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenGovernanceConfig_filter]
  or: [TokenGovernanceConfig_filter]
}

enum TokenGovernanceConfig_orderBy {
  id
  createdAtTimestamp
  createdAtBlockNumber
  updatedAtTimestamp
  updatedAtBlockNumber
  isDefault
  rewardAddress
  liquidationPeriod
  patricianPeriod
  minimumDeposit
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
}

"""
TokenStatistic: An aggregate entity which contains aggregate data for `token`.

"""
type TokenStatistic {
  """
  id: `token` (superToken) address
  
  """
  id: ID!
  updatedAtTimestamp: BigInt!
  updatedAtBlockNumber: BigInt!

  """
  The total number of currently active `token` streams.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The count of closed streams for `token`.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The total number of Indexes created with `token`.
  
  """
  totalNumberOfIndexes: Int!

  """
  The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
  
  """
  totalNumberOfActiveIndexes: Int!

  """
  The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  The total deposit held by the CFA agreement for this particular `token`.
  
  """
  totalDeposit: BigInt!

  """
  The total outflow rate of the `token` (how much value is being moved).
  
  """
  totalOutflowRate: BigInt!

  """
  The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountStreamedUntilUpdatedAt: BigInt!

  """
  The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountTransferredUntilUpdatedAt: BigInt!

  """
  The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`.
  
  """
  totalAmountDistributedUntilUpdatedAt: BigInt!

  """
  The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
  
  """
  totalSupply: BigInt!
  token: Token!
  tokenStatisticLogs(skip: Int = 0, first: Int = 100, orderBy: TokenStatisticLog_orderBy, orderDirection: OrderDirection, where: TokenStatisticLog_filter): [TokenStatisticLog!]!
}

input TokenStatistic_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  updatedAtTimestamp: BigInt
  updatedAtTimestamp_not: BigInt
  updatedAtTimestamp_gt: BigInt
  updatedAtTimestamp_lt: BigInt
  updatedAtTimestamp_gte: BigInt
  updatedAtTimestamp_lte: BigInt
  updatedAtTimestamp_in: [BigInt!]
  updatedAtTimestamp_not_in: [BigInt!]
  updatedAtBlockNumber: BigInt
  updatedAtBlockNumber_not: BigInt
  updatedAtBlockNumber_gt: BigInt
  updatedAtBlockNumber_lt: BigInt
  updatedAtBlockNumber_gte: BigInt
  updatedAtBlockNumber_lte: BigInt
  updatedAtBlockNumber_in: [BigInt!]
  updatedAtBlockNumber_not_in: [BigInt!]
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  totalNumberOfIndexes: Int
  totalNumberOfIndexes_not: Int
  totalNumberOfIndexes_gt: Int
  totalNumberOfIndexes_lt: Int
  totalNumberOfIndexes_gte: Int
  totalNumberOfIndexes_lte: Int
  totalNumberOfIndexes_in: [Int!]
  totalNumberOfIndexes_not_in: [Int!]
  totalNumberOfActiveIndexes: Int
  totalNumberOfActiveIndexes_not: Int
  totalNumberOfActiveIndexes_gt: Int
  totalNumberOfActiveIndexes_lt: Int
  totalNumberOfActiveIndexes_gte: Int
  totalNumberOfActiveIndexes_lte: Int
  totalNumberOfActiveIndexes_in: [Int!]
  totalNumberOfActiveIndexes_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt: BigInt
  totalAmountStreamedUntilUpdatedAt_not: BigInt
  totalAmountStreamedUntilUpdatedAt_gt: BigInt
  totalAmountStreamedUntilUpdatedAt_lt: BigInt
  totalAmountStreamedUntilUpdatedAt_gte: BigInt
  totalAmountStreamedUntilUpdatedAt_lte: BigInt
  totalAmountStreamedUntilUpdatedAt_in: [BigInt!]
  totalAmountStreamedUntilUpdatedAt_not_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt: BigInt
  totalAmountTransferredUntilUpdatedAt_not: BigInt
  totalAmountTransferredUntilUpdatedAt_gt: BigInt
  totalAmountTransferredUntilUpdatedAt_lt: BigInt
  totalAmountTransferredUntilUpdatedAt_gte: BigInt
  totalAmountTransferredUntilUpdatedAt_lte: BigInt
  totalAmountTransferredUntilUpdatedAt_in: [BigInt!]
  totalAmountTransferredUntilUpdatedAt_not_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt: BigInt
  totalAmountDistributedUntilUpdatedAt_not: BigInt
  totalAmountDistributedUntilUpdatedAt_gt: BigInt
  totalAmountDistributedUntilUpdatedAt_lt: BigInt
  totalAmountDistributedUntilUpdatedAt_gte: BigInt
  totalAmountDistributedUntilUpdatedAt_lte: BigInt
  totalAmountDistributedUntilUpdatedAt_in: [BigInt!]
  totalAmountDistributedUntilUpdatedAt_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  tokenStatisticLogs_: TokenStatisticLog_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenStatistic_filter]
  or: [TokenStatistic_filter]
}

enum TokenStatistic_orderBy {
  id
  updatedAtTimestamp
  updatedAtBlockNumber
  totalNumberOfActiveStreams
  totalNumberOfClosedStreams
  totalNumberOfIndexes
  totalNumberOfActiveIndexes
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  totalDeposit
  totalOutflowRate
  totalAmountStreamedUntilUpdatedAt
  totalAmountTransferredUntilUpdatedAt
  totalAmountDistributedUntilUpdatedAt
  totalSupply
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  tokenStatisticLogs
}

"""
TokenStatisticLog: Historical entries of `TokenStatistic` updates.

"""
type TokenStatisticLog {
  id: ID!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  logIndex: BigInt!
  order: BigInt!
  triggeredByEventName: String!

  """
  The total number of currently active `token` streams.
  
  """
  totalNumberOfActiveStreams: Int!

  """
  The count of closed streams for `token`.
  
  """
  totalNumberOfClosedStreams: Int!

  """
  The total number of Indexes created with `token`.
  
  """
  totalNumberOfIndexes: Int!

  """
  The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
  
  """
  totalNumberOfActiveIndexes: Int!

  """
  The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
  
  """
  totalSubscriptionsWithUnits: Int!

  """
  Counts all approved subscriptions whether or not they have units.
  
  """
  totalApprovedSubscriptions: Int!

  """
  The total deposit held by the CFA agreement for this particular `token`.
  
  """
  totalDeposit: BigInt!

  """
  The total outflow rate of the `token` (how much value is being moved).
  
  """
  totalOutflowRate: BigInt!

  """
  The all-time total amount of `token` streamed (outflows) until the `timestamp`/`block`.
  
  """
  totalAmountStreamed: BigInt!

  """
  The all-time total amount of `token` transferred until the `timestamp`/`block`.
  
  """
  totalAmountTransferred: BigInt!

  """
  The all-time total amount of `token` distributed until the `timestamp`/`block`.
  
  """
  totalAmountDistributed: BigInt!

  """
  The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
  
  """
  totalSupply: BigInt!
  token: Token!
  tokenStatistic: TokenStatistic!
}

input TokenStatisticLog_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  triggeredByEventName: String
  triggeredByEventName_not: String
  triggeredByEventName_gt: String
  triggeredByEventName_lt: String
  triggeredByEventName_gte: String
  triggeredByEventName_lte: String
  triggeredByEventName_in: [String!]
  triggeredByEventName_not_in: [String!]
  triggeredByEventName_contains: String
  triggeredByEventName_contains_nocase: String
  triggeredByEventName_not_contains: String
  triggeredByEventName_not_contains_nocase: String
  triggeredByEventName_starts_with: String
  triggeredByEventName_starts_with_nocase: String
  triggeredByEventName_not_starts_with: String
  triggeredByEventName_not_starts_with_nocase: String
  triggeredByEventName_ends_with: String
  triggeredByEventName_ends_with_nocase: String
  triggeredByEventName_not_ends_with: String
  triggeredByEventName_not_ends_with_nocase: String
  totalNumberOfActiveStreams: Int
  totalNumberOfActiveStreams_not: Int
  totalNumberOfActiveStreams_gt: Int
  totalNumberOfActiveStreams_lt: Int
  totalNumberOfActiveStreams_gte: Int
  totalNumberOfActiveStreams_lte: Int
  totalNumberOfActiveStreams_in: [Int!]
  totalNumberOfActiveStreams_not_in: [Int!]
  totalNumberOfClosedStreams: Int
  totalNumberOfClosedStreams_not: Int
  totalNumberOfClosedStreams_gt: Int
  totalNumberOfClosedStreams_lt: Int
  totalNumberOfClosedStreams_gte: Int
  totalNumberOfClosedStreams_lte: Int
  totalNumberOfClosedStreams_in: [Int!]
  totalNumberOfClosedStreams_not_in: [Int!]
  totalNumberOfIndexes: Int
  totalNumberOfIndexes_not: Int
  totalNumberOfIndexes_gt: Int
  totalNumberOfIndexes_lt: Int
  totalNumberOfIndexes_gte: Int
  totalNumberOfIndexes_lte: Int
  totalNumberOfIndexes_in: [Int!]
  totalNumberOfIndexes_not_in: [Int!]
  totalNumberOfActiveIndexes: Int
  totalNumberOfActiveIndexes_not: Int
  totalNumberOfActiveIndexes_gt: Int
  totalNumberOfActiveIndexes_lt: Int
  totalNumberOfActiveIndexes_gte: Int
  totalNumberOfActiveIndexes_lte: Int
  totalNumberOfActiveIndexes_in: [Int!]
  totalNumberOfActiveIndexes_not_in: [Int!]
  totalSubscriptionsWithUnits: Int
  totalSubscriptionsWithUnits_not: Int
  totalSubscriptionsWithUnits_gt: Int
  totalSubscriptionsWithUnits_lt: Int
  totalSubscriptionsWithUnits_gte: Int
  totalSubscriptionsWithUnits_lte: Int
  totalSubscriptionsWithUnits_in: [Int!]
  totalSubscriptionsWithUnits_not_in: [Int!]
  totalApprovedSubscriptions: Int
  totalApprovedSubscriptions_not: Int
  totalApprovedSubscriptions_gt: Int
  totalApprovedSubscriptions_lt: Int
  totalApprovedSubscriptions_gte: Int
  totalApprovedSubscriptions_lte: Int
  totalApprovedSubscriptions_in: [Int!]
  totalApprovedSubscriptions_not_in: [Int!]
  totalDeposit: BigInt
  totalDeposit_not: BigInt
  totalDeposit_gt: BigInt
  totalDeposit_lt: BigInt
  totalDeposit_gte: BigInt
  totalDeposit_lte: BigInt
  totalDeposit_in: [BigInt!]
  totalDeposit_not_in: [BigInt!]
  totalOutflowRate: BigInt
  totalOutflowRate_not: BigInt
  totalOutflowRate_gt: BigInt
  totalOutflowRate_lt: BigInt
  totalOutflowRate_gte: BigInt
  totalOutflowRate_lte: BigInt
  totalOutflowRate_in: [BigInt!]
  totalOutflowRate_not_in: [BigInt!]
  totalAmountStreamed: BigInt
  totalAmountStreamed_not: BigInt
  totalAmountStreamed_gt: BigInt
  totalAmountStreamed_lt: BigInt
  totalAmountStreamed_gte: BigInt
  totalAmountStreamed_lte: BigInt
  totalAmountStreamed_in: [BigInt!]
  totalAmountStreamed_not_in: [BigInt!]
  totalAmountTransferred: BigInt
  totalAmountTransferred_not: BigInt
  totalAmountTransferred_gt: BigInt
  totalAmountTransferred_lt: BigInt
  totalAmountTransferred_gte: BigInt
  totalAmountTransferred_lte: BigInt
  totalAmountTransferred_in: [BigInt!]
  totalAmountTransferred_not_in: [BigInt!]
  totalAmountDistributed: BigInt
  totalAmountDistributed_not: BigInt
  totalAmountDistributed_gt: BigInt
  totalAmountDistributed_lt: BigInt
  totalAmountDistributed_gte: BigInt
  totalAmountDistributed_lte: BigInt
  totalAmountDistributed_in: [BigInt!]
  totalAmountDistributed_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  tokenStatistic: String
  tokenStatistic_not: String
  tokenStatistic_gt: String
  tokenStatistic_lt: String
  tokenStatistic_gte: String
  tokenStatistic_lte: String
  tokenStatistic_in: [String!]
  tokenStatistic_not_in: [String!]
  tokenStatistic_contains: String
  tokenStatistic_contains_nocase: String
  tokenStatistic_not_contains: String
  tokenStatistic_not_contains_nocase: String
  tokenStatistic_starts_with: String
  tokenStatistic_starts_with_nocase: String
  tokenStatistic_not_starts_with: String
  tokenStatistic_not_starts_with_nocase: String
  tokenStatistic_ends_with: String
  tokenStatistic_ends_with_nocase: String
  tokenStatistic_not_ends_with: String
  tokenStatistic_not_ends_with_nocase: String
  tokenStatistic_: TokenStatistic_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenStatisticLog_filter]
  or: [TokenStatisticLog_filter]
}

enum TokenStatisticLog_orderBy {
  id
  timestamp
  blockNumber
  transactionHash
  logIndex
  order
  triggeredByEventName
  totalNumberOfActiveStreams
  totalNumberOfClosedStreams
  totalNumberOfIndexes
  totalNumberOfActiveIndexes
  totalSubscriptionsWithUnits
  totalApprovedSubscriptions
  totalDeposit
  totalOutflowRate
  totalAmountStreamed
  totalAmountTransferred
  totalAmountDistributed
  totalSupply
  token
  token__id
  token__createdAtTimestamp
  token__createdAtBlockNumber
  token__decimals
  token__name
  token__symbol
  token__isSuperToken
  token__isNativeAssetSuperToken
  token__isListed
  token__underlyingAddress
  tokenStatistic
  tokenStatistic__id
  tokenStatistic__updatedAtTimestamp
  tokenStatistic__updatedAtBlockNumber
  tokenStatistic__totalNumberOfActiveStreams
  tokenStatistic__totalNumberOfClosedStreams
  tokenStatistic__totalNumberOfIndexes
  tokenStatistic__totalNumberOfActiveIndexes
  tokenStatistic__totalSubscriptionsWithUnits
  tokenStatistic__totalApprovedSubscriptions
  tokenStatistic__totalDeposit
  tokenStatistic__totalOutflowRate
  tokenStatistic__totalAmountStreamedUntilUpdatedAt
  tokenStatistic__totalAmountTransferredUntilUpdatedAt
  tokenStatistic__totalAmountDistributedUntilUpdatedAt
  tokenStatistic__totalSupply
}

type TokenUpgradedEvent implements Event {
  id: ID!
  account: Account!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `account`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  token: Bytes!
  amount: BigInt!
}

input TokenUpgradedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  account: String
  account_not: String
  account_gt: String
  account_lt: String
  account_gte: String
  account_lte: String
  account_in: [String!]
  account_not_in: [String!]
  account_contains: String
  account_contains_nocase: String
  account_not_contains: String
  account_not_contains_nocase: String
  account_starts_with: String
  account_starts_with_nocase: String
  account_not_starts_with: String
  account_not_starts_with_nocase: String
  account_ends_with: String
  account_ends_with_nocase: String
  account_not_ends_with: String
  account_not_ends_with_nocase: String
  account_: Account_filter
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenUpgradedEvent_filter]
  or: [TokenUpgradedEvent_filter]
}

enum TokenUpgradedEvent_orderBy {
  id
  account
  account__id
  account__createdAtTimestamp
  account__createdAtBlockNumber
  account__updatedAtTimestamp
  account__updatedAtBlockNumber
  account__isSuperApp
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  token
  amount
}

type TransferEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  Contains the addresses that were impacted by this event:
  addresses[0] = `token` (superToken)
  addresses[1] = `from`
  addresses[2] = `to`
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  from: Account!
  to: Account!
  value: BigInt!
  token: Bytes!
}

input TransferEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  from: String
  from_not: String
  from_gt: String
  from_lt: String
  from_gte: String
  from_lte: String
  from_in: [String!]
  from_not_in: [String!]
  from_contains: String
  from_contains_nocase: String
  from_not_contains: String
  from_not_contains_nocase: String
  from_starts_with: String
  from_starts_with_nocase: String
  from_not_starts_with: String
  from_not_starts_with_nocase: String
  from_ends_with: String
  from_ends_with_nocase: String
  from_not_ends_with: String
  from_not_ends_with_nocase: String
  from_: Account_filter
  to: String
  to_not: String
  to_gt: String
  to_lt: String
  to_gte: String
  to_lte: String
  to_in: [String!]
  to_not_in: [String!]
  to_contains: String
  to_contains_nocase: String
  to_not_contains: String
  to_not_contains_nocase: String
  to_starts_with: String
  to_starts_with_nocase: String
  to_not_starts_with: String
  to_not_starts_with_nocase: String
  to_ends_with: String
  to_ends_with_nocase: String
  to_not_ends_with: String
  to_not_ends_with_nocase: String
  to_: Account_filter
  value: BigInt
  value_not: BigInt
  value_gt: BigInt
  value_lt: BigInt
  value_gte: BigInt
  value_lte: BigInt
  value_in: [BigInt!]
  value_not_in: [BigInt!]
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TransferEvent_filter]
  or: [TransferEvent_filter]
}

enum TransferEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  addresses
  blockNumber
  logIndex
  order
  from
  from__id
  from__createdAtTimestamp
  from__createdAtBlockNumber
  from__updatedAtTimestamp
  from__updatedAtBlockNumber
  from__isSuperApp
  to
  to__id
  to__createdAtTimestamp
  to__createdAtBlockNumber
  to__updatedAtTimestamp
  to__updatedAtBlockNumber
  to__isSuperApp
  value
  token
}

type TrustedForwarderChangedEvent implements Event {
  id: ID!
  transactionHash: Bytes!
  gasPrice: BigInt!
  gasUsed: BigInt!
  timestamp: BigInt!
  name: String!

  """
  The address of the governance contract the event was emitted from.
  
  """
  governanceAddress: Bytes!

  """
  Empty addresses array.
  
  """
  addresses: [Bytes!]!
  blockNumber: BigInt!
  logIndex: BigInt!
  order: BigInt!
  host: Bytes!
  superToken: Bytes!
  isKeySet: Boolean!
  forwarder: Bytes!
  enabled: Boolean!
}

input TrustedForwarderChangedEvent_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  gasPrice: BigInt
  gasPrice_not: BigInt
  gasPrice_gt: BigInt
  gasPrice_lt: BigInt
  gasPrice_gte: BigInt
  gasPrice_lte: BigInt
  gasPrice_in: [BigInt!]
  gasPrice_not_in: [BigInt!]
  gasUsed: BigInt
  gasUsed_not: BigInt
  gasUsed_gt: BigInt
  gasUsed_lt: BigInt
  gasUsed_gte: BigInt
  gasUsed_lte: BigInt
  gasUsed_in: [BigInt!]
  gasUsed_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  governanceAddress: Bytes
  governanceAddress_not: Bytes
  governanceAddress_gt: Bytes
  governanceAddress_lt: Bytes
  governanceAddress_gte: Bytes
  governanceAddress_lte: Bytes
  governanceAddress_in: [Bytes!]
  governanceAddress_not_in: [Bytes!]
  governanceAddress_contains: Bytes
  governanceAddress_not_contains: Bytes
  addresses: [Bytes!]
  addresses_not: [Bytes!]
  addresses_contains: [Bytes!]
  addresses_contains_nocase: [Bytes!]
  addresses_not_contains: [Bytes!]
  addresses_not_contains_nocase: [Bytes!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  order: BigInt
  order_not: BigInt
  order_gt: BigInt
  order_lt: BigInt
  order_gte: BigInt
  order_lte: BigInt
  order_in: [BigInt!]
  order_not_in: [BigInt!]
  host: Bytes
  host_not: Bytes
  host_gt: Bytes
  host_lt: Bytes
  host_gte: Bytes
  host_lte: Bytes
  host_in: [Bytes!]
  host_not_in: [Bytes!]
  host_contains: Bytes
  host_not_contains: Bytes
  superToken: Bytes
  superToken_not: Bytes
  superToken_gt: Bytes
  superToken_lt: Bytes
  superToken_gte: Bytes
  superToken_lte: Bytes
  superToken_in: [Bytes!]
  superToken_not_in: [Bytes!]
  superToken_contains: Bytes
  superToken_not_contains: Bytes
  isKeySet: Boolean
  isKeySet_not: Boolean
  isKeySet_in: [Boolean!]
  isKeySet_not_in: [Boolean!]
  forwarder: Bytes
  forwarder_not: Bytes
  forwarder_gt: Bytes
  forwarder_lt: Bytes
  forwarder_gte: Bytes
  forwarder_lte: Bytes
  forwarder_in: [Bytes!]
  forwarder_not_in: [Bytes!]
  forwarder_contains: Bytes
  forwarder_not_contains: Bytes
  enabled: Boolean
  enabled_not: Boolean
  enabled_in: [Boolean!]
  enabled_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TrustedForwarderChangedEvent_filter]
  or: [TrustedForwarderChangedEvent_filter]
}

enum TrustedForwarderChangedEvent_orderBy {
  id
  transactionHash
  gasPrice
  gasUsed
  timestamp
  name
  governanceAddress
  addresses
  blockNumber
  logIndex
  order
  host
  superToken
  isKeySet
  forwarder
  enabled
}

