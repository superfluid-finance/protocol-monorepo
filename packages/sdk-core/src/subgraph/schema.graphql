# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"""

Event: An interface which is shared by all
event entities and contains basic transaction
data.
"""
interface Event {
    """

    Holds the addresses for accounts that were impacted by the event.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    timestamp: BigInt!
    transactionHash: Bytes!
}

"""

Account: A HOL entity created for any addresses which interact with
Superfluid contracts.
"""
type Account {
    accountTokenSnapshots(first: Int = 100, orderBy: AccountTokenSnapshot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: AccountTokenSnapshot_filter): [AccountTokenSnapshot!]!
    createdAtBlockNumber: BigInt!
    createdAtTimestamp: BigInt!
    id: ID!
    inflows(first: Int = 100, orderBy: Stream_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Stream_filter): [Stream!]!
    """

    Indicates whether the address/account is a super app.
    """
    isSuperApp: Boolean!
    outflows(first: Int = 100, orderBy: Stream_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Stream_filter): [Stream!]!
    publishedIndexes(first: Int = 100, orderBy: Index_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Index_filter): [Index!]!
    receivedTransferEvents(first: Int = 100, orderBy: TransferEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TransferEvent_filter): [TransferEvent!]!
    sentTransferEvents(first: Int = 100, orderBy: TransferEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TransferEvent_filter): [TransferEvent!]!
    subscriptions(first: Int = 100, orderBy: IndexSubscription_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: IndexSubscription_filter): [IndexSubscription!]!
    tokenDowngradedEvents(first: Int = 100, orderBy: TokenDowngradedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenDowngradedEvent_filter): [TokenDowngradedEvent!]!
    tokenUpgradedEvents(first: Int = 100, orderBy: TokenUpgradedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenUpgradedEvent_filter): [TokenUpgradedEvent!]!
    updatedAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
}

"""

AccountTokenSnapshot: An aggregate entity which aggregates data on an account's
interaction with a `token`.
"""
type AccountTokenSnapshot {
    account: Account!
    """

    Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
    """
    balanceUntilUpdatedAt: BigInt!
    """

    ID composed of: accountID-tokenID
    """
    id: ID!
    token: Token!
    """

    The total amount of `token` streamed to this `account` until
    the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountStreamedUntilUpdatedAt: BigInt!
    """

    The total amount of `token` this `account` has transferred.
    """
    totalAmountTransferredUntilUpdatedAt: BigInt!
    """

    Counts all currently (as of updatedAt) approved subscriptions whether or not they have units.
    """
    totalApprovedSubscriptions: Int!
    """

    The total inflow rate (receive flowRate per second) of the `account`.
    """
    totalInflowRate: BigInt!
    """

    The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalNetFlowRate: BigInt!
    """

    The number of currently open streams.
    """
    totalNumberOfActiveStreams: Int!
    """

    The number of all-time closed streams.
    """
    totalNumberOfClosedStreams: Int!
    """

    The total outflow rate (send flowrate per second) of the `account`.
    """
    totalOutflowRate: BigInt!
    """

    The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`.
    """
    totalSubscriptionsWithUnits: Int!
    updatedAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
}

type AgreementClassRegisteredEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    agreementType: Bytes!
    blockNumber: BigInt!
    code: Bytes!
    id: ID!
    name: String!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type AgreementClassUpdatedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    agreementType: Bytes!
    blockNumber: BigInt!
    code: Bytes!
    id: ID!
    name: String!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type AgreementLiquidatedByEvent implements Event {
    """

    Holds the token, liquidatorAccount, penaltyAccount and bondAccount addresses.
    """
    addresses: [Bytes!]!
    agreementClass: Bytes!
    agreementId: Bytes!
    bailoutAmount: BigInt!
    blockNumber: BigInt!
    bondAccount: Bytes!
    id: ID!
    liquidatorAccount: Bytes!
    name: String!
    penaltyAccount: Bytes!
    rewardAmount: BigInt!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

type AppRegisteredEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    app: Bytes!
    blockNumber: BigInt!
    id: ID!
    name: String!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type BurnedEvent implements Event {
    """

    Holds the token and from addresses.
    """
    addresses: [Bytes!]!
    amount: BigInt!
    blockNumber: BigInt!
    data: Bytes!
    from: Bytes!
    id: ID!
    name: String!
    operator: Bytes!
    operatorData: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type CFAv1LiquidationPeriodChangedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    host: Bytes!
    id: ID!
    isSet: Boolean!
    liquidationPeriod: BigInt!
    name: String!
    superToken: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type ConfigChangedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    host: Bytes!
    id: ID!
    isSet: Boolean!
    key: Bytes!
    name: String!
    superToken: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
    value: BigInt!
}

type CustomSuperTokenCreatedEvent implements Event {
    """

    Holds the token address.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

"""

FlowUpdated: An `Event` entity that is emitted
when a flow is created, updated, or deleted.
"""
type FlowUpdatedEvent implements Event {
    """

    Holds the token, sender and receiver addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    """

    The flow rate per second.
    """
    flowRate: BigInt!
    id: ID!
    name: String!
    """

    The previous flow rate.
    """
    oldFlowRate: BigInt!
    receiver: Bytes!
    sender: Bytes!
    """

    The stream entity which is being modified.
    """
    stream: Stream!
    timestamp: BigInt!
    """

    The address of the `token` being streamed.
    """
    token: Bytes!
    """

    The total amount streamed until the timestamp
    for the Stream entity linked to this event.
    """
    totalAmountStreamedUntilTimestamp: BigInt!
    totalReceiverFlowRate: BigInt!
    totalSenderFlowRate: BigInt!
    transactionHash: Bytes!
    """

    The "type" of the `FlowUpdated` event.
    0 = create
    1 = update
    2 = terminate
    """
    type: Int!
    userData: Bytes!
}

type GovernanceReplacedEvent implements Event {
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    newGovernance: Bytes!
    """

    Empty addresses array.
    """
    oldGovernance: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

"""

Index: A Index HOL entity.
"""
type Index {
    createdAtBlockNumber: BigInt!
    createdAtTimestamp: BigInt!
    """

    ID composed of: publisherAddress-tokenAddress-indexId
    """
    id: ID!
    """

    IndexCreated event, there will only be one.
    """
    indexCreatedEvent: IndexCreatedEvent!
    indexDistributionClaimedEvents(first: Int = 100, orderBy: IndexDistributionClaimedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: IndexDistributionClaimedEvent_filter): [IndexDistributionClaimedEvent!]!
    """

    indexId is not the id of the `Index` entity.
    """
    indexId: BigInt!
    indexSubscribedEvents(first: Int = 100, orderBy: IndexSubscribedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: IndexSubscribedEvent_filter): [IndexSubscribedEvent!]!
    indexUnitsUpdatedEvents(first: Int = 100, orderBy: IndexUnitsUpdatedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: IndexUnitsUpdatedEvent_filter): [IndexUnitsUpdatedEvent!]!
    indexUnsubscribedEvents(first: Int = 100, orderBy: IndexUnsubscribedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: IndexUnsubscribedEvent_filter): [IndexUnsubscribedEvent!]!
    indexUpdatedEvents(first: Int = 100, orderBy: IndexUpdatedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: IndexUpdatedEvent_filter): [IndexUpdatedEvent!]!
    indexValue: BigInt!
    publisher: Account!
    """

    The subscriptions of the index, it will include approved, unapproved
    and deleted subscriptions.
    """
    subscriptions(first: Int = 100, orderBy: IndexSubscription_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: IndexSubscription_filter): [IndexSubscription!]!
    token: Token!
    """

    The total amount distributed from this `Index`.
    """
    totalAmountDistributedUntilUpdatedAt: BigInt!
    """

    The number of subscriptions which have units allocated to them on the `Index`.
    """
    totalSubscriptionsWithUnits: Int!
    """

    The sum of `totalUnitsPending` and `totalUnitsApproved`.
    """
    totalUnits: BigInt!
    """

    The number of units allocated by the `Index` that are approved.
    This refers to the current (as of updatedAt) `totalUnitsApproved`
    - not all that has ever been approved.
    """
    totalUnitsApproved: BigInt!
    """

    The number of units allocated by the `Index` that are pending.
    This refers to the current (as of updatedAt) `totalUnitsPending`
    - not all that has ever been pending.
    """
    totalUnitsPending: BigInt!
    updatedAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
}

type IndexCreatedEvent implements Event {
    """

    Holds the token and publisher addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    index: Index!
    indexId: BigInt!
    name: String!
    publisher: Bytes!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
    userData: Bytes!
}

type IndexDistributionClaimedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    amount: BigInt!
    blockNumber: BigInt!
    id: ID!
    index: Index!
    indexId: BigInt!
    name: String!
    publisher: Bytes!
    subscriber: Bytes!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

type IndexSubscribedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    index: Index!
    indexId: BigInt!
    name: String!
    publisher: Bytes!
    subscriber: Bytes!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
    userData: Bytes!
}

"""

IndexSubscription: A HOL entity that contains subscription data for a `subscriber` account of a particular
`Index`.
"""
type IndexSubscription {
    """

    Approved subscriptions don't require subscribers to claim tokens that are distributed from
    the publisher.
    """
    approved: Boolean!
    createdAtBlockNumber: BigInt!
    createdAtTimestamp: BigInt!
    """

    ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId
    """
    id: ID!
    index: Index!
    """

    The previous index value - used to calculate `totalAmountReceivedUntilUpdatedAt` field as of the
    `index.updatedAtTimestamp`. The formula to get this value is:
    `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue - indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
    """
    indexValueUntilUpdatedAt: BigInt!
    subscriber: Account!
    """

    IndexSubscription approved events on the subscription.
    """
    subscriptionApprovedEvents(first: Int = 100, orderBy: SubscriptionApprovedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: SubscriptionApprovedEvent_filter): [SubscriptionApprovedEvent!]!
    subscriptionDistributionClaimedEvents(first: Int = 100, orderBy: SubscriptionDistributionClaimedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: SubscriptionDistributionClaimedEvent_filter): [SubscriptionDistributionClaimedEvent!]!
    subscriptionRevokedEvents(first: Int = 100, orderBy: SubscriptionRevokedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: SubscriptionRevokedEvent_filter): [SubscriptionRevokedEvent!]!
    subscriptionUnitsUpdatedEvents(first: Int = 100, orderBy: SubscriptionUnitsUpdatedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: SubscriptionUnitsUpdatedEvent_filter): [SubscriptionUnitsUpdatedEvent!]!
    """

    The total amount of tokens you've received via IDA until
    `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountReceivedUntilUpdatedAt: BigInt!
    """

    If units is 0, it indicates that the subscription is "deleted". They are no longer
    subscribed to the index.
    """
    units: BigInt!
    updatedAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
}

type IndexUnitsUpdatedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    index: Index!
    indexId: BigInt!
    name: String!
    oldUnits: BigInt!
    publisher: Bytes!
    subscriber: Bytes!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
    units: BigInt!
    userData: Bytes!
}

type IndexUnsubscribedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    index: Index!
    indexId: BigInt!
    name: String!
    publisher: Bytes!
    subscriber: Bytes!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
    userData: Bytes!
}

type IndexUpdatedEvent implements Event {
    """

    Holds the token and publisher addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    index: Index!
    indexId: BigInt!
    name: String!
    newIndexValue: BigInt!
    oldIndexValue: BigInt!
    publisher: Bytes!
    timestamp: BigInt!
    token: Bytes!
    totalUnitsApproved: BigInt!
    totalUnitsPending: BigInt!
    transactionHash: Bytes!
    userData: Bytes!
}

type JailEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    app: Bytes!
    blockNumber: BigInt!
    id: ID!
    name: String!
    reason: BigInt!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type MintedEvent implements Event {
    """

    Holds the token, operator and to addresses.
    """
    addresses: [Bytes!]!
    amount: BigInt!
    blockNumber: BigInt!
    data: Bytes!
    id: ID!
    name: String!
    operator: Bytes!
    operatorData: Bytes!
    timestamp: BigInt!
    to: Bytes!
    transactionHash: Bytes!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accountTokenSnapshot(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountTokenSnapshot
    accountTokenSnapshots(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountTokenSnapshot_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AccountTokenSnapshot_filter
    ): [AccountTokenSnapshot!]!
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    agreementClassRegisteredEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AgreementClassRegisteredEvent
    agreementClassRegisteredEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AgreementClassRegisteredEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AgreementClassRegisteredEvent_filter
    ): [AgreementClassRegisteredEvent!]!
    agreementClassUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AgreementClassUpdatedEvent
    agreementClassUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AgreementClassUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AgreementClassUpdatedEvent_filter
    ): [AgreementClassUpdatedEvent!]!
    agreementLiquidatedByEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AgreementLiquidatedByEvent
    agreementLiquidatedByEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AgreementLiquidatedByEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AgreementLiquidatedByEvent_filter
    ): [AgreementLiquidatedByEvent!]!
    appRegisteredEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AppRegisteredEvent
    appRegisteredEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AppRegisteredEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AppRegisteredEvent_filter
    ): [AppRegisteredEvent!]!
    burnedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BurnedEvent
    burnedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BurnedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BurnedEvent_filter
    ): [BurnedEvent!]!
    cfav1LiquidationPeriodChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CFAv1LiquidationPeriodChangedEvent
    cfav1LiquidationPeriodChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CFAv1LiquidationPeriodChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CFAv1LiquidationPeriodChangedEvent_filter
    ): [CFAv1LiquidationPeriodChangedEvent!]!
    configChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ConfigChangedEvent
    configChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ConfigChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ConfigChangedEvent_filter
    ): [ConfigChangedEvent!]!
    customSuperTokenCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CustomSuperTokenCreatedEvent
    customSuperTokenCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CustomSuperTokenCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CustomSuperTokenCreatedEvent_filter
    ): [CustomSuperTokenCreatedEvent!]!
    event(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Event
    events(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Event_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Event_filter
    ): [Event!]!
    flowUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FlowUpdatedEvent
    flowUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FlowUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FlowUpdatedEvent_filter
    ): [FlowUpdatedEvent!]!
    governanceReplacedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GovernanceReplacedEvent
    governanceReplacedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GovernanceReplacedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GovernanceReplacedEvent_filter
    ): [GovernanceReplacedEvent!]!
    index(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Index
    indexCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexCreatedEvent
    indexCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexCreatedEvent_filter
    ): [IndexCreatedEvent!]!
    indexDistributionClaimedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexDistributionClaimedEvent
    indexDistributionClaimedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexDistributionClaimedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexDistributionClaimedEvent_filter
    ): [IndexDistributionClaimedEvent!]!
    indexSubscribedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexSubscribedEvent
    indexSubscribedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexSubscribedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexSubscribedEvent_filter
    ): [IndexSubscribedEvent!]!
    indexSubscription(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexSubscription
    indexSubscriptions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexSubscription_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexSubscription_filter
    ): [IndexSubscription!]!
    indexUnitsUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexUnitsUpdatedEvent
    indexUnitsUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexUnitsUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexUnitsUpdatedEvent_filter
    ): [IndexUnitsUpdatedEvent!]!
    indexUnsubscribedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexUnsubscribedEvent
    indexUnsubscribedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexUnsubscribedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexUnsubscribedEvent_filter
    ): [IndexUnsubscribedEvent!]!
    indexUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexUpdatedEvent
    indexUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexUpdatedEvent_filter
    ): [IndexUpdatedEvent!]!
    indexes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Index_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Index_filter
    ): [Index!]!
    jailEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): JailEvent
    jailEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: JailEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: JailEvent_filter
    ): [JailEvent!]!
    mintedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MintedEvent
    mintedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MintedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MintedEvent_filter
    ): [MintedEvent!]!
    rewardAddressChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardAddressChangedEvent
    rewardAddressChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RewardAddressChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RewardAddressChangedEvent_filter
    ): [RewardAddressChangedEvent!]!
    roleAdminChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleAdminChangedEvent
    roleAdminChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleAdminChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleAdminChangedEvent_filter
    ): [RoleAdminChangedEvent!]!
    roleGrantedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleGrantedEvent
    roleGrantedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleGrantedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleGrantedEvent_filter
    ): [RoleGrantedEvent!]!
    roleRevokedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleRevokedEvent
    roleRevokedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleRevokedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleRevokedEvent_filter
    ): [RoleRevokedEvent!]!
    sentEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SentEvent
    sentEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SentEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SentEvent_filter
    ): [SentEvent!]!
    sfmeta(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SFMeta
    sfmetas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SFMeta_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SFMeta_filter
    ): [SFMeta!]!
    stream(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Stream
    streamPeriod(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StreamPeriod
    streamPeriods(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StreamPeriod_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StreamPeriod_filter
    ): [StreamPeriod!]!
    streamRevision(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StreamRevision
    streamRevisions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StreamRevision_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StreamRevision_filter
    ): [StreamRevision!]!
    streams(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Stream_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Stream_filter
    ): [Stream!]!
    subscriptionApprovedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionApprovedEvent
    subscriptionApprovedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionApprovedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionApprovedEvent_filter
    ): [SubscriptionApprovedEvent!]!
    subscriptionDistributionClaimedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionDistributionClaimedEvent
    subscriptionDistributionClaimedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionDistributionClaimedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionDistributionClaimedEvent_filter
    ): [SubscriptionDistributionClaimedEvent!]!
    subscriptionRevokedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionRevokedEvent
    subscriptionRevokedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionRevokedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionRevokedEvent_filter
    ): [SubscriptionRevokedEvent!]!
    subscriptionUnitsUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionUnitsUpdatedEvent
    subscriptionUnitsUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionUnitsUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionUnitsUpdatedEvent_filter
    ): [SubscriptionUnitsUpdatedEvent!]!
    superTokenCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenCreatedEvent
    superTokenCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenCreatedEvent_filter
    ): [SuperTokenCreatedEvent!]!
    superTokenFactoryUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenFactoryUpdatedEvent
    superTokenFactoryUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenFactoryUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenFactoryUpdatedEvent_filter
    ): [SuperTokenFactoryUpdatedEvent!]!
    superTokenLogicCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenLogicCreatedEvent
    superTokenLogicCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenLogicCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenLogicCreatedEvent_filter
    ): [SuperTokenLogicCreatedEvent!]!
    superTokenLogicUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenLogicUpdatedEvent
    superTokenLogicUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenLogicUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenLogicUpdatedEvent_filter
    ): [SuperTokenLogicUpdatedEvent!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenDowngradedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenDowngradedEvent
    tokenDowngradedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenDowngradedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenDowngradedEvent_filter
    ): [TokenDowngradedEvent!]!
    tokenStatistic(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenStatistic
    tokenStatistics(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenStatistic_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenStatistic_filter
    ): [TokenStatistic!]!
    tokenUpgradedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenUpgradedEvent
    tokenUpgradedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenUpgradedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenUpgradedEvent_filter
    ): [TokenUpgradedEvent!]!
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
    transferEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TransferEvent
    transferEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TransferEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TransferEvent_filter
    ): [TransferEvent!]!
    trustedForwarderChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TrustedForwarderChangedEvent
    trustedForwarderChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TrustedForwarderChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TrustedForwarderChangedEvent_filter
    ): [TrustedForwarderChangedEvent!]!
}

type RewardAddressChangedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    host: Bytes!
    id: ID!
    isSet: Boolean!
    name: String!
    rewardAddress: Bytes!
    superToken: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type RoleAdminChangedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    newAdminRole: Bytes!
    previousAdminRole: Bytes!
    role: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type RoleGrantedEvent implements Event {
    account: Bytes!
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    role: Bytes!
    sender: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type RoleRevokedEvent implements Event {
    account: Bytes!
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    role: Bytes!
    sender: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type SFMeta {
    blockNumber: BigInt!
    """

    The branch the current deployment is coming from.
    """
    branch: String!
    """

    Whether the branch is feature/dev/v1.
    """
    configuration: String!
    """

    The id is the commit hash.
    """
    id: ID!
    """

    The release tag if it exists.
    """
    tag: String
    timestamp: BigInt!
}

type SentEvent implements Event {
    """

    Holds the token, operator and from addresses.
    """
    addresses: [Bytes!]!
    amount: BigInt!
    blockNumber: BigInt!
    data: Bytes!
    id: ID!
    name: String!
    operator: Bytes!
    operatorData: Bytes!
    timestamp: BigInt!
    to: Bytes!
    transactionHash: Bytes!
}

"""

Stream: A HOL entity that represents the lifetime of a stream between a `sender` and a `receiver`.
A account can start a stream, update the flow rate, but when they close it, it is
considered "dead". The next stream you create with the same `sender` and `receiver`
will create a new stream entity. Therefore, multiple stream entities can be created
between the same `sender` and `receiver`.
"""
type Stream {
    createdAtBlockNumber: BigInt!
    createdAtTimestamp: BigInt!
    currentFlowRate: BigInt!
    flowUpdatedEvents(first: Int = 100, orderBy: FlowUpdatedEvent_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: FlowUpdatedEvent_filter): [FlowUpdatedEvent!]!
    """

    ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex
    """
    id: ID!
    receiver: Account!
    sender: Account!
    streamPeriods(first: Int = 100, orderBy: StreamPeriod_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: StreamPeriod_filter): [StreamPeriod!]!
    """

    The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`. The formula to get the current streamed
    amount is:
    `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
    """
    streamedUntilUpdatedAt: BigInt!
    token: Token!
    updatedAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
}

"""

StreamPeriod: A HOL entity that represents a period of time in a Stream with a constant flowRate.
"""
type StreamPeriod {
    flowRate: BigInt!
    """

    ID composed of: streamId - periodRevisionIndex
    """
    id: ID!
    receiver: Account!
    sender: Account!
    startedAtBlockNumber: BigInt!
    startedAtEvent: FlowUpdatedEvent!
    startedAtTimestamp: BigInt!
    stoppedAtBlockNumber: BigInt
    stoppedAtEvent: FlowUpdatedEvent
    """

    Following values are null until the StreamPeriod is terminated
    """
    stoppedAtTimestamp: BigInt
    stream: Stream!
    token: Token!
    totalAmountStreamed: BigInt
}

type StreamRevision {
    id: ID!
    periodRevisionIndex: Int!
    revisionIndex: Int!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accountTokenSnapshot(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountTokenSnapshot
    accountTokenSnapshots(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountTokenSnapshot_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AccountTokenSnapshot_filter
    ): [AccountTokenSnapshot!]!
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    agreementClassRegisteredEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AgreementClassRegisteredEvent
    agreementClassRegisteredEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AgreementClassRegisteredEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AgreementClassRegisteredEvent_filter
    ): [AgreementClassRegisteredEvent!]!
    agreementClassUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AgreementClassUpdatedEvent
    agreementClassUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AgreementClassUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AgreementClassUpdatedEvent_filter
    ): [AgreementClassUpdatedEvent!]!
    agreementLiquidatedByEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AgreementLiquidatedByEvent
    agreementLiquidatedByEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AgreementLiquidatedByEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AgreementLiquidatedByEvent_filter
    ): [AgreementLiquidatedByEvent!]!
    appRegisteredEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AppRegisteredEvent
    appRegisteredEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AppRegisteredEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AppRegisteredEvent_filter
    ): [AppRegisteredEvent!]!
    burnedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BurnedEvent
    burnedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BurnedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BurnedEvent_filter
    ): [BurnedEvent!]!
    cfav1LiquidationPeriodChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CFAv1LiquidationPeriodChangedEvent
    cfav1LiquidationPeriodChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CFAv1LiquidationPeriodChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CFAv1LiquidationPeriodChangedEvent_filter
    ): [CFAv1LiquidationPeriodChangedEvent!]!
    configChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ConfigChangedEvent
    configChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ConfigChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ConfigChangedEvent_filter
    ): [ConfigChangedEvent!]!
    customSuperTokenCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CustomSuperTokenCreatedEvent
    customSuperTokenCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CustomSuperTokenCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CustomSuperTokenCreatedEvent_filter
    ): [CustomSuperTokenCreatedEvent!]!
    event(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Event
    events(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Event_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Event_filter
    ): [Event!]!
    flowUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): FlowUpdatedEvent
    flowUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: FlowUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: FlowUpdatedEvent_filter
    ): [FlowUpdatedEvent!]!
    governanceReplacedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GovernanceReplacedEvent
    governanceReplacedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GovernanceReplacedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GovernanceReplacedEvent_filter
    ): [GovernanceReplacedEvent!]!
    index(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Index
    indexCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexCreatedEvent
    indexCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexCreatedEvent_filter
    ): [IndexCreatedEvent!]!
    indexDistributionClaimedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexDistributionClaimedEvent
    indexDistributionClaimedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexDistributionClaimedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexDistributionClaimedEvent_filter
    ): [IndexDistributionClaimedEvent!]!
    indexSubscribedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexSubscribedEvent
    indexSubscribedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexSubscribedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexSubscribedEvent_filter
    ): [IndexSubscribedEvent!]!
    indexSubscription(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexSubscription
    indexSubscriptions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexSubscription_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexSubscription_filter
    ): [IndexSubscription!]!
    indexUnitsUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexUnitsUpdatedEvent
    indexUnitsUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexUnitsUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexUnitsUpdatedEvent_filter
    ): [IndexUnitsUpdatedEvent!]!
    indexUnsubscribedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexUnsubscribedEvent
    indexUnsubscribedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexUnsubscribedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexUnsubscribedEvent_filter
    ): [IndexUnsubscribedEvent!]!
    indexUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): IndexUpdatedEvent
    indexUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: IndexUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: IndexUpdatedEvent_filter
    ): [IndexUpdatedEvent!]!
    indexes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Index_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Index_filter
    ): [Index!]!
    jailEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): JailEvent
    jailEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: JailEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: JailEvent_filter
    ): [JailEvent!]!
    mintedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): MintedEvent
    mintedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: MintedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: MintedEvent_filter
    ): [MintedEvent!]!
    rewardAddressChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RewardAddressChangedEvent
    rewardAddressChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RewardAddressChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RewardAddressChangedEvent_filter
    ): [RewardAddressChangedEvent!]!
    roleAdminChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleAdminChangedEvent
    roleAdminChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleAdminChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleAdminChangedEvent_filter
    ): [RoleAdminChangedEvent!]!
    roleGrantedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleGrantedEvent
    roleGrantedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleGrantedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleGrantedEvent_filter
    ): [RoleGrantedEvent!]!
    roleRevokedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RoleRevokedEvent
    roleRevokedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RoleRevokedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RoleRevokedEvent_filter
    ): [RoleRevokedEvent!]!
    sentEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SentEvent
    sentEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SentEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SentEvent_filter
    ): [SentEvent!]!
    sfmeta(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SFMeta
    sfmetas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SFMeta_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SFMeta_filter
    ): [SFMeta!]!
    stream(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Stream
    streamPeriod(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StreamPeriod
    streamPeriods(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StreamPeriod_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StreamPeriod_filter
    ): [StreamPeriod!]!
    streamRevision(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): StreamRevision
    streamRevisions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: StreamRevision_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: StreamRevision_filter
    ): [StreamRevision!]!
    streams(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Stream_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Stream_filter
    ): [Stream!]!
    subscriptionApprovedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionApprovedEvent
    subscriptionApprovedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionApprovedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionApprovedEvent_filter
    ): [SubscriptionApprovedEvent!]!
    subscriptionDistributionClaimedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionDistributionClaimedEvent
    subscriptionDistributionClaimedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionDistributionClaimedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionDistributionClaimedEvent_filter
    ): [SubscriptionDistributionClaimedEvent!]!
    subscriptionRevokedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionRevokedEvent
    subscriptionRevokedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionRevokedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionRevokedEvent_filter
    ): [SubscriptionRevokedEvent!]!
    subscriptionUnitsUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SubscriptionUnitsUpdatedEvent
    subscriptionUnitsUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SubscriptionUnitsUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SubscriptionUnitsUpdatedEvent_filter
    ): [SubscriptionUnitsUpdatedEvent!]!
    superTokenCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenCreatedEvent
    superTokenCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenCreatedEvent_filter
    ): [SuperTokenCreatedEvent!]!
    superTokenFactoryUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenFactoryUpdatedEvent
    superTokenFactoryUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenFactoryUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenFactoryUpdatedEvent_filter
    ): [SuperTokenFactoryUpdatedEvent!]!
    superTokenLogicCreatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenLogicCreatedEvent
    superTokenLogicCreatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenLogicCreatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenLogicCreatedEvent_filter
    ): [SuperTokenLogicCreatedEvent!]!
    superTokenLogicUpdatedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): SuperTokenLogicUpdatedEvent
    superTokenLogicUpdatedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: SuperTokenLogicUpdatedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: SuperTokenLogicUpdatedEvent_filter
    ): [SuperTokenLogicUpdatedEvent!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenDowngradedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenDowngradedEvent
    tokenDowngradedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenDowngradedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenDowngradedEvent_filter
    ): [TokenDowngradedEvent!]!
    tokenStatistic(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenStatistic
    tokenStatistics(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenStatistic_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenStatistic_filter
    ): [TokenStatistic!]!
    tokenUpgradedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenUpgradedEvent
    tokenUpgradedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenUpgradedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenUpgradedEvent_filter
    ): [TokenUpgradedEvent!]!
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
    transferEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TransferEvent
    transferEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TransferEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TransferEvent_filter
    ): [TransferEvent!]!
    trustedForwarderChangedEvent(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TrustedForwarderChangedEvent
    trustedForwarderChangedEvents(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TrustedForwarderChangedEvent_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TrustedForwarderChangedEvent_filter
    ): [TrustedForwarderChangedEvent!]!
}

type SubscriptionApprovedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    indexId: BigInt!
    name: String!
    publisher: Bytes!
    subscriber: Bytes!
    subscription: IndexSubscription!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
    userData: Bytes!
}

type SubscriptionDistributionClaimedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    amount: BigInt!
    blockNumber: BigInt!
    id: ID!
    indexId: BigInt!
    name: String!
    publisher: Bytes!
    subscriber: Bytes!
    subscription: IndexSubscription!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

type SubscriptionRevokedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    indexId: BigInt!
    name: String!
    publisher: Bytes!
    subscriber: Bytes!
    subscription: IndexSubscription!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
    userData: Bytes!
}

type SubscriptionUnitsUpdatedEvent implements Event {
    """

    Holds the token, publisher and subscriber addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    indexId: BigInt!
    name: String!
    oldUnits: BigInt!
    publisher: Bytes!
    subscriber: Bytes!
    subscription: IndexSubscription!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
    units: BigInt!
    userData: Bytes!
}

type SuperTokenCreatedEvent implements Event {
    """

    Holds the token address.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

type SuperTokenFactoryUpdatedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    newFactory: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type SuperTokenLogicCreatedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    id: ID!
    name: String!
    timestamp: BigInt!
    tokenLogic: Bytes!
    transactionHash: Bytes!
}

type SuperTokenLogicUpdatedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    code: Bytes!
    id: ID!
    name: String!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

"""

Token: A HOL entity created for super tokens that are "valid" (tokens that have
Superfluid's host contract address set as the host).
"""
type Token {
    createdAtBlockNumber: BigInt!
    createdAtTimestamp: BigInt!
    decimals: Int!
    """

    ID: the token address
    """
    id: ID!
    """

    This indicates whether the token is a part of our resolver list.
    """
    isListed: Boolean!
    isSuperToken: Boolean!
    name: String!
    symbol: String!
    """

    The address of the underlying ERC20 token.
    """
    underlyingAddress: Bytes!
    """

    The underlying ERC20 token for a SuperToken or
    null for a regular ERC20 token.
    """
    underlyingToken: Token
}

type TokenDowngradedEvent implements Event {
    account: Account!
    """

    Holds the token and account addresses.
    """
    addresses: [Bytes!]!
    amount: BigInt!
    blockNumber: BigInt!
    id: ID!
    name: String!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

"""

TokenStatistic: An aggregate entity which aggregates data of a single `token`.
"""
type TokenStatistic {
    """

    ID: tokenID
    """
    id: ID!
    token: Token!
    """

    The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountDistributedUntilUpdatedAt: BigInt!
    """

    The all-time total amount streamed until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountStreamedUntilUpdatedAt: BigInt!
    """

    The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountTransferredUntilUpdatedAt: BigInt!
    """

    Counts all approved subscriptions whether or not they have units.
    """
    totalApprovedSubscriptions: Int!
    """

    The total number of "active" (has greater than 0 units and has distributed it at
    least once) Indexes created with `token`.
    """
    totalNumberOfActiveIndexes: Int!
    """

    The total number of currently active `token` streams.
    """
    totalNumberOfActiveStreams: Int!
    """

    The all-time number of closed streams.
    """
    totalNumberOfClosedStreams: Int!
    """

    The total number of Indexes created with `token`.
    """
    totalNumberOfIndexes: Int!
    """

    The total outflow rate of the `token` (how much value is being moved).
    """
    totalOutflowRate: BigInt!
    """

    The number of subscriptions which have units allocated to them
    created with Indexes that distribute `token`.
    """
    totalSubscriptionsWithUnits: Int!
    """

    The total supply of the token - this is impacted by users upgrading/downgrading their
    tokens.
    """
    totalSupply: BigInt!
    updatedAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
}

type TokenUpgradedEvent implements Event {
    account: Account!
    """

    Holds the token and account addresses.
    """
    addresses: [Bytes!]!
    amount: BigInt!
    blockNumber: BigInt!
    id: ID!
    name: String!
    timestamp: BigInt!
    token: Bytes!
    transactionHash: Bytes!
}

type TransferEvent implements Event {
    """

    Holds the token, from and to addresses.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    from: Account!
    id: ID!
    name: String!
    timestamp: BigInt!
    to: Account!
    token: Bytes!
    transactionHash: Bytes!
    value: BigInt!
}

type TrustedForwarderChangedEvent implements Event {
    """

    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    enabled: Boolean!
    forwarder: Bytes!
    host: Bytes!
    id: ID!
    isSet: Boolean!
    name: String!
    superToken: Bytes!
    timestamp: BigInt!
    transactionHash: Bytes!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum AccountTokenSnapshot_orderBy {
    account
    balanceUntilUpdatedAt
    id
    token
    totalAmountStreamedUntilUpdatedAt
    totalAmountTransferredUntilUpdatedAt
    totalApprovedSubscriptions
    totalInflowRate
    totalNetFlowRate
    totalNumberOfActiveStreams
    totalNumberOfClosedStreams
    totalOutflowRate
    totalSubscriptionsWithUnits
    updatedAtBlockNumber
    updatedAtTimestamp
}

enum Account_orderBy {
    accountTokenSnapshots
    createdAtBlockNumber
    createdAtTimestamp
    id
    inflows
    isSuperApp
    outflows
    publishedIndexes
    receivedTransferEvents
    sentTransferEvents
    subscriptions
    tokenDowngradedEvents
    tokenUpgradedEvents
    updatedAtBlockNumber
    updatedAtTimestamp
}

enum AgreementClassRegisteredEvent_orderBy {
    addresses
    agreementType
    blockNumber
    code
    id
    name
    timestamp
    transactionHash
}

enum AgreementClassUpdatedEvent_orderBy {
    addresses
    agreementType
    blockNumber
    code
    id
    name
    timestamp
    transactionHash
}

enum AgreementLiquidatedByEvent_orderBy {
    addresses
    agreementClass
    agreementId
    bailoutAmount
    blockNumber
    bondAccount
    id
    liquidatorAccount
    name
    penaltyAccount
    rewardAmount
    timestamp
    token
    transactionHash
}

enum AppRegisteredEvent_orderBy {
    addresses
    app
    blockNumber
    id
    name
    timestamp
    transactionHash
}

enum BurnedEvent_orderBy {
    addresses
    amount
    blockNumber
    data
    from
    id
    name
    operator
    operatorData
    timestamp
    transactionHash
}

enum CFAv1LiquidationPeriodChangedEvent_orderBy {
    addresses
    blockNumber
    host
    id
    isSet
    liquidationPeriod
    name
    superToken
    timestamp
    transactionHash
}

enum ConfigChangedEvent_orderBy {
    addresses
    blockNumber
    host
    id
    isSet
    key
    name
    superToken
    timestamp
    transactionHash
    value
}

enum CustomSuperTokenCreatedEvent_orderBy {
    addresses
    blockNumber
    id
    name
    timestamp
    token
    transactionHash
}

enum Event_orderBy {
    addresses
    blockNumber
    id
    name
    timestamp
    transactionHash
}

enum FlowUpdatedEvent_orderBy {
    addresses
    blockNumber
    flowRate
    id
    name
    oldFlowRate
    receiver
    sender
    stream
    timestamp
    token
    totalAmountStreamedUntilTimestamp
    totalReceiverFlowRate
    totalSenderFlowRate
    transactionHash
    type
    userData
}

enum GovernanceReplacedEvent_orderBy {
    addresses
    blockNumber
    id
    name
    newGovernance
    oldGovernance
    timestamp
    transactionHash
}

enum IndexCreatedEvent_orderBy {
    addresses
    blockNumber
    id
    index
    indexId
    name
    publisher
    timestamp
    token
    transactionHash
    userData
}

enum IndexDistributionClaimedEvent_orderBy {
    addresses
    amount
    blockNumber
    id
    index
    indexId
    name
    publisher
    subscriber
    timestamp
    token
    transactionHash
}

enum IndexSubscribedEvent_orderBy {
    addresses
    blockNumber
    id
    index
    indexId
    name
    publisher
    subscriber
    timestamp
    token
    transactionHash
    userData
}

enum IndexSubscription_orderBy {
    approved
    createdAtBlockNumber
    createdAtTimestamp
    id
    index
    indexValueUntilUpdatedAt
    subscriber
    subscriptionApprovedEvents
    subscriptionDistributionClaimedEvents
    subscriptionRevokedEvents
    subscriptionUnitsUpdatedEvents
    totalAmountReceivedUntilUpdatedAt
    units
    updatedAtBlockNumber
    updatedAtTimestamp
}

enum IndexUnitsUpdatedEvent_orderBy {
    addresses
    blockNumber
    id
    index
    indexId
    name
    oldUnits
    publisher
    subscriber
    timestamp
    token
    transactionHash
    units
    userData
}

enum IndexUnsubscribedEvent_orderBy {
    addresses
    blockNumber
    id
    index
    indexId
    name
    publisher
    subscriber
    timestamp
    token
    transactionHash
    userData
}

enum IndexUpdatedEvent_orderBy {
    addresses
    blockNumber
    id
    index
    indexId
    name
    newIndexValue
    oldIndexValue
    publisher
    timestamp
    token
    totalUnitsApproved
    totalUnitsPending
    transactionHash
    userData
}

enum Index_orderBy {
    createdAtBlockNumber
    createdAtTimestamp
    id
    indexCreatedEvent
    indexDistributionClaimedEvents
    indexId
    indexSubscribedEvents
    indexUnitsUpdatedEvents
    indexUnsubscribedEvents
    indexUpdatedEvents
    indexValue
    publisher
    subscriptions
    token
    totalAmountDistributedUntilUpdatedAt
    totalSubscriptionsWithUnits
    totalUnits
    totalUnitsApproved
    totalUnitsPending
    updatedAtBlockNumber
    updatedAtTimestamp
}

enum JailEvent_orderBy {
    addresses
    app
    blockNumber
    id
    name
    reason
    timestamp
    transactionHash
}

enum MintedEvent_orderBy {
    addresses
    amount
    blockNumber
    data
    id
    name
    operator
    operatorData
    timestamp
    to
    transactionHash
}

enum OrderDirection {
    asc
    desc
}

enum RewardAddressChangedEvent_orderBy {
    addresses
    blockNumber
    host
    id
    isSet
    name
    rewardAddress
    superToken
    timestamp
    transactionHash
}

enum RoleAdminChangedEvent_orderBy {
    addresses
    blockNumber
    id
    name
    newAdminRole
    previousAdminRole
    role
    timestamp
    transactionHash
}

enum RoleGrantedEvent_orderBy {
    account
    addresses
    blockNumber
    id
    name
    role
    sender
    timestamp
    transactionHash
}

enum RoleRevokedEvent_orderBy {
    account
    addresses
    blockNumber
    id
    name
    role
    sender
    timestamp
    transactionHash
}

enum SFMeta_orderBy {
    blockNumber
    branch
    configuration
    id
    tag
    timestamp
}

enum SentEvent_orderBy {
    addresses
    amount
    blockNumber
    data
    id
    name
    operator
    operatorData
    timestamp
    to
    transactionHash
}

enum StreamPeriod_orderBy {
    flowRate
    id
    receiver
    sender
    startedAtBlockNumber
    startedAtEvent
    startedAtTimestamp
    stoppedAtBlockNumber
    stoppedAtEvent
    stoppedAtTimestamp
    stream
    token
    totalAmountStreamed
}

enum StreamRevision_orderBy {
    id
    periodRevisionIndex
    revisionIndex
}

enum Stream_orderBy {
    createdAtBlockNumber
    createdAtTimestamp
    currentFlowRate
    flowUpdatedEvents
    id
    receiver
    sender
    streamPeriods
    streamedUntilUpdatedAt
    token
    updatedAtBlockNumber
    updatedAtTimestamp
}

enum SubscriptionApprovedEvent_orderBy {
    addresses
    blockNumber
    id
    indexId
    name
    publisher
    subscriber
    subscription
    timestamp
    token
    transactionHash
    userData
}

enum SubscriptionDistributionClaimedEvent_orderBy {
    addresses
    amount
    blockNumber
    id
    indexId
    name
    publisher
    subscriber
    subscription
    timestamp
    token
    transactionHash
}

enum SubscriptionRevokedEvent_orderBy {
    addresses
    blockNumber
    id
    indexId
    name
    publisher
    subscriber
    subscription
    timestamp
    token
    transactionHash
    userData
}

enum SubscriptionUnitsUpdatedEvent_orderBy {
    addresses
    blockNumber
    id
    indexId
    name
    oldUnits
    publisher
    subscriber
    subscription
    timestamp
    token
    transactionHash
    units
    userData
}

enum SuperTokenCreatedEvent_orderBy {
    addresses
    blockNumber
    id
    name
    timestamp
    token
    transactionHash
}

enum SuperTokenFactoryUpdatedEvent_orderBy {
    addresses
    blockNumber
    id
    name
    newFactory
    timestamp
    transactionHash
}

enum SuperTokenLogicCreatedEvent_orderBy {
    addresses
    blockNumber
    id
    name
    timestamp
    tokenLogic
    transactionHash
}

enum SuperTokenLogicUpdatedEvent_orderBy {
    addresses
    blockNumber
    code
    id
    name
    timestamp
    token
    transactionHash
}

enum TokenDowngradedEvent_orderBy {
    account
    addresses
    amount
    blockNumber
    id
    name
    timestamp
    token
    transactionHash
}

enum TokenStatistic_orderBy {
    id
    token
    totalAmountDistributedUntilUpdatedAt
    totalAmountStreamedUntilUpdatedAt
    totalAmountTransferredUntilUpdatedAt
    totalApprovedSubscriptions
    totalNumberOfActiveIndexes
    totalNumberOfActiveStreams
    totalNumberOfClosedStreams
    totalNumberOfIndexes
    totalOutflowRate
    totalSubscriptionsWithUnits
    totalSupply
    updatedAtBlockNumber
    updatedAtTimestamp
}

enum TokenUpgradedEvent_orderBy {
    account
    addresses
    amount
    blockNumber
    id
    name
    timestamp
    token
    transactionHash
}

enum Token_orderBy {
    createdAtBlockNumber
    createdAtTimestamp
    decimals
    id
    isListed
    isSuperToken
    name
    symbol
    underlyingAddress
    underlyingToken
}

enum TransferEvent_orderBy {
    addresses
    blockNumber
    from
    id
    name
    timestamp
    to
    token
    transactionHash
    value
}

enum TrustedForwarderChangedEvent_orderBy {
    addresses
    blockNumber
    enabled
    forwarder
    host
    id
    isSet
    name
    superToken
    timestamp
    transactionHash
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

input AccountTokenSnapshot_filter {
    account: String
    account_contains: String
    account_ends_with: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_ends_with: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_starts_with: String
    balanceUntilUpdatedAt: BigInt
    balanceUntilUpdatedAt_gt: BigInt
    balanceUntilUpdatedAt_gte: BigInt
    balanceUntilUpdatedAt_in: [BigInt!]
    balanceUntilUpdatedAt_lt: BigInt
    balanceUntilUpdatedAt_lte: BigInt
    balanceUntilUpdatedAt_not: BigInt
    balanceUntilUpdatedAt_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    totalAmountStreamedUntilUpdatedAt: BigInt
    totalAmountStreamedUntilUpdatedAt_gt: BigInt
    totalAmountStreamedUntilUpdatedAt_gte: BigInt
    totalAmountStreamedUntilUpdatedAt_in: [BigInt!]
    totalAmountStreamedUntilUpdatedAt_lt: BigInt
    totalAmountStreamedUntilUpdatedAt_lte: BigInt
    totalAmountStreamedUntilUpdatedAt_not: BigInt
    totalAmountStreamedUntilUpdatedAt_not_in: [BigInt!]
    totalAmountTransferredUntilUpdatedAt: BigInt
    totalAmountTransferredUntilUpdatedAt_gt: BigInt
    totalAmountTransferredUntilUpdatedAt_gte: BigInt
    totalAmountTransferredUntilUpdatedAt_in: [BigInt!]
    totalAmountTransferredUntilUpdatedAt_lt: BigInt
    totalAmountTransferredUntilUpdatedAt_lte: BigInt
    totalAmountTransferredUntilUpdatedAt_not: BigInt
    totalAmountTransferredUntilUpdatedAt_not_in: [BigInt!]
    totalApprovedSubscriptions: Int
    totalApprovedSubscriptions_gt: Int
    totalApprovedSubscriptions_gte: Int
    totalApprovedSubscriptions_in: [Int!]
    totalApprovedSubscriptions_lt: Int
    totalApprovedSubscriptions_lte: Int
    totalApprovedSubscriptions_not: Int
    totalApprovedSubscriptions_not_in: [Int!]
    totalInflowRate: BigInt
    totalInflowRate_gt: BigInt
    totalInflowRate_gte: BigInt
    totalInflowRate_in: [BigInt!]
    totalInflowRate_lt: BigInt
    totalInflowRate_lte: BigInt
    totalInflowRate_not: BigInt
    totalInflowRate_not_in: [BigInt!]
    totalNetFlowRate: BigInt
    totalNetFlowRate_gt: BigInt
    totalNetFlowRate_gte: BigInt
    totalNetFlowRate_in: [BigInt!]
    totalNetFlowRate_lt: BigInt
    totalNetFlowRate_lte: BigInt
    totalNetFlowRate_not: BigInt
    totalNetFlowRate_not_in: [BigInt!]
    totalNumberOfActiveStreams: Int
    totalNumberOfActiveStreams_gt: Int
    totalNumberOfActiveStreams_gte: Int
    totalNumberOfActiveStreams_in: [Int!]
    totalNumberOfActiveStreams_lt: Int
    totalNumberOfActiveStreams_lte: Int
    totalNumberOfActiveStreams_not: Int
    totalNumberOfActiveStreams_not_in: [Int!]
    totalNumberOfClosedStreams: Int
    totalNumberOfClosedStreams_gt: Int
    totalNumberOfClosedStreams_gte: Int
    totalNumberOfClosedStreams_in: [Int!]
    totalNumberOfClosedStreams_lt: Int
    totalNumberOfClosedStreams_lte: Int
    totalNumberOfClosedStreams_not: Int
    totalNumberOfClosedStreams_not_in: [Int!]
    totalOutflowRate: BigInt
    totalOutflowRate_gt: BigInt
    totalOutflowRate_gte: BigInt
    totalOutflowRate_in: [BigInt!]
    totalOutflowRate_lt: BigInt
    totalOutflowRate_lte: BigInt
    totalOutflowRate_not: BigInt
    totalOutflowRate_not_in: [BigInt!]
    totalSubscriptionsWithUnits: Int
    totalSubscriptionsWithUnits_gt: Int
    totalSubscriptionsWithUnits_gte: Int
    totalSubscriptionsWithUnits_in: [Int!]
    totalSubscriptionsWithUnits_lt: Int
    totalSubscriptionsWithUnits_lte: Int
    totalSubscriptionsWithUnits_not: Int
    totalSubscriptionsWithUnits_not_in: [Int!]
    updatedAtBlockNumber: BigInt
    updatedAtBlockNumber_gt: BigInt
    updatedAtBlockNumber_gte: BigInt
    updatedAtBlockNumber_in: [BigInt!]
    updatedAtBlockNumber_lt: BigInt
    updatedAtBlockNumber_lte: BigInt
    updatedAtBlockNumber_not: BigInt
    updatedAtBlockNumber_not_in: [BigInt!]
    updatedAtTimestamp: BigInt
    updatedAtTimestamp_gt: BigInt
    updatedAtTimestamp_gte: BigInt
    updatedAtTimestamp_in: [BigInt!]
    updatedAtTimestamp_lt: BigInt
    updatedAtTimestamp_lte: BigInt
    updatedAtTimestamp_not: BigInt
    updatedAtTimestamp_not_in: [BigInt!]
}

input Account_filter {
    createdAtBlockNumber: BigInt
    createdAtBlockNumber_gt: BigInt
    createdAtBlockNumber_gte: BigInt
    createdAtBlockNumber_in: [BigInt!]
    createdAtBlockNumber_lt: BigInt
    createdAtBlockNumber_lte: BigInt
    createdAtBlockNumber_not: BigInt
    createdAtBlockNumber_not_in: [BigInt!]
    createdAtTimestamp: BigInt
    createdAtTimestamp_gt: BigInt
    createdAtTimestamp_gte: BigInt
    createdAtTimestamp_in: [BigInt!]
    createdAtTimestamp_lt: BigInt
    createdAtTimestamp_lte: BigInt
    createdAtTimestamp_not: BigInt
    createdAtTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isSuperApp: Boolean
    isSuperApp_in: [Boolean!]
    isSuperApp_not: Boolean
    isSuperApp_not_in: [Boolean!]
    updatedAtBlockNumber: BigInt
    updatedAtBlockNumber_gt: BigInt
    updatedAtBlockNumber_gte: BigInt
    updatedAtBlockNumber_in: [BigInt!]
    updatedAtBlockNumber_lt: BigInt
    updatedAtBlockNumber_lte: BigInt
    updatedAtBlockNumber_not: BigInt
    updatedAtBlockNumber_not_in: [BigInt!]
    updatedAtTimestamp: BigInt
    updatedAtTimestamp_gt: BigInt
    updatedAtTimestamp_gte: BigInt
    updatedAtTimestamp_in: [BigInt!]
    updatedAtTimestamp_lt: BigInt
    updatedAtTimestamp_lte: BigInt
    updatedAtTimestamp_not: BigInt
    updatedAtTimestamp_not_in: [BigInt!]
}

input AgreementClassRegisteredEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    agreementType: Bytes
    agreementType_contains: Bytes
    agreementType_in: [Bytes!]
    agreementType_not: Bytes
    agreementType_not_contains: Bytes
    agreementType_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    code: Bytes
    code_contains: Bytes
    code_in: [Bytes!]
    code_not: Bytes
    code_not_contains: Bytes
    code_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input AgreementClassUpdatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    agreementType: Bytes
    agreementType_contains: Bytes
    agreementType_in: [Bytes!]
    agreementType_not: Bytes
    agreementType_not_contains: Bytes
    agreementType_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    code: Bytes
    code_contains: Bytes
    code_in: [Bytes!]
    code_not: Bytes
    code_not_contains: Bytes
    code_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input AgreementLiquidatedByEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    agreementClass: Bytes
    agreementClass_contains: Bytes
    agreementClass_in: [Bytes!]
    agreementClass_not: Bytes
    agreementClass_not_contains: Bytes
    agreementClass_not_in: [Bytes!]
    agreementId: Bytes
    agreementId_contains: Bytes
    agreementId_in: [Bytes!]
    agreementId_not: Bytes
    agreementId_not_contains: Bytes
    agreementId_not_in: [Bytes!]
    bailoutAmount: BigInt
    bailoutAmount_gt: BigInt
    bailoutAmount_gte: BigInt
    bailoutAmount_in: [BigInt!]
    bailoutAmount_lt: BigInt
    bailoutAmount_lte: BigInt
    bailoutAmount_not: BigInt
    bailoutAmount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    bondAccount: Bytes
    bondAccount_contains: Bytes
    bondAccount_in: [Bytes!]
    bondAccount_not: Bytes
    bondAccount_not_contains: Bytes
    bondAccount_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    liquidatorAccount: Bytes
    liquidatorAccount_contains: Bytes
    liquidatorAccount_in: [Bytes!]
    liquidatorAccount_not: Bytes
    liquidatorAccount_not_contains: Bytes
    liquidatorAccount_not_in: [Bytes!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    penaltyAccount: Bytes
    penaltyAccount_contains: Bytes
    penaltyAccount_in: [Bytes!]
    penaltyAccount_not: Bytes
    penaltyAccount_not_contains: Bytes
    penaltyAccount_not_in: [Bytes!]
    rewardAmount: BigInt
    rewardAmount_gt: BigInt
    rewardAmount_gte: BigInt
    rewardAmount_in: [BigInt!]
    rewardAmount_lt: BigInt
    rewardAmount_lte: BigInt
    rewardAmount_not: BigInt
    rewardAmount_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input AppRegisteredEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    app: Bytes
    app_contains: Bytes
    app_in: [Bytes!]
    app_not: Bytes
    app_not_contains: Bytes
    app_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input BurnedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    data: Bytes
    data_contains: Bytes
    data_in: [Bytes!]
    data_not: Bytes
    data_not_contains: Bytes
    data_not_in: [Bytes!]
    from: Bytes
    from_contains: Bytes
    from_in: [Bytes!]
    from_not: Bytes
    from_not_contains: Bytes
    from_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    operator: Bytes
    operatorData: Bytes
    operatorData_contains: Bytes
    operatorData_in: [Bytes!]
    operatorData_not: Bytes
    operatorData_not_contains: Bytes
    operatorData_not_in: [Bytes!]
    operator_contains: Bytes
    operator_in: [Bytes!]
    operator_not: Bytes
    operator_not_contains: Bytes
    operator_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input CFAv1LiquidationPeriodChangedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    host: Bytes
    host_contains: Bytes
    host_in: [Bytes!]
    host_not: Bytes
    host_not_contains: Bytes
    host_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isSet: Boolean
    isSet_in: [Boolean!]
    isSet_not: Boolean
    isSet_not_in: [Boolean!]
    liquidationPeriod: BigInt
    liquidationPeriod_gt: BigInt
    liquidationPeriod_gte: BigInt
    liquidationPeriod_in: [BigInt!]
    liquidationPeriod_lt: BigInt
    liquidationPeriod_lte: BigInt
    liquidationPeriod_not: BigInt
    liquidationPeriod_not_in: [BigInt!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    superToken: Bytes
    superToken_contains: Bytes
    superToken_in: [Bytes!]
    superToken_not: Bytes
    superToken_not_contains: Bytes
    superToken_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input ConfigChangedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    host: Bytes
    host_contains: Bytes
    host_in: [Bytes!]
    host_not: Bytes
    host_not_contains: Bytes
    host_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isSet: Boolean
    isSet_in: [Boolean!]
    isSet_not: Boolean
    isSet_not_in: [Boolean!]
    key: Bytes
    key_contains: Bytes
    key_in: [Bytes!]
    key_not: Bytes
    key_not_contains: Bytes
    key_not_in: [Bytes!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    superToken: Bytes
    superToken_contains: Bytes
    superToken_in: [Bytes!]
    superToken_not: Bytes
    superToken_not_contains: Bytes
    superToken_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    value: BigInt
    value_gt: BigInt
    value_gte: BigInt
    value_in: [BigInt!]
    value_lt: BigInt
    value_lte: BigInt
    value_not: BigInt
    value_not_in: [BigInt!]
}

input CustomSuperTokenCreatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Event_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input FlowUpdatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    flowRate: BigInt
    flowRate_gt: BigInt
    flowRate_gte: BigInt
    flowRate_in: [BigInt!]
    flowRate_lt: BigInt
    flowRate_lte: BigInt
    flowRate_not: BigInt
    flowRate_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    oldFlowRate: BigInt
    oldFlowRate_gt: BigInt
    oldFlowRate_gte: BigInt
    oldFlowRate_in: [BigInt!]
    oldFlowRate_lt: BigInt
    oldFlowRate_lte: BigInt
    oldFlowRate_not: BigInt
    oldFlowRate_not_in: [BigInt!]
    receiver: Bytes
    receiver_contains: Bytes
    receiver_in: [Bytes!]
    receiver_not: Bytes
    receiver_not_contains: Bytes
    receiver_not_in: [Bytes!]
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    stream: String
    stream_contains: String
    stream_ends_with: String
    stream_gt: String
    stream_gte: String
    stream_in: [String!]
    stream_lt: String
    stream_lte: String
    stream_not: String
    stream_not_contains: String
    stream_not_ends_with: String
    stream_not_in: [String!]
    stream_not_starts_with: String
    stream_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    totalAmountStreamedUntilTimestamp: BigInt
    totalAmountStreamedUntilTimestamp_gt: BigInt
    totalAmountStreamedUntilTimestamp_gte: BigInt
    totalAmountStreamedUntilTimestamp_in: [BigInt!]
    totalAmountStreamedUntilTimestamp_lt: BigInt
    totalAmountStreamedUntilTimestamp_lte: BigInt
    totalAmountStreamedUntilTimestamp_not: BigInt
    totalAmountStreamedUntilTimestamp_not_in: [BigInt!]
    totalReceiverFlowRate: BigInt
    totalReceiverFlowRate_gt: BigInt
    totalReceiverFlowRate_gte: BigInt
    totalReceiverFlowRate_in: [BigInt!]
    totalReceiverFlowRate_lt: BigInt
    totalReceiverFlowRate_lte: BigInt
    totalReceiverFlowRate_not: BigInt
    totalReceiverFlowRate_not_in: [BigInt!]
    totalSenderFlowRate: BigInt
    totalSenderFlowRate_gt: BigInt
    totalSenderFlowRate_gte: BigInt
    totalSenderFlowRate_in: [BigInt!]
    totalSenderFlowRate_lt: BigInt
    totalSenderFlowRate_lte: BigInt
    totalSenderFlowRate_not: BigInt
    totalSenderFlowRate_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    type: Int
    type_gt: Int
    type_gte: Int
    type_in: [Int!]
    type_lt: Int
    type_lte: Int
    type_not: Int
    type_not_in: [Int!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input GovernanceReplacedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    newGovernance: Bytes
    newGovernance_contains: Bytes
    newGovernance_in: [Bytes!]
    newGovernance_not: Bytes
    newGovernance_not_contains: Bytes
    newGovernance_not_in: [Bytes!]
    oldGovernance: Bytes
    oldGovernance_contains: Bytes
    oldGovernance_in: [Bytes!]
    oldGovernance_not: Bytes
    oldGovernance_not_contains: Bytes
    oldGovernance_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input IndexCreatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input IndexDistributionClaimedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input IndexSubscribedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input IndexSubscription_filter {
    approved: Boolean
    approved_in: [Boolean!]
    approved_not: Boolean
    approved_not_in: [Boolean!]
    createdAtBlockNumber: BigInt
    createdAtBlockNumber_gt: BigInt
    createdAtBlockNumber_gte: BigInt
    createdAtBlockNumber_in: [BigInt!]
    createdAtBlockNumber_lt: BigInt
    createdAtBlockNumber_lte: BigInt
    createdAtBlockNumber_not: BigInt
    createdAtBlockNumber_not_in: [BigInt!]
    createdAtTimestamp: BigInt
    createdAtTimestamp_gt: BigInt
    createdAtTimestamp_gte: BigInt
    createdAtTimestamp_in: [BigInt!]
    createdAtTimestamp_lt: BigInt
    createdAtTimestamp_lte: BigInt
    createdAtTimestamp_not: BigInt
    createdAtTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexValueUntilUpdatedAt: BigInt
    indexValueUntilUpdatedAt_gt: BigInt
    indexValueUntilUpdatedAt_gte: BigInt
    indexValueUntilUpdatedAt_in: [BigInt!]
    indexValueUntilUpdatedAt_lt: BigInt
    indexValueUntilUpdatedAt_lte: BigInt
    indexValueUntilUpdatedAt_not: BigInt
    indexValueUntilUpdatedAt_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    subscriber: String
    subscriber_contains: String
    subscriber_ends_with: String
    subscriber_gt: String
    subscriber_gte: String
    subscriber_in: [String!]
    subscriber_lt: String
    subscriber_lte: String
    subscriber_not: String
    subscriber_not_contains: String
    subscriber_not_ends_with: String
    subscriber_not_in: [String!]
    subscriber_not_starts_with: String
    subscriber_starts_with: String
    totalAmountReceivedUntilUpdatedAt: BigInt
    totalAmountReceivedUntilUpdatedAt_gt: BigInt
    totalAmountReceivedUntilUpdatedAt_gte: BigInt
    totalAmountReceivedUntilUpdatedAt_in: [BigInt!]
    totalAmountReceivedUntilUpdatedAt_lt: BigInt
    totalAmountReceivedUntilUpdatedAt_lte: BigInt
    totalAmountReceivedUntilUpdatedAt_not: BigInt
    totalAmountReceivedUntilUpdatedAt_not_in: [BigInt!]
    units: BigInt
    units_gt: BigInt
    units_gte: BigInt
    units_in: [BigInt!]
    units_lt: BigInt
    units_lte: BigInt
    units_not: BigInt
    units_not_in: [BigInt!]
    updatedAtBlockNumber: BigInt
    updatedAtBlockNumber_gt: BigInt
    updatedAtBlockNumber_gte: BigInt
    updatedAtBlockNumber_in: [BigInt!]
    updatedAtBlockNumber_lt: BigInt
    updatedAtBlockNumber_lte: BigInt
    updatedAtBlockNumber_not: BigInt
    updatedAtBlockNumber_not_in: [BigInt!]
    updatedAtTimestamp: BigInt
    updatedAtTimestamp_gt: BigInt
    updatedAtTimestamp_gte: BigInt
    updatedAtTimestamp_in: [BigInt!]
    updatedAtTimestamp_lt: BigInt
    updatedAtTimestamp_lte: BigInt
    updatedAtTimestamp_not: BigInt
    updatedAtTimestamp_not_in: [BigInt!]
}

input IndexUnitsUpdatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    oldUnits: BigInt
    oldUnits_gt: BigInt
    oldUnits_gte: BigInt
    oldUnits_in: [BigInt!]
    oldUnits_lt: BigInt
    oldUnits_lte: BigInt
    oldUnits_not: BigInt
    oldUnits_not_in: [BigInt!]
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    units: BigInt
    units_gt: BigInt
    units_gte: BigInt
    units_in: [BigInt!]
    units_lt: BigInt
    units_lte: BigInt
    units_not: BigInt
    units_not_in: [BigInt!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input IndexUnsubscribedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input IndexUpdatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    index: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    index_contains: String
    index_ends_with: String
    index_gt: String
    index_gte: String
    index_in: [String!]
    index_lt: String
    index_lte: String
    index_not: String
    index_not_contains: String
    index_not_ends_with: String
    index_not_in: [String!]
    index_not_starts_with: String
    index_starts_with: String
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    newIndexValue: BigInt
    newIndexValue_gt: BigInt
    newIndexValue_gte: BigInt
    newIndexValue_in: [BigInt!]
    newIndexValue_lt: BigInt
    newIndexValue_lte: BigInt
    newIndexValue_not: BigInt
    newIndexValue_not_in: [BigInt!]
    oldIndexValue: BigInt
    oldIndexValue_gt: BigInt
    oldIndexValue_gte: BigInt
    oldIndexValue_in: [BigInt!]
    oldIndexValue_lt: BigInt
    oldIndexValue_lte: BigInt
    oldIndexValue_not: BigInt
    oldIndexValue_not_in: [BigInt!]
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    totalUnitsApproved: BigInt
    totalUnitsApproved_gt: BigInt
    totalUnitsApproved_gte: BigInt
    totalUnitsApproved_in: [BigInt!]
    totalUnitsApproved_lt: BigInt
    totalUnitsApproved_lte: BigInt
    totalUnitsApproved_not: BigInt
    totalUnitsApproved_not_in: [BigInt!]
    totalUnitsPending: BigInt
    totalUnitsPending_gt: BigInt
    totalUnitsPending_gte: BigInt
    totalUnitsPending_in: [BigInt!]
    totalUnitsPending_lt: BigInt
    totalUnitsPending_lte: BigInt
    totalUnitsPending_not: BigInt
    totalUnitsPending_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input Index_filter {
    createdAtBlockNumber: BigInt
    createdAtBlockNumber_gt: BigInt
    createdAtBlockNumber_gte: BigInt
    createdAtBlockNumber_in: [BigInt!]
    createdAtBlockNumber_lt: BigInt
    createdAtBlockNumber_lte: BigInt
    createdAtBlockNumber_not: BigInt
    createdAtBlockNumber_not_in: [BigInt!]
    createdAtTimestamp: BigInt
    createdAtTimestamp_gt: BigInt
    createdAtTimestamp_gte: BigInt
    createdAtTimestamp_in: [BigInt!]
    createdAtTimestamp_lt: BigInt
    createdAtTimestamp_lte: BigInt
    createdAtTimestamp_not: BigInt
    createdAtTimestamp_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    indexCreatedEvent: String
    indexCreatedEvent_contains: String
    indexCreatedEvent_ends_with: String
    indexCreatedEvent_gt: String
    indexCreatedEvent_gte: String
    indexCreatedEvent_in: [String!]
    indexCreatedEvent_lt: String
    indexCreatedEvent_lte: String
    indexCreatedEvent_not: String
    indexCreatedEvent_not_contains: String
    indexCreatedEvent_not_ends_with: String
    indexCreatedEvent_not_in: [String!]
    indexCreatedEvent_not_starts_with: String
    indexCreatedEvent_starts_with: String
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    indexValue: BigInt
    indexValue_gt: BigInt
    indexValue_gte: BigInt
    indexValue_in: [BigInt!]
    indexValue_lt: BigInt
    indexValue_lte: BigInt
    indexValue_not: BigInt
    indexValue_not_in: [BigInt!]
    publisher: String
    publisher_contains: String
    publisher_ends_with: String
    publisher_gt: String
    publisher_gte: String
    publisher_in: [String!]
    publisher_lt: String
    publisher_lte: String
    publisher_not: String
    publisher_not_contains: String
    publisher_not_ends_with: String
    publisher_not_in: [String!]
    publisher_not_starts_with: String
    publisher_starts_with: String
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    totalAmountDistributedUntilUpdatedAt: BigInt
    totalAmountDistributedUntilUpdatedAt_gt: BigInt
    totalAmountDistributedUntilUpdatedAt_gte: BigInt
    totalAmountDistributedUntilUpdatedAt_in: [BigInt!]
    totalAmountDistributedUntilUpdatedAt_lt: BigInt
    totalAmountDistributedUntilUpdatedAt_lte: BigInt
    totalAmountDistributedUntilUpdatedAt_not: BigInt
    totalAmountDistributedUntilUpdatedAt_not_in: [BigInt!]
    totalSubscriptionsWithUnits: Int
    totalSubscriptionsWithUnits_gt: Int
    totalSubscriptionsWithUnits_gte: Int
    totalSubscriptionsWithUnits_in: [Int!]
    totalSubscriptionsWithUnits_lt: Int
    totalSubscriptionsWithUnits_lte: Int
    totalSubscriptionsWithUnits_not: Int
    totalSubscriptionsWithUnits_not_in: [Int!]
    totalUnits: BigInt
    totalUnitsApproved: BigInt
    totalUnitsApproved_gt: BigInt
    totalUnitsApproved_gte: BigInt
    totalUnitsApproved_in: [BigInt!]
    totalUnitsApproved_lt: BigInt
    totalUnitsApproved_lte: BigInt
    totalUnitsApproved_not: BigInt
    totalUnitsApproved_not_in: [BigInt!]
    totalUnitsPending: BigInt
    totalUnitsPending_gt: BigInt
    totalUnitsPending_gte: BigInt
    totalUnitsPending_in: [BigInt!]
    totalUnitsPending_lt: BigInt
    totalUnitsPending_lte: BigInt
    totalUnitsPending_not: BigInt
    totalUnitsPending_not_in: [BigInt!]
    totalUnits_gt: BigInt
    totalUnits_gte: BigInt
    totalUnits_in: [BigInt!]
    totalUnits_lt: BigInt
    totalUnits_lte: BigInt
    totalUnits_not: BigInt
    totalUnits_not_in: [BigInt!]
    updatedAtBlockNumber: BigInt
    updatedAtBlockNumber_gt: BigInt
    updatedAtBlockNumber_gte: BigInt
    updatedAtBlockNumber_in: [BigInt!]
    updatedAtBlockNumber_lt: BigInt
    updatedAtBlockNumber_lte: BigInt
    updatedAtBlockNumber_not: BigInt
    updatedAtBlockNumber_not_in: [BigInt!]
    updatedAtTimestamp: BigInt
    updatedAtTimestamp_gt: BigInt
    updatedAtTimestamp_gte: BigInt
    updatedAtTimestamp_in: [BigInt!]
    updatedAtTimestamp_lt: BigInt
    updatedAtTimestamp_lte: BigInt
    updatedAtTimestamp_not: BigInt
    updatedAtTimestamp_not_in: [BigInt!]
}

input JailEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    app: Bytes
    app_contains: Bytes
    app_in: [Bytes!]
    app_not: Bytes
    app_not_contains: Bytes
    app_not_in: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    reason: BigInt
    reason_gt: BigInt
    reason_gte: BigInt
    reason_in: [BigInt!]
    reason_lt: BigInt
    reason_lte: BigInt
    reason_not: BigInt
    reason_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input MintedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    data: Bytes
    data_contains: Bytes
    data_in: [Bytes!]
    data_not: Bytes
    data_not_contains: Bytes
    data_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    operator: Bytes
    operatorData: Bytes
    operatorData_contains: Bytes
    operatorData_in: [Bytes!]
    operatorData_not: Bytes
    operatorData_not_contains: Bytes
    operatorData_not_in: [Bytes!]
    operator_contains: Bytes
    operator_in: [Bytes!]
    operator_not: Bytes
    operator_not_contains: Bytes
    operator_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    to: Bytes
    to_contains: Bytes
    to_in: [Bytes!]
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RewardAddressChangedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    host: Bytes
    host_contains: Bytes
    host_in: [Bytes!]
    host_not: Bytes
    host_not_contains: Bytes
    host_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isSet: Boolean
    isSet_in: [Boolean!]
    isSet_not: Boolean
    isSet_not_in: [Boolean!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    rewardAddress: Bytes
    rewardAddress_contains: Bytes
    rewardAddress_in: [Bytes!]
    rewardAddress_not: Bytes
    rewardAddress_not_contains: Bytes
    rewardAddress_not_in: [Bytes!]
    superToken: Bytes
    superToken_contains: Bytes
    superToken_in: [Bytes!]
    superToken_not: Bytes
    superToken_not_contains: Bytes
    superToken_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RoleAdminChangedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    newAdminRole: Bytes
    newAdminRole_contains: Bytes
    newAdminRole_in: [Bytes!]
    newAdminRole_not: Bytes
    newAdminRole_not_contains: Bytes
    newAdminRole_not_in: [Bytes!]
    previousAdminRole: Bytes
    previousAdminRole_contains: Bytes
    previousAdminRole_in: [Bytes!]
    previousAdminRole_not: Bytes
    previousAdminRole_not_contains: Bytes
    previousAdminRole_not_in: [Bytes!]
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RoleGrantedEvent_filter {
    account: Bytes
    account_contains: Bytes
    account_in: [Bytes!]
    account_not: Bytes
    account_not_contains: Bytes
    account_not_in: [Bytes!]
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input RoleRevokedEvent_filter {
    account: Bytes
    account_contains: Bytes
    account_in: [Bytes!]
    account_not: Bytes
    account_not_contains: Bytes
    account_not_in: [Bytes!]
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    role: Bytes
    role_contains: Bytes
    role_in: [Bytes!]
    role_not: Bytes
    role_not_contains: Bytes
    role_not_in: [Bytes!]
    sender: Bytes
    sender_contains: Bytes
    sender_in: [Bytes!]
    sender_not: Bytes
    sender_not_contains: Bytes
    sender_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input SFMeta_filter {
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    branch: String
    branch_contains: String
    branch_ends_with: String
    branch_gt: String
    branch_gte: String
    branch_in: [String!]
    branch_lt: String
    branch_lte: String
    branch_not: String
    branch_not_contains: String
    branch_not_ends_with: String
    branch_not_in: [String!]
    branch_not_starts_with: String
    branch_starts_with: String
    configuration: String
    configuration_contains: String
    configuration_ends_with: String
    configuration_gt: String
    configuration_gte: String
    configuration_in: [String!]
    configuration_lt: String
    configuration_lte: String
    configuration_not: String
    configuration_not_contains: String
    configuration_not_ends_with: String
    configuration_not_in: [String!]
    configuration_not_starts_with: String
    configuration_starts_with: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    tag: String
    tag_contains: String
    tag_ends_with: String
    tag_gt: String
    tag_gte: String
    tag_in: [String!]
    tag_lt: String
    tag_lte: String
    tag_not: String
    tag_not_contains: String
    tag_not_ends_with: String
    tag_not_in: [String!]
    tag_not_starts_with: String
    tag_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

input SentEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    data: Bytes
    data_contains: Bytes
    data_in: [Bytes!]
    data_not: Bytes
    data_not_contains: Bytes
    data_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    operator: Bytes
    operatorData: Bytes
    operatorData_contains: Bytes
    operatorData_in: [Bytes!]
    operatorData_not: Bytes
    operatorData_not_contains: Bytes
    operatorData_not_in: [Bytes!]
    operator_contains: Bytes
    operator_in: [Bytes!]
    operator_not: Bytes
    operator_not_contains: Bytes
    operator_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    to: Bytes
    to_contains: Bytes
    to_in: [Bytes!]
    to_not: Bytes
    to_not_contains: Bytes
    to_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input StreamPeriod_filter {
    flowRate: BigInt
    flowRate_gt: BigInt
    flowRate_gte: BigInt
    flowRate_in: [BigInt!]
    flowRate_lt: BigInt
    flowRate_lte: BigInt
    flowRate_not: BigInt
    flowRate_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    receiver: String
    receiver_contains: String
    receiver_ends_with: String
    receiver_gt: String
    receiver_gte: String
    receiver_in: [String!]
    receiver_lt: String
    receiver_lte: String
    receiver_not: String
    receiver_not_contains: String
    receiver_not_ends_with: String
    receiver_not_in: [String!]
    receiver_not_starts_with: String
    receiver_starts_with: String
    sender: String
    sender_contains: String
    sender_ends_with: String
    sender_gt: String
    sender_gte: String
    sender_in: [String!]
    sender_lt: String
    sender_lte: String
    sender_not: String
    sender_not_contains: String
    sender_not_ends_with: String
    sender_not_in: [String!]
    sender_not_starts_with: String
    sender_starts_with: String
    startedAtBlockNumber: BigInt
    startedAtBlockNumber_gt: BigInt
    startedAtBlockNumber_gte: BigInt
    startedAtBlockNumber_in: [BigInt!]
    startedAtBlockNumber_lt: BigInt
    startedAtBlockNumber_lte: BigInt
    startedAtBlockNumber_not: BigInt
    startedAtBlockNumber_not_in: [BigInt!]
    startedAtEvent: String
    startedAtEvent_contains: String
    startedAtEvent_ends_with: String
    startedAtEvent_gt: String
    startedAtEvent_gte: String
    startedAtEvent_in: [String!]
    startedAtEvent_lt: String
    startedAtEvent_lte: String
    startedAtEvent_not: String
    startedAtEvent_not_contains: String
    startedAtEvent_not_ends_with: String
    startedAtEvent_not_in: [String!]
    startedAtEvent_not_starts_with: String
    startedAtEvent_starts_with: String
    startedAtTimestamp: BigInt
    startedAtTimestamp_gt: BigInt
    startedAtTimestamp_gte: BigInt
    startedAtTimestamp_in: [BigInt!]
    startedAtTimestamp_lt: BigInt
    startedAtTimestamp_lte: BigInt
    startedAtTimestamp_not: BigInt
    startedAtTimestamp_not_in: [BigInt!]
    stoppedAtBlockNumber: BigInt
    stoppedAtBlockNumber_gt: BigInt
    stoppedAtBlockNumber_gte: BigInt
    stoppedAtBlockNumber_in: [BigInt!]
    stoppedAtBlockNumber_lt: BigInt
    stoppedAtBlockNumber_lte: BigInt
    stoppedAtBlockNumber_not: BigInt
    stoppedAtBlockNumber_not_in: [BigInt!]
    stoppedAtEvent: String
    stoppedAtEvent_contains: String
    stoppedAtEvent_ends_with: String
    stoppedAtEvent_gt: String
    stoppedAtEvent_gte: String
    stoppedAtEvent_in: [String!]
    stoppedAtEvent_lt: String
    stoppedAtEvent_lte: String
    stoppedAtEvent_not: String
    stoppedAtEvent_not_contains: String
    stoppedAtEvent_not_ends_with: String
    stoppedAtEvent_not_in: [String!]
    stoppedAtEvent_not_starts_with: String
    stoppedAtEvent_starts_with: String
    stoppedAtTimestamp: BigInt
    stoppedAtTimestamp_gt: BigInt
    stoppedAtTimestamp_gte: BigInt
    stoppedAtTimestamp_in: [BigInt!]
    stoppedAtTimestamp_lt: BigInt
    stoppedAtTimestamp_lte: BigInt
    stoppedAtTimestamp_not: BigInt
    stoppedAtTimestamp_not_in: [BigInt!]
    stream: String
    stream_contains: String
    stream_ends_with: String
    stream_gt: String
    stream_gte: String
    stream_in: [String!]
    stream_lt: String
    stream_lte: String
    stream_not: String
    stream_not_contains: String
    stream_not_ends_with: String
    stream_not_in: [String!]
    stream_not_starts_with: String
    stream_starts_with: String
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    totalAmountStreamed: BigInt
    totalAmountStreamed_gt: BigInt
    totalAmountStreamed_gte: BigInt
    totalAmountStreamed_in: [BigInt!]
    totalAmountStreamed_lt: BigInt
    totalAmountStreamed_lte: BigInt
    totalAmountStreamed_not: BigInt
    totalAmountStreamed_not_in: [BigInt!]
}

input StreamRevision_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    periodRevisionIndex: Int
    periodRevisionIndex_gt: Int
    periodRevisionIndex_gte: Int
    periodRevisionIndex_in: [Int!]
    periodRevisionIndex_lt: Int
    periodRevisionIndex_lte: Int
    periodRevisionIndex_not: Int
    periodRevisionIndex_not_in: [Int!]
    revisionIndex: Int
    revisionIndex_gt: Int
    revisionIndex_gte: Int
    revisionIndex_in: [Int!]
    revisionIndex_lt: Int
    revisionIndex_lte: Int
    revisionIndex_not: Int
    revisionIndex_not_in: [Int!]
}

input Stream_filter {
    createdAtBlockNumber: BigInt
    createdAtBlockNumber_gt: BigInt
    createdAtBlockNumber_gte: BigInt
    createdAtBlockNumber_in: [BigInt!]
    createdAtBlockNumber_lt: BigInt
    createdAtBlockNumber_lte: BigInt
    createdAtBlockNumber_not: BigInt
    createdAtBlockNumber_not_in: [BigInt!]
    createdAtTimestamp: BigInt
    createdAtTimestamp_gt: BigInt
    createdAtTimestamp_gte: BigInt
    createdAtTimestamp_in: [BigInt!]
    createdAtTimestamp_lt: BigInt
    createdAtTimestamp_lte: BigInt
    createdAtTimestamp_not: BigInt
    createdAtTimestamp_not_in: [BigInt!]
    currentFlowRate: BigInt
    currentFlowRate_gt: BigInt
    currentFlowRate_gte: BigInt
    currentFlowRate_in: [BigInt!]
    currentFlowRate_lt: BigInt
    currentFlowRate_lte: BigInt
    currentFlowRate_not: BigInt
    currentFlowRate_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    receiver: String
    receiver_contains: String
    receiver_ends_with: String
    receiver_gt: String
    receiver_gte: String
    receiver_in: [String!]
    receiver_lt: String
    receiver_lte: String
    receiver_not: String
    receiver_not_contains: String
    receiver_not_ends_with: String
    receiver_not_in: [String!]
    receiver_not_starts_with: String
    receiver_starts_with: String
    sender: String
    sender_contains: String
    sender_ends_with: String
    sender_gt: String
    sender_gte: String
    sender_in: [String!]
    sender_lt: String
    sender_lte: String
    sender_not: String
    sender_not_contains: String
    sender_not_ends_with: String
    sender_not_in: [String!]
    sender_not_starts_with: String
    sender_starts_with: String
    streamedUntilUpdatedAt: BigInt
    streamedUntilUpdatedAt_gt: BigInt
    streamedUntilUpdatedAt_gte: BigInt
    streamedUntilUpdatedAt_in: [BigInt!]
    streamedUntilUpdatedAt_lt: BigInt
    streamedUntilUpdatedAt_lte: BigInt
    streamedUntilUpdatedAt_not: BigInt
    streamedUntilUpdatedAt_not_in: [BigInt!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    updatedAtBlockNumber: BigInt
    updatedAtBlockNumber_gt: BigInt
    updatedAtBlockNumber_gte: BigInt
    updatedAtBlockNumber_in: [BigInt!]
    updatedAtBlockNumber_lt: BigInt
    updatedAtBlockNumber_lte: BigInt
    updatedAtBlockNumber_not: BigInt
    updatedAtBlockNumber_not_in: [BigInt!]
    updatedAtTimestamp: BigInt
    updatedAtTimestamp_gt: BigInt
    updatedAtTimestamp_gte: BigInt
    updatedAtTimestamp_in: [BigInt!]
    updatedAtTimestamp_lt: BigInt
    updatedAtTimestamp_lte: BigInt
    updatedAtTimestamp_not: BigInt
    updatedAtTimestamp_not_in: [BigInt!]
}

input SubscriptionApprovedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    subscription: String
    subscription_contains: String
    subscription_ends_with: String
    subscription_gt: String
    subscription_gte: String
    subscription_in: [String!]
    subscription_lt: String
    subscription_lte: String
    subscription_not: String
    subscription_not_contains: String
    subscription_not_ends_with: String
    subscription_not_in: [String!]
    subscription_not_starts_with: String
    subscription_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input SubscriptionDistributionClaimedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    subscription: String
    subscription_contains: String
    subscription_ends_with: String
    subscription_gt: String
    subscription_gte: String
    subscription_in: [String!]
    subscription_lt: String
    subscription_lte: String
    subscription_not: String
    subscription_not_contains: String
    subscription_not_ends_with: String
    subscription_not_in: [String!]
    subscription_not_starts_with: String
    subscription_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input SubscriptionRevokedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    subscription: String
    subscription_contains: String
    subscription_ends_with: String
    subscription_gt: String
    subscription_gte: String
    subscription_in: [String!]
    subscription_lt: String
    subscription_lte: String
    subscription_not: String
    subscription_not_contains: String
    subscription_not_ends_with: String
    subscription_not_in: [String!]
    subscription_not_starts_with: String
    subscription_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input SubscriptionUnitsUpdatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    indexId: BigInt
    indexId_gt: BigInt
    indexId_gte: BigInt
    indexId_in: [BigInt!]
    indexId_lt: BigInt
    indexId_lte: BigInt
    indexId_not: BigInt
    indexId_not_in: [BigInt!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    oldUnits: BigInt
    oldUnits_gt: BigInt
    oldUnits_gte: BigInt
    oldUnits_in: [BigInt!]
    oldUnits_lt: BigInt
    oldUnits_lte: BigInt
    oldUnits_not: BigInt
    oldUnits_not_in: [BigInt!]
    publisher: Bytes
    publisher_contains: Bytes
    publisher_in: [Bytes!]
    publisher_not: Bytes
    publisher_not_contains: Bytes
    publisher_not_in: [Bytes!]
    subscriber: Bytes
    subscriber_contains: Bytes
    subscriber_in: [Bytes!]
    subscriber_not: Bytes
    subscriber_not_contains: Bytes
    subscriber_not_in: [Bytes!]
    subscription: String
    subscription_contains: String
    subscription_ends_with: String
    subscription_gt: String
    subscription_gte: String
    subscription_in: [String!]
    subscription_lt: String
    subscription_lte: String
    subscription_not: String
    subscription_not_contains: String
    subscription_not_ends_with: String
    subscription_not_in: [String!]
    subscription_not_starts_with: String
    subscription_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    units: BigInt
    units_gt: BigInt
    units_gte: BigInt
    units_in: [BigInt!]
    units_lt: BigInt
    units_lte: BigInt
    units_not: BigInt
    units_not_in: [BigInt!]
    userData: Bytes
    userData_contains: Bytes
    userData_in: [Bytes!]
    userData_not: Bytes
    userData_not_contains: Bytes
    userData_not_in: [Bytes!]
}

input SuperTokenCreatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input SuperTokenFactoryUpdatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    newFactory: Bytes
    newFactory_contains: Bytes
    newFactory_in: [Bytes!]
    newFactory_not: Bytes
    newFactory_not_contains: Bytes
    newFactory_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input SuperTokenLogicCreatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    tokenLogic: Bytes
    tokenLogic_contains: Bytes
    tokenLogic_in: [Bytes!]
    tokenLogic_not: Bytes
    tokenLogic_not_contains: Bytes
    tokenLogic_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input SuperTokenLogicUpdatedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    code: Bytes
    code_contains: Bytes
    code_in: [Bytes!]
    code_not: Bytes
    code_not_contains: Bytes
    code_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input TokenDowngradedEvent_filter {
    account: String
    account_contains: String
    account_ends_with: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_ends_with: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_starts_with: String
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input TokenStatistic_filter {
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    token: String
    token_contains: String
    token_ends_with: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_ends_with: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_starts_with: String
    totalAmountDistributedUntilUpdatedAt: BigInt
    totalAmountDistributedUntilUpdatedAt_gt: BigInt
    totalAmountDistributedUntilUpdatedAt_gte: BigInt
    totalAmountDistributedUntilUpdatedAt_in: [BigInt!]
    totalAmountDistributedUntilUpdatedAt_lt: BigInt
    totalAmountDistributedUntilUpdatedAt_lte: BigInt
    totalAmountDistributedUntilUpdatedAt_not: BigInt
    totalAmountDistributedUntilUpdatedAt_not_in: [BigInt!]
    totalAmountStreamedUntilUpdatedAt: BigInt
    totalAmountStreamedUntilUpdatedAt_gt: BigInt
    totalAmountStreamedUntilUpdatedAt_gte: BigInt
    totalAmountStreamedUntilUpdatedAt_in: [BigInt!]
    totalAmountStreamedUntilUpdatedAt_lt: BigInt
    totalAmountStreamedUntilUpdatedAt_lte: BigInt
    totalAmountStreamedUntilUpdatedAt_not: BigInt
    totalAmountStreamedUntilUpdatedAt_not_in: [BigInt!]
    totalAmountTransferredUntilUpdatedAt: BigInt
    totalAmountTransferredUntilUpdatedAt_gt: BigInt
    totalAmountTransferredUntilUpdatedAt_gte: BigInt
    totalAmountTransferredUntilUpdatedAt_in: [BigInt!]
    totalAmountTransferredUntilUpdatedAt_lt: BigInt
    totalAmountTransferredUntilUpdatedAt_lte: BigInt
    totalAmountTransferredUntilUpdatedAt_not: BigInt
    totalAmountTransferredUntilUpdatedAt_not_in: [BigInt!]
    totalApprovedSubscriptions: Int
    totalApprovedSubscriptions_gt: Int
    totalApprovedSubscriptions_gte: Int
    totalApprovedSubscriptions_in: [Int!]
    totalApprovedSubscriptions_lt: Int
    totalApprovedSubscriptions_lte: Int
    totalApprovedSubscriptions_not: Int
    totalApprovedSubscriptions_not_in: [Int!]
    totalNumberOfActiveIndexes: Int
    totalNumberOfActiveIndexes_gt: Int
    totalNumberOfActiveIndexes_gte: Int
    totalNumberOfActiveIndexes_in: [Int!]
    totalNumberOfActiveIndexes_lt: Int
    totalNumberOfActiveIndexes_lte: Int
    totalNumberOfActiveIndexes_not: Int
    totalNumberOfActiveIndexes_not_in: [Int!]
    totalNumberOfActiveStreams: Int
    totalNumberOfActiveStreams_gt: Int
    totalNumberOfActiveStreams_gte: Int
    totalNumberOfActiveStreams_in: [Int!]
    totalNumberOfActiveStreams_lt: Int
    totalNumberOfActiveStreams_lte: Int
    totalNumberOfActiveStreams_not: Int
    totalNumberOfActiveStreams_not_in: [Int!]
    totalNumberOfClosedStreams: Int
    totalNumberOfClosedStreams_gt: Int
    totalNumberOfClosedStreams_gte: Int
    totalNumberOfClosedStreams_in: [Int!]
    totalNumberOfClosedStreams_lt: Int
    totalNumberOfClosedStreams_lte: Int
    totalNumberOfClosedStreams_not: Int
    totalNumberOfClosedStreams_not_in: [Int!]
    totalNumberOfIndexes: Int
    totalNumberOfIndexes_gt: Int
    totalNumberOfIndexes_gte: Int
    totalNumberOfIndexes_in: [Int!]
    totalNumberOfIndexes_lt: Int
    totalNumberOfIndexes_lte: Int
    totalNumberOfIndexes_not: Int
    totalNumberOfIndexes_not_in: [Int!]
    totalOutflowRate: BigInt
    totalOutflowRate_gt: BigInt
    totalOutflowRate_gte: BigInt
    totalOutflowRate_in: [BigInt!]
    totalOutflowRate_lt: BigInt
    totalOutflowRate_lte: BigInt
    totalOutflowRate_not: BigInt
    totalOutflowRate_not_in: [BigInt!]
    totalSubscriptionsWithUnits: Int
    totalSubscriptionsWithUnits_gt: Int
    totalSubscriptionsWithUnits_gte: Int
    totalSubscriptionsWithUnits_in: [Int!]
    totalSubscriptionsWithUnits_lt: Int
    totalSubscriptionsWithUnits_lte: Int
    totalSubscriptionsWithUnits_not: Int
    totalSubscriptionsWithUnits_not_in: [Int!]
    totalSupply: BigInt
    totalSupply_gt: BigInt
    totalSupply_gte: BigInt
    totalSupply_in: [BigInt!]
    totalSupply_lt: BigInt
    totalSupply_lte: BigInt
    totalSupply_not: BigInt
    totalSupply_not_in: [BigInt!]
    updatedAtBlockNumber: BigInt
    updatedAtBlockNumber_gt: BigInt
    updatedAtBlockNumber_gte: BigInt
    updatedAtBlockNumber_in: [BigInt!]
    updatedAtBlockNumber_lt: BigInt
    updatedAtBlockNumber_lte: BigInt
    updatedAtBlockNumber_not: BigInt
    updatedAtBlockNumber_not_in: [BigInt!]
    updatedAtTimestamp: BigInt
    updatedAtTimestamp_gt: BigInt
    updatedAtTimestamp_gte: BigInt
    updatedAtTimestamp_in: [BigInt!]
    updatedAtTimestamp_lt: BigInt
    updatedAtTimestamp_lte: BigInt
    updatedAtTimestamp_not: BigInt
    updatedAtTimestamp_not_in: [BigInt!]
}

input TokenUpgradedEvent_filter {
    account: String
    account_contains: String
    account_ends_with: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_ends_with: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_starts_with: String
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}

input Token_filter {
    createdAtBlockNumber: BigInt
    createdAtBlockNumber_gt: BigInt
    createdAtBlockNumber_gte: BigInt
    createdAtBlockNumber_in: [BigInt!]
    createdAtBlockNumber_lt: BigInt
    createdAtBlockNumber_lte: BigInt
    createdAtBlockNumber_not: BigInt
    createdAtBlockNumber_not_in: [BigInt!]
    createdAtTimestamp: BigInt
    createdAtTimestamp_gt: BigInt
    createdAtTimestamp_gte: BigInt
    createdAtTimestamp_in: [BigInt!]
    createdAtTimestamp_lt: BigInt
    createdAtTimestamp_lte: BigInt
    createdAtTimestamp_not: BigInt
    createdAtTimestamp_not_in: [BigInt!]
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isListed: Boolean
    isListed_in: [Boolean!]
    isListed_not: Boolean
    isListed_not_in: [Boolean!]
    isSuperToken: Boolean
    isSuperToken_in: [Boolean!]
    isSuperToken_not: Boolean
    isSuperToken_not_in: [Boolean!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    symbol: String
    symbol_contains: String
    symbol_ends_with: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_ends_with: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_starts_with: String
    underlyingAddress: Bytes
    underlyingAddress_contains: Bytes
    underlyingAddress_in: [Bytes!]
    underlyingAddress_not: Bytes
    underlyingAddress_not_contains: Bytes
    underlyingAddress_not_in: [Bytes!]
    underlyingToken: String
    underlyingToken_contains: String
    underlyingToken_ends_with: String
    underlyingToken_gt: String
    underlyingToken_gte: String
    underlyingToken_in: [String!]
    underlyingToken_lt: String
    underlyingToken_lte: String
    underlyingToken_not: String
    underlyingToken_not_contains: String
    underlyingToken_not_ends_with: String
    underlyingToken_not_in: [String!]
    underlyingToken_not_starts_with: String
    underlyingToken_starts_with: String
}

input TransferEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    from: String
    from_contains: String
    from_ends_with: String
    from_gt: String
    from_gte: String
    from_in: [String!]
    from_lt: String
    from_lte: String
    from_not: String
    from_not_contains: String
    from_not_ends_with: String
    from_not_in: [String!]
    from_not_starts_with: String
    from_starts_with: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    to: String
    to_contains: String
    to_ends_with: String
    to_gt: String
    to_gte: String
    to_in: [String!]
    to_lt: String
    to_lte: String
    to_not: String
    to_not_contains: String
    to_not_ends_with: String
    to_not_in: [String!]
    to_not_starts_with: String
    to_starts_with: String
    token: Bytes
    token_contains: Bytes
    token_in: [Bytes!]
    token_not: Bytes
    token_not_contains: Bytes
    token_not_in: [Bytes!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
    value: BigInt
    value_gt: BigInt
    value_gte: BigInt
    value_in: [BigInt!]
    value_lt: BigInt
    value_lte: BigInt
    value_not: BigInt
    value_not_in: [BigInt!]
}

input TrustedForwarderChangedEvent_filter {
    addresses: [Bytes!]
    addresses_contains: [Bytes!]
    addresses_not: [Bytes!]
    addresses_not_contains: [Bytes!]
    blockNumber: BigInt
    blockNumber_gt: BigInt
    blockNumber_gte: BigInt
    blockNumber_in: [BigInt!]
    blockNumber_lt: BigInt
    blockNumber_lte: BigInt
    blockNumber_not: BigInt
    blockNumber_not_in: [BigInt!]
    enabled: Boolean
    enabled_in: [Boolean!]
    enabled_not: Boolean
    enabled_not_in: [Boolean!]
    forwarder: Bytes
    forwarder_contains: Bytes
    forwarder_in: [Bytes!]
    forwarder_not: Bytes
    forwarder_not_contains: Bytes
    forwarder_not_in: [Bytes!]
    host: Bytes
    host_contains: Bytes
    host_in: [Bytes!]
    host_not: Bytes
    host_not_contains: Bytes
    host_not_in: [Bytes!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isSet: Boolean
    isSet_in: [Boolean!]
    isSet_not: Boolean
    isSet_not_in: [Boolean!]
    name: String
    name_contains: String
    name_ends_with: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_ends_with: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_starts_with: String
    superToken: Bytes
    superToken_contains: Bytes
    superToken_in: [Bytes!]
    superToken_not: Bytes
    superToken_not_contains: Bytes
    superToken_not_in: [Bytes!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    transactionHash: Bytes
    transactionHash_contains: Bytes
    transactionHash_in: [Bytes!]
    transactionHash_not: Bytes
    transactionHash_not_contains: Bytes
    transactionHash_not_in: [Bytes!]
}


scalar BigDecimal

scalar BigInt

scalar Bytes
