##################
# Event Entities #
##################
"""
Event: An interface which is shared by all event entities and contains basic transaction data.
"""
interface Event {
    """
    The id of the event entity.
    """
    id: ID!

    """
    The block number which the event was logged in.
    """
    blockNumber: BigInt!

    """
    The index of the event, e.g. first event emitted would have `logIndex` of 0.
    """
    logIndex: BigInt!

    """
    A number used internally to sort the order of transactions.
    The formula: `blockNumber * ORDER_MULTIPLIER + logIndex`
    where: ORDER_MULTIPLIER = 10000
    """
    order: BigInt!

    """
    The name of the event - is a 1-to-1 match with the name in our smart contracts.
    """
    name: String!

    """
    Contains the addresses for accounts that were "impacted" by the event.
    This typically involves accounts which experienced a state change as a result of the transaction which emitted this event.
    """
    addresses: [Bytes!]!

    """
    The block timestamp which the event was logged in.
    """
    timestamp: BigInt!

    """
    The transaction hash of the transaction that the event was logged in.
    """
    transactionHash: Bytes!

    """
    The gas price of the transaction that the event was logged in.
    """
    gasPrice: BigInt!
}

#     ConstantFlowAgreementV1    #
"""
FlowUpdated: An `Event` entity that is emitted
when a flow is created, updated, or deleted.
"""
type FlowUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (supertoken)
    addresses[1] = `sender`
    addresses[2] = `receiver`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    """
    The address of the `token` (supertoken) being streamed.
    """
    token: Bytes!

    """
    The address of the flow sender.
    """
    sender: Bytes!

    """
    The address of the flow receiver.
    """
    receiver: Bytes!

    """
    The address that is executing the flow update transaction.
    This will be the zero address until the flowOperator feature is live.
    """
    flowOperator: Bytes!

    """
    The flow rate per second.
    """
    flowRate: BigInt!

    """
    The total (global/account level) flow rate of `sender` for `token` as of this event.
    """
    totalSenderFlowRate: BigInt!

    """
    The total (global/account level) flow rate of `receiver` for `token` as of this event.
    """
    totalReceiverFlowRate: BigInt!

    """
    The deposit amount put up for the creation of the flow.
    """
    deposit: BigInt!

    """
    Arbitrary bytes (additional data) passed upon flow creation.
    """
    userData: Bytes!

    # Custom Properties (not on event)

    """
    The previous flow rate, the absolute (positive) value.
    """
    oldFlowRate: BigInt!

    """
    The "type" of the `FlowUpdated` event.
    0 = create
    1 = update
    2 = terminate
    """
    type: Int!

    """
    The total amount streamed until the timestamp
    for the Stream entity linked to this event.
    """
    totalAmountStreamedUntilTimestamp: BigInt!

    # ---------------------------------- links ----------------------------------
    """
    The stream entity which is being modified.
    """
    stream: Stream!
}

type FlowOperatorUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = sender
    addresses[2] = `flowOperator`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    """
    The address of the `token` being streamed.
    """
    token: Bytes!
    sender: Bytes!

    """
    The permissions granted to the `flowOperator`.
    Octo bitmask representation.
    """
    permissions: Int!
    flowRateAllowance: BigInt!

    # ---------------------------------- links ----------------------------------
    flowOperator: FlowOperator!
}

#  InstantDistributionAgreementV1 #
type IndexCreatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!
    userData: Bytes!

    # ---------------------------------- links ----------------------------------
    index: Index!
}

type IndexDistributionClaimedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!
    amount: BigInt!

    # ---------------------------------- links ----------------------------------
    index: Index!
}

type IndexUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!
    oldIndexValue: BigInt!
    newIndexValue: BigInt!
    totalUnitsPending: BigInt!
    totalUnitsApproved: BigInt!
    userData: Bytes!

    # ---------------------------------- links ----------------------------------
    index: Index!
}

type IndexSubscribedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!
    userData: Bytes!

    # ---------------------------------- links ----------------------------------
    index: Index!
}

type IndexUnitsUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!
    units: BigInt!
    userData: Bytes!

    # Custom Properties (not on event)
    oldUnits: BigInt!

    # ---------------------------------- links ----------------------------------
    index: Index!
}

type IndexUnsubscribedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!
    userData: Bytes!

    # ---------------------------------- links ----------------------------------
    index: Index!
}

type SubscriptionApprovedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!
    userData: Bytes!

    # ---------------------------------- links ----------------------------------
    subscription: IndexSubscription!
}

type SubscriptionDistributionClaimedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!
    amount: BigInt!

    # ---------------------------------- links ----------------------------------
    subscription: IndexSubscription!
}

type SubscriptionRevokedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!
    userData: Bytes!

    # ---------------------------------- links ----------------------------------
    subscription: IndexSubscription!
}

type SubscriptionUnitsUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `publisher`
    addresses[2] = `subscriber`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!

    """
    The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
    `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
    """
    subscriber: Bytes!

    """
    The creator of the `index`.
    """
    publisher: Bytes!

    """
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!
    units: BigInt!
    userData: Bytes!

    # Custom Properties (not on event)
    oldUnits: BigInt!

    # ---------------------------------- links ----------------------------------
    subscription: IndexSubscription!
}

#     Host    #

type AgreementClassRegisteredEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    agreementType: Bytes!
    code: Bytes!
}

type AgreementClassUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    agreementType: Bytes!
    code: Bytes!
}

type AppRegisteredEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    app: Bytes!
}

type GovernanceReplacedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    oldGovernance: Bytes!
    newGovernance: Bytes!
}

type JailEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    app: Bytes!
    reason: BigInt!
}

type SuperTokenFactoryUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    newFactory: Bytes!
}

type SuperTokenLogicUpdatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!
    code: Bytes!
}

#     Resolver    #
type RoleAdminChangedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    role: Bytes!
    previousAdminRole: Bytes!
    newAdminRole: Bytes!
}

type RoleGrantedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    role: Bytes!
    account: Bytes!
    sender: Bytes!
}

type RoleRevokedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    role: Bytes!
    account: Bytes!
    sender: Bytes!
}

type SetEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    """
    Because the name property is indexed, the
    returned value will be a keccak256 hash
    of the string.
    """
    hashedName: Bytes!
    target: Bytes!

    resolverEntry: ResolverEntry!
}

#     SuperfluidGovernance    #
type CFAv1LiquidationPeriodChangedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    The address of the governance contract the event was emitted from.
    """
    governanceAddress: Bytes!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    order: BigInt!
    logIndex: BigInt!
    host: Bytes!
    superToken: Bytes!
    isKeySet: Boolean! # changed from Set due to strange bug w/ TheGraph
    liquidationPeriod: BigInt!
}

type ConfigChangedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    The address of the governance contract the event was emitted from.
    """
    governanceAddress: Bytes!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    host: Bytes!
    superToken: Bytes!
    key: Bytes!
    isKeySet: Boolean! # changed from Set due to strange bug w/ TheGraph
    value: BigInt!
}

type RewardAddressChangedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    The address of the governance contract the event was emitted from.
    """
    governanceAddress: Bytes!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    host: Bytes!
    superToken: Bytes!
    isKeySet: Boolean! # changed from Set due to strange bug w/ TheGraph
    rewardAddress: Bytes!
}

type PPPConfigurationChangedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    The address of the governance contract the event was emitted from.
    """
    governanceAddress: Bytes!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    host: Bytes!
    superToken: Bytes!
    isKeySet: Boolean! # changed from Set due to strange bug w/ TheGraph
    liquidationPeriod: BigInt!
    patricianPeriod: BigInt!
}

type TrustedForwarderChangedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    The address of the governance contract the event was emitted from.
    """
    governanceAddress: Bytes!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!
    host: Bytes!
    superToken: Bytes!
    isKeySet: Boolean! # changed from Set due to strange bug w/ TheGraph
    forwarder: Bytes!
    enabled: Boolean!
}

#     SuperToken    #
"""
NOTE: This event was deprecated since the introduction of the 3Ps system.
Replaced by: `AgreementLiquidatedV2Event`
See: https://docs.superfluid.finance/superfluid/sentinels/liquidations-and-toga#patricians-plebs-and-pirates-3ps for more details on the 3Ps system.
See: https://github.com/superfluid-finance/protocol-monorepo/blob/dev/packages/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol#L425 for more details on the events.
"""
type AgreementLiquidatedByEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = liquidatorAccount (executor of liquidation)
    addresses[2] = penaltyAccount (the sender of the flow/stream)
    addresses[3] = bondAccount (the address receiving the reward - the reward account for the token, pre 3Ps)
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!
    liquidatorAccount: Bytes!
    agreementClass: Bytes!
    agreementId: Bytes!
    penaltyAccount: Bytes!
    bondAccount: Bytes!
    rewardAmount: BigInt!
    bailoutAmount: BigInt!

    """
    The full deposit amount of the stream that was liquidated.
    """
    deposit: BigInt!
}

type AgreementLiquidatedV2Event implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `liquidatorAccount` (executor of liquidation)
    addresses[2] = `targetAccount` (the sender of the flow/stream)
    addresses[3] = `rewardAmountReceiver` (the address receiving the reward) addresses
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!
    agreementClass: Bytes!
    agreementId: Bytes!
    liquidatorAccount: Bytes!
    targetAccount: Bytes!
    rewardAmountReceiver: Bytes!
    rewardAmount: BigInt!
    targetAccountBalanceDelta: BigInt!
    version: BigInt!
    liquidationType: Int!

    """
    The full deposit amount of the stream that was liquidated.
    """
    deposit: BigInt!

    """
    TO BE DEPRECATED in v2 endpoint - use rewardAmountReceiver instead
    """
    rewardAccount: Bytes! @deprecated(reason: "use rewardAmountReceiver")
}

type BurnedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `from`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    operator: Bytes!
    from: Bytes!
    token: Bytes!
    amount: BigInt!
    data: Bytes!
    operatorData: Bytes!
}

type MintedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `operator`
    addresses[2] = `to`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    operator: Bytes!
    to: Bytes!
    amount: BigInt!
    data: Bytes!
    token: Bytes!
    operatorData: Bytes!
}

type SentEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `operator`
    addresses[2] = `from`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    operator: Bytes!
    from: Bytes!
    to: Bytes!
    token: Bytes!
    amount: BigInt!
    data: Bytes!
    operatorData: Bytes!
}

type TransferEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `from`
    addresses[2] = `to`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    from: Account!
    to: Account!
    value: BigInt!
    token: Bytes!
}

type TokenDowngradedEvent implements Event @entity {
    id: ID!
    account: Account!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `account`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!
    amount: BigInt!
}

type TokenUpgradedEvent implements Event @entity {
    id: ID!
    account: Account!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    addresses[1] = `account`
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!
    amount: BigInt!
}

#     SuperTokenFactory    #

type CustomSuperTokenCreatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!
}

type SuperTokenCreatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Contains the addresses that were impacted by this event:
    addresses[0] = `token` (superToken)
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    token: Bytes!
}

type SuperTokenLogicCreatedEvent implements Event @entity {
    id: ID!
    transactionHash: Bytes!
    gasPrice: BigInt!
    timestamp: BigInt!
    name: String!

    """
    Empty addresses array.
    """
    addresses: [Bytes!]!
    blockNumber: BigInt!
    logIndex: BigInt!
    order: BigInt!

    tokenLogic: Bytes!
}

#########################
# Higher Order Entities #
#########################
# State is defined as properties that will change outside
# of the BaseEntity properties.
# Links is defined as a property which links the current
# entity to another higher order entity.

"""
Account: A higher order entity created for any addresses which interact with Superfluid contracts.
"""
type Account @entity {
    id: ID!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!

    """
    Indicates whether the address/account is a super app.
    """
    isSuperApp: Boolean!

    # ---------------------------------- links ----------------------------------
    inflows: [Stream!]! @derivedFrom(field: "receiver")
    outflows: [Stream!]! @derivedFrom(field: "sender")

    subscriptions: [IndexSubscription!]! @derivedFrom(field: "subscriber")
    publishedIndexes: [Index!]! @derivedFrom(field: "publisher")

    sentTransferEvents: [TransferEvent!]! @derivedFrom(field: "from")
    receivedTransferEvents: [TransferEvent!]! @derivedFrom(field: "to")

    tokenUpgradedEvents: [TokenUpgradedEvent!]! @derivedFrom(field: "account")
    tokenDowngradedEvents: [TokenDowngradedEvent!]!
        @derivedFrom(field: "account")

    accountTokenSnapshots: [AccountTokenSnapshot!]!
        @derivedFrom(field: "account")
}

"""
Index: An Index higher order entity.
"""
type Index @entity {
    """
    ID composed of: publisherAddress-tokenAddress-indexId
    """
    id: ID!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!

    """
    NOTE: indexId is not the same as the id of the `Index` entity.
    An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
    """
    indexId: BigInt!
    # ---------------------------------- state ----------------------------------

    indexValue: BigInt!

    """
    The number of subscriptions which have units allocated to them on the `Index`.
    """
    totalSubscriptionsWithUnits: Int!

    """
    The number of units allocated by the `Index` that are pending.
    This refers to the current (as of updatedAt) `totalUnitsPending`-not all that has ever been pending.
    """
    totalUnitsPending: BigInt!

    """
    The number of units allocated by the `Index` that are approved.
    This refers to the current (as of updatedAt) `totalUnitsApproved`-not all that has ever been approved.
    """
    totalUnitsApproved: BigInt!

    """
    The sum of `totalUnitsPending` and `totalUnitsApproved`.
    """
    totalUnits: BigInt!

    """
    The total amount distributed from this `Index`.
    """
    totalAmountDistributedUntilUpdatedAt: BigInt!

    # ---------------------------------- links ----------------------------------
    token: Token!
    publisher: Account!

    """
    The subscriptions of the index, it will include approved, unapproved
    and deleted subscriptions.
    """
    subscriptions: [IndexSubscription!]! @derivedFrom(field: "index")

    """
    IndexCreated event, there will only be one.
    """
    indexCreatedEvent: IndexCreatedEvent!

    indexDistributionClaimedEvents: [IndexDistributionClaimedEvent!]!
        @derivedFrom(field: "index")

    indexUpdatedEvents: [IndexUpdatedEvent!]! @derivedFrom(field: "index")
    indexSubscribedEvents: [IndexSubscribedEvent!]! @derivedFrom(field: "index")
    indexUnitsUpdatedEvents: [IndexUnitsUpdatedEvent!]!
        @derivedFrom(field: "index")
    indexUnsubscribedEvents: [IndexUnsubscribedEvent!]!
        @derivedFrom(field: "index")
}

"""
IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
"""
type IndexSubscription @entity {
    """
    ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId
    """
    id: ID!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!
    subscriber: Account!

    # ---------------------------------- state ----------------------------------
    """
    A boolean indicating whether the `IndexSubscription` is approved.
    Approved subscriptions don't require `subscriber` to claim tokens that are distributed from the publisher.
    """
    approved: Boolean!

    """
    If `units` is `0`, it indicates that the subscription is "deleted" and `subscriber` is no longer subscribed to `index`.
    """
    units: BigInt!

    """
    The total amount of tokens you've received via IDA until
    `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountReceivedUntilUpdatedAt: BigInt!

    """
    The previous index value - used to calculate `totalAmountReceivedUntilUpdatedAt` field as of the `index.updatedAtTimestamp`.
    The formula to get this value is:
    `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue - indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
    """
    indexValueUntilUpdatedAt: BigInt!
    # ---------------------------------- links ----------------------------------
    index: Index!

    """
    IndexSubscription approved events on the subscription.
    """
    subscriptionApprovedEvents: [SubscriptionApprovedEvent!]!
        @derivedFrom(field: "subscription")

    subscriptionDistributionClaimedEvents: [SubscriptionDistributionClaimedEvent!]!
        @derivedFrom(field: "subscription")

    subscriptionRevokedEvents: [SubscriptionRevokedEvent!]!
        @derivedFrom(field: "subscription")

    subscriptionUnitsUpdatedEvents: [SubscriptionUnitsUpdatedEvent!]!
        @derivedFrom(field: "subscription")
}

"""
Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
The next stream you create with the same `sender` and `receiver` will create a new stream entity.
Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
"""
type Stream @entity {
    """
    ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex
    """
    id: ID!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!
    # ---------------------------------- state ----------------------------------
    currentFlowRate: BigInt!
    deposit: BigInt!

    """
    The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`. 
    The formula to get the current streamed amount is:
    `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
    """
    streamedUntilUpdatedAt: BigInt!
    # ---------------------------------- links ----------------------------------
    token: Token!
    sender: Account!
    receiver: Account!

    flowUpdatedEvents: [FlowUpdatedEvent!]! @derivedFrom(field: "stream")
    streamPeriods: [StreamPeriod!]! @derivedFrom(field: "stream")
}

"""
FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`.
"""
type FlowOperator @entity {
    """
    ID composed of: flowOperator-token-sender
    """
    id: ID!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!

    """
    The permissions granted to the `flowOperator`.
    Bitmask representation:
    Delete | Update | Create
    | D | U | C |
    | 0 | 0 | 0 |
    """
    permissions: Int!

    """
    The flow rate allowance granted to the `flowOperator` by the `sender`. This can be reset if the `sender` updates the `flowOperator` flow rate allowance.
    """
    flowRateAllowanceGranted: BigInt!

    """
    The remaining flow rate allowance the `flowOperator` has.
    This will go down every time when the `flowOperator` uses the allowance, that is, if they increase flowRate for `sender` or create a new flow on behalf of `sender`.
    It can only be reset if the `sender` updates the flow rate allowance.
    NOTE: this value will NOT go down if max flow rate allowance is set.
    """
    flowRateAllowanceRemaining: BigInt!

    # ---------------------------------- links ----------------------------------
    flowOperator: Bytes!
    sender: Account!
    token: Token!
    accountTokenSnapshot: AccountTokenSnapshot!

    flowOperatorUpdatedEvents: [FlowOperatorUpdatedEvent!]!
        @derivedFrom(field: "flowOperator")
}

"""
StreamPeriod: A higher order entity that represents a period of time in a Stream with a constant flowRate.
"""
type StreamPeriod @entity {
    """
    ID composed of: streamId - periodRevisionIndex
    """
    id: ID!

    stream: Stream!

    sender: Account!
    receiver: Account!

    token: Token!

    flowRate: BigInt!
    deposit: BigInt!

    startedAtTimestamp: BigInt!
    startedAtBlockNumber: BigInt!
    startedAtEvent: FlowUpdatedEvent!
    """
    Following values are null until the StreamPeriod is terminated
    """
    stoppedAtTimestamp: BigInt
    stoppedAtBlockNumber: BigInt
    stoppedAtEvent: FlowUpdatedEvent

    totalAmountStreamed: BigInt
}

####################
#  Helper Entities #
####################
type StreamRevision @entity {
    """
    ID composed of: keccak256(abi.encode(sender,receiver))-tokenAddress
    """
    id: ID!
    revisionIndex: Int!
    periodRevisionIndex: Int!

    """
    The "most recently alive" stream between a sender and receiver.
    Note: The `revisionIndex` property may not be the same as the `revisionIndex` of `mostRecentStream`. Which means `mostRecentStream` has been closed and no new stream has been opened.
    """
    mostRecentStream: Stream!
}

"""
Token: A higher order entity created for super tokens (and underlying tokens) that are "valid" (tokens that have Superfluid's host contract address set as the host).
"""
type Token @entity {
    """
    ID: the token address
    """
    id: ID!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
    decimals: Int!
    name: String!
    symbol: String!
    isSuperToken: Boolean!

    """
    A boolean indicating whether the token is a NativeAssetSuperToken.
    """
    isNativeAssetSuperToken: Boolean!

    """
    A boolean indicating whether the token is a part of our resolver list.
    """
    isListed: Boolean!

    """
    The address of the underlying ERC20 token (zero address for non-ERC20WrapperSuperToken's)
    """
    underlyingAddress: Bytes! # Underlying ERC20
    """
    The underlying ERC20 token for a ERC20WrapperSuperToken otherwise null.
    """
    underlyingToken: Token
}

type ResolverEntry @entity {
    """
    ID: the keccak256 hash of the set name
    """
    id: ID!
    createdAtTimestamp: BigInt!
    createdAtBlockNumber: BigInt!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!
    targetAddress: Bytes!
    isToken: Boolean!
    isListed: Boolean!

    setEvents: [SetEvent!]! @derivedFrom(field: "resolverEntry")
}

####################
#  Aggr. Entities  #
####################
"""
AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.
"""
type AccountTokenSnapshot @entity {
    """
    ID composed of: accountID-tokenID
    """
    id: ID!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!
    # ---------------------------------- state ----------------------------------
    """
    isLiquidationEstimateOptimistic, If `totalSubscriptionsWithUnits > 0`, it is true.
    "Optimistic" can be thought of as conservative as it refers to the earliest time the user may be liquidated as they may receive ongoing distributions which aren't tracked by the subgraph.
    """
    isLiquidationEstimateOptimistic: Boolean!

    """
    Optimistic liquidation estimation property.
    """
    maybeCriticalAtTimestamp: BigInt

    """
    The number of currently open streams.
    """
    totalNumberOfActiveStreams: Int!

    """
    The count of closed streams by `account`.
    """
    totalNumberOfClosedStreams: Int!

    """
    The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`.
    """
    totalSubscriptionsWithUnits: Int!

    """
    Counts all currently (as of updatedAt) approved subscriptions whether or not they have units.
    """
    totalApprovedSubscriptions: Int!

    """
    Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
    """
    balanceUntilUpdatedAt: BigInt!

    """
    The total deposit this account has held by the CFA agreement for `account` active streams.
    """
    totalDeposit: BigInt!

    """
    The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalNetFlowRate: BigInt!

    """
    The total inflow rate (receive flowRate per second) of the `account`.
    """
    totalInflowRate: BigInt!

    """
    The total outflow rate (send flowrate per second) of the `account`.
    """
    totalOutflowRate: BigInt!

    """
    The total amount of `token` streamed into this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountStreamedInUntilUpdatedAt: BigInt!

    """
    The total amount of `token` streamed from this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountStreamedOutUntilUpdatedAt: BigInt!

    """
    The total amount of `token` streamed through this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountStreamedUntilUpdatedAt: BigInt!

    """
    The total amount of `token` this `account` has transferred.
    """
    totalAmountTransferredUntilUpdatedAt: BigInt!
    # ---------------------------------- links ----------------------------------
    account: Account!
    token: Token!
    flowOperators: [FlowOperator!]! @derivedFrom(field: "accountTokenSnapshot")
    accountTokenSnapshotLogs: [AccountTokenSnapshotLog!]!
        @derivedFrom(field: "accountTokenSnapshot")
}

"""
AccountTokenSnapshotLog: Historical entries of `AccountTokenSnapshot` updates.
"""
type AccountTokenSnapshotLog @entity {
    id: ID!
    timestamp: BigInt!
    blockNumber: BigInt!

    transactionHash: Bytes!
    logIndex: BigInt!
    order: BigInt!
    triggeredByEventName: String!

    # ---------------------------------- state ----------------------------------
    """
    Optimistic liquidation estimation property.
    """
    maybeCriticalAtTimestamp: BigInt
    """
    The current (as of timestamp) number of open streams.
    """
    totalNumberOfActiveStreams: Int!

    """
    The current (as of timestamp) count of closed streams.
    """
    totalNumberOfClosedStreams: Int!

    """
    The current (as of timestamp) number of subscriptions with units allocated to them tied to this `account`.
    """
    totalSubscriptionsWithUnits: Int!

    """
    Counts all currently (as of timestamp) approved subscriptions whether or not they have units.
    """
    totalApprovedSubscriptions: Int!

    """
    Balance of `account` as of `timestamp`/`block`.
    """
    balance: BigInt!

    """
    The total (as of timestamp) deposit this account has held by the CFA agreement for `account` active streams.
    """
    totalDeposit: BigInt!

    """
    The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block`.
    This can be obtained by: `totalInflowRate - totalOutflowRate` 
    """
    totalNetFlowRate: BigInt!

    """
    The total (as of timestamp) inflow rate (receive flowRate per second) of the `account`.
    """
    totalInflowRate: BigInt!

    """
    The total (as of timestamp) outflow rate (send flowrate per second) of the `account`.
    """
    totalOutflowRate: BigInt!

    """
    The total (as of timestamp) amount of `token` streamed into this `account` until the `timestamp`/`block`.
    """
    totalAmountStreamedIn: BigInt!

    """
    The total (as of timestamp) amount of `token` streamed from this `account` until the `timestamp`/`block`.
    """
    totalAmountStreamedOut: BigInt!

    """
    The total (as of timestamp) net amount of `token` streamed through this `account` until the `timestamp`/`block`.
    """
    totalAmountStreamed: BigInt!

    """
    The total (as of timestamp) amount of `token` this `account` has transferred out until the `timestamp`/`block`.
    """
    totalAmountTransferred: BigInt!
    # ---------------------------------- links ----------------------------------
    account: Account!
    token: Token!
    accountTokenSnapshot: AccountTokenSnapshot!
}

"""
TokenStatistic: An aggregate entity which contains aggregate data for `token`.
"""
type TokenStatistic @entity {
    """
    id: `token` (superToken) address
    """
    id: ID!
    updatedAtTimestamp: BigInt!
    updatedAtBlockNumber: BigInt!
    # ---------------------------------- state ----------------------------------
    """
    The total number of currently active `token` streams.
    """
    totalNumberOfActiveStreams: Int!

    """
    The count of closed streams for `token`.
    """
    totalNumberOfClosedStreams: Int!

    """
    The total number of Indexes created with `token`.
    """
    totalNumberOfIndexes: Int!

    """
    The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
    """
    totalNumberOfActiveIndexes: Int!

    """
    The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
    """
    totalSubscriptionsWithUnits: Int!

    """
    Counts all approved subscriptions whether or not they have units.
    """
    totalApprovedSubscriptions: Int!

    """
    The total deposit held by the CFA agreement for this particular `token`.
    """
    totalDeposit: BigInt!

    """
    The total outflow rate of the `token` (how much value is being moved).
    """
    totalOutflowRate: BigInt!

    """
    The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountStreamedUntilUpdatedAt: BigInt!

    """
    The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountTransferredUntilUpdatedAt: BigInt!

    """
    The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`.
    """
    totalAmountDistributedUntilUpdatedAt: BigInt!

    """
    The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
    """
    totalSupply: BigInt!

    # ---------------------------------- links ----------------------------------
    token: Token!
    tokenStatisticLogs: [TokenStatisticLog!]!
        @derivedFrom(field: "tokenStatistic")
}

"""
TokenStatisticLog: Historical entries of `TokenStatistic` updates.
"""
type TokenStatisticLog @entity {
    id: ID!
    timestamp: BigInt!
    blockNumber: BigInt!

    transactionHash: Bytes!
    logIndex: BigInt!
    order: BigInt!
    triggeredByEventName: String!
    # ---------------------------------- state ----------------------------------
    """
    The total number of currently active `token` streams.
    """
    totalNumberOfActiveStreams: Int!

    """
    The count of closed streams for `token`.
    """
    totalNumberOfClosedStreams: Int!

    """
    The total number of Indexes created with `token`.
    """
    totalNumberOfIndexes: Int!

    """
    The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
    """
    totalNumberOfActiveIndexes: Int!

    """
    The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
    """
    totalSubscriptionsWithUnits: Int!

    """
    Counts all approved subscriptions whether or not they have units.
    """
    totalApprovedSubscriptions: Int!

    """
    The total deposit held by the CFA agreement for this particular `token`.
    """
    totalDeposit: BigInt!

    """
    The total outflow rate of the `token` (how much value is being moved).
    """
    totalOutflowRate: BigInt!

    """
    The all-time total amount of `token` streamed (outflows) until the `timestamp`/`block`.
    """
    totalAmountStreamed: BigInt!

    """
    The all-time total amount of `token` transferred until the `timestamp`/`block`.
    """
    totalAmountTransferred: BigInt!

    """
    The all-time total amount of `token` distributed until the `timestamp`/`block`.
    """
    totalAmountDistributed: BigInt!

    """
    The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
    """
    totalSupply: BigInt!

    # ---------------------------------- links ----------------------------------
    token: Token!
    tokenStatistic: TokenStatistic!
}

####################
#  Internal Entity #
####################

type SFMeta @entity {
    """
    The id is the commit hash.
    """
    id: ID!
    timestamp: BigInt!
    blockNumber: BigInt!
    """
    Whether the branch is feature/dev/v1.
    """
    configuration: String!
    """
    The branch the current deployment is coming from.
    """
    branch: String!
}
